#include "tcs.h"
#include "tcsmac.h"

void tcsAim2xe ( double xa, double ya, double za,
                 double a, double b, double np,
                 double xt, double yt, double zt,
                 double *xi, double *eta, int *j )

/*
**  - - - - - - - - - -
**   t c s A i m 2 x e
**  - - - - - - - - - -
**
**  In a "virtual telescope", given the AIM vector, and knowing the
**  mount roll/pitch, determine the [xi,eta] position of the image in
**  the focal plane.
**
**  Given:
**     xa       double        AIM x-coordinate
**     ya       double        AIM y-coordinate
**     za       double        AIM z-coordinate
**     a        double        mount "roll" (Note 2)
**     b        double        mount "pitch" (Note 2)
**     np       double        mount axes nonperpendicularity (radians)
**     xt       double        telescope vector, x-component (Note 3)
**     yt       double        telescope vector, y-component (Note 3)
**     zt       double        telescope vector, z-component (Note 3)
**
**  Returned:
**     xi       double*       image xi-coordinate (Note 4)
**     eta      double*       image eta-coordinate (Note 4)
**     j        int*          status:    0 = OK
**                                    else = star cannot be imaged
**
**  Defined in tcsmac.h:
**     TINY     double        a small number
**
**  Called:  tcsPosture
**
**  Notes:
**
**  1  A "virtual telescope" is a group of transformations that link
**     three sets of coordinates:
**
**       (i)  the target (where in the sky the source is);
**
**      (ii)  the pointing-origin (where in the focal plane the image
**            appears);
**
**     (iii)  the mount encoder readings (that cause the image of the
**            target to fall in the specified place in the focal plane).
**
**     The transformations are specified by various time-dependent
**     rotation matrices, pointing corrections, functions of rotator
**     angle and so on.  They form a chain:
**
**
**                [ TARGET ]             <- target [a,b]
**                     v
**        astronomical transformations   <- time, site
**                     v
**                 refraction            <- weather
**                     v
**              mount orientation        <- ae2mt
**                     v
**                  [ AIM ]
**                     v
**                   roll                <- encoder a, and ia
**                     v
**            roll/pitch nonperp         <- np
**                     v
**                   pitch               <- encoder b, and ib
**                     v
**               [ BORESIGHT ]
**                     v
**                  guiding              <- ga, gb
**                     v
**               pointing origin         -> [x,y] <- rotator angle
**                     ^
**               [ TELESCOPE ]
**                     ^
**                   flop                <- vertical deflection terms
**                     ^
**             tel/pitch nonperp         <- collimation terms
**                     ^
**                 [ 1,0,0 ]
**
**
**     Given any two of the three sets of coordinates (sky, pointing-
**     origin, mount), the missing coordinates can be deduced.  There is
**     only one mount, and hence all the virtual telescopes must share
**     the same encoder demands, namely those generated by the main
**     "mount tracking" virtual telescope.  The remaining virtual
**     telescopes implement such features as autoguiding and tip/tilt
**     secondary optics, either by deducing the image position for a
**     given target, or deducing the sky coordinates that correspond to
**     a given place in the focal plane.
**
**     In the present case, the pointing origin is determined, starting
**     from the AIM vector and the encoder settings, as shown by the
**     arrows.
**
**  2  The roll and pitch are corrected for index errors, i.e. they are
**     the encoder settings plus the index errors.
**
**  3  The TELESCOPE vector [xt,yt,zt] is in this frame:
**
**       x-axis:  at right angles to both the roll and pitch axes
**       y-axis:  along the pitch axis
**       z-axis:  at right angles to the other two axes
**
**     In the absence of either collimation error or vertical deflection
**     the TELESCOPE vector is [1,0,0].
**
**  4  In impossible cases, zero is returned for both xi and eta, and
**     the status j is set to an error value.
**
**  5  This routine is optimized for speed, and accordingly only minimal
**     validation of the arguments is performed.  It is the caller's
**     responsibility to supply sensible and safe values.
**
**  Last revision:   4 May 2005
**
**  Copyright P.T.Wallace.  All rights reserved.
*/

{
   double p[3][3], xb, yb, zb, r2, r, w, d;



/* Obtain the mount posture matrix. */
   tcsPosture ( a, b, np, p );

/* Use it to rotate AIM by a(z) then -np(x) then -b(z), giving BORESIGHT. */
   xb = p[0][0] * xa + p[1][0] * ya + p[2][0] * za;
   yb = p[0][1] * xa + p[1][1] * ya + p[2][1] * za;
   zb = p[0][2] * xa + p[1][2] * ya + p[2][2] * za;

/* Deduce the image [xi,eta] that makes BORESIGHT and TELESCOPE match. */
   r2 = xt * xt + yt * yt;
   r = sqrt ( r2 );
   if ( r == 0.0 ) {
      r = 1e-20;
      xt = r;
   }
   w = xb * xt + yb * yt;
   d = w + zb * zt;
   if ( d > TINY ) {
      *j = 0;
   } else if ( d >= 0.0 ) {
      *j = 1;
      d = TINY;
   } else if ( d > -TINY ) {
      *j = 2;
      d = -TINY;
   } else {
      *j = 3;
   }
   d *= r;
   *xi = ( yb * xt - xb * yt ) / d;
   *eta = ( zb * r2 - zt * w ) / d;

}

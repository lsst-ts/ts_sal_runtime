#include "tcs.h"
#include "tcsmac.h"

void tcsAim2enc ( double xa, double ya, double za,
                  ROTLOC rotl, double rotap, double ap, double bp,
                  double xim, double yim,
                  double ia, double ib, double np,
                  double xt, double yt, double zt,
                  double ga, double gb,
                  double *enca1, double *encb1,
                  double *enca2, double *encb2, int *j )

/*
**  - - - - - - - - - - -
**   t c s A i m 2 e n c
**  - - - - - - - - - - -
**
**  Partial downstream (sky to encoders) tracking routine that starts
**  with the AIM vector and ends with the equivalent ENCODER readings.
**
**  Given:
**     xa       double        AIM x-coordinate (Note 1)
**     ya       double        AIM y-coordinate (Note 1)
**     za       double        AIM z-coordinate (Note 1)
**     rotl     ROTLOC        rotator location
**     rotap    double        predicted rotator mechanical angle (Note 2)
**     ap       double        predicted roll (Note 3)
**     bp       double        predicted pitch (Note 3)
**     xim      double        pointing origin x (in focal lengths)
**     yim      double        pointing origin y (in focal lengths)
**     ia       double        roll zero point (radians)
**     ib       double        pitch zero point (radians)
**     np       double        mount axes nonperpendicularity (radians)
**     xt       double        telescope vector, x-component (Note 4)
**     yt       double        telescope vector, y-component (Note 4)
**     zt       double        telescope vector, z-component (Note 4)
**     ga       double        guiding correction, collimation
**     gb       double        guiding correction, pitch
**
**  Returned:
**     enca1    double        roll coordinate, first solution (Note 5)
**     encb1    double        pitch coordinate, first solution (Note 5)
**     enca2    double        roll coordinate, second solution (Note 5)
**     encb2    double        pitch coordinate, second solution (Note 5)
**     j        int           status:  0 = OK
**                                    -1 = no solutions (Note 6)
**
**  Defined in tcsmac.h:
**     ROTLOC   enum          rotator locations
**
**  Defined in tcsmac.h:
**     TINY     double        a small number
**
**  Called:  tcsBs
**
**  Notes:
**
**  1  A "virtual telescope" is a group of transformations that link
**     three sets of coordinates:
**
**       (i)  the target (where in the sky the source is);
**
**      (ii)  the pointing-origin (where in the focal plane the image
**            appears);
**
**     (iii)  the mount encoder readings (that cause the image of the
**            target to fall in the specified place in the focal plane).
**
**     The transformations are specified by various time-dependent
**     rotation matrices, pointing corrections, functions of rotator
**     angle and so on.  They form a chain:
**
**
**                [ TARGET ]             <- target [a,b]
**                     v
**        astronomical transformations   <- time, site
**                     v
**                 refraction            <- weather
**                     v
**              mount orientation        <- ae2mt
**                     v
**                  [ AIM ]
**                     |                 }
**                   roll                }
**                     |                 } -> encoder [a,b]
**            roll/pitch nonperp         }
**                     |                 } <- np, ia, ib
**                   pitch               }
**                     |                 }
**               [ BORESIGHT ]
**                     ^
**                  guiding              <- ga, gb
**                     ^
**               pointing origin         <- [x,y] and rotator angle
**                     ^
**               [ TELESCOPE ]
**                     ^
**                   flop                <- vertical deflection terms
**                     ^
**             tel/pitch nonperp         <- collimation terms
**                     ^
**                 [ 1,0,0 ]
**
**
**     Given any two of the three sets of coordinates (sky, pointing-
**     origin, mount), the missing coordinates can be deduced.  There is
**     only one mount, and hence all the virtual telescopes must share
**     the same encoder demands, namely those generated by the main
**     "mount tracking" virtual telescope.  The remaining virtual
**     telescopes implement such features as autoguiding and tip/tilt
**     secondary optics, either by deducing the image position for a
**     given target, or deducing the sky coordinates that correspond to
**     a given place in the focal plane.
**
**     In the present case, the encoder demands required to image the
**     target at the specified pointing-origin are calculated, starting
**     from the AIM vector, as shown by the arrows.
**
**  2  The predicted rotator angle rotap is the expected position of
**     the mechanical rotator (whether at a coude or Nasmyth focus,
**     or mounted on the OTA) at the time for which the prediction is
**     being made.
**
**  3  The arguments ap and bp are an estimate of the coordinates
**     a and b which are being computed.  The results are not very
**     sensitive to the values used.
**
**  4  The TELESCOPE vector [xt,yt,zt] is in this frame:
**
**       x-axis:  at right angles to both the roll and pitch axes
**       y-axis:  along the pitch axis
**       z-axis:  at right angles to the other two axes
**
**     In the absence of either collimation error or vertical deflection
**     the TELESCOPE vector is [1,0,0].
**
**  5  If the mount is an altazimuth, the roll coordinate is pi-azimuth
**     and the pitch coordinate is elevation.  If the mount is an
**     equatorial, roll is -HA and pitch is declination.  For any
**     accessible target, there are two solutions; depending on the type
**     of mount, the two solutions correspond to above/below the pole,
**     nearside/farside of the zenith, east/west of the pier, and so on.
**
**  6  Near the pole of the mount, especially when the collimation error
**     or nonperpendicularity are large, there may be no combination of
**     mount angles that images the target at the desired place.  In
**     such cases, the status j is set to the "no solutions" value, and
**     the returned roll and pitch are set to safe values.
**
**  Last revision:   4 May 2005
**
**  Copyright P.T.Wallace.  All rights reserved.
*/

{
   int notok;
   double xb, yb, zb, a, snp, cnp, p, s, c, b1, b2, cb, sb, x, y, a1, a2;



/* Initialize status to OK. */
   notok = 0;

/*
** ---------------------------
** Obtain the BORESIGHT vector
** ---------------------------
*/

/* Obtain the BORESIGHT vector. */
   tcsBs ( xt, yt, zt, rotl, rotap, ap, bp, ga, gb, xim, yim,
           &xb, &yb, &zb );

/* Deal with extreme case. */
   if ( xb == 0.0 ) {
      notok = 1;
      xb = TINY;
   }

/*
** ----------------------------------------
** From AIM and BORESIGHT solve for posture
** ----------------------------------------
*/

/* Default roll value. */
   a = ap + ia;

/* Functions of a/b nonperpendicularity. */
   snp = sin ( np );
   cnp = cos ( np );

/* Deal with extreme np = +/-90 deg case. */
   if ( cnp == 0.0 ) {
      notok = 1;
      cnp = TINY;
   }

/* Solve for pitch angle (two solutions). */
   p = atan2 ( zb, xb );
   s = ( za + snp * yb );
   c = xa * xa + ya * ya - yb * ( 2.0 * za * snp + yb ) - snp * snp;
   if ( c >= 0.0 ) {
      c = sqrt ( c );
   } else {
      notok = 1;
      c = 0.0;
   }
   b1 = atan2 ( s, c ) - p;
   b2 = atan2 ( s, -c ) - p;

/* Solution 1:  rotate boresight vector, first Ry(b) then Rx(np). */
   sb = sin ( b1 );
   cb = cos ( b1 );
   x = cb * xb  - sb * zb;
   y = snp * sb * xb + cnp * yb + snp * cb * zb;

/* Solve for remaining rotation, Rz(-a). */
   a1 = ( x * x + y * y ) != 0.0 ?
        atan2 ( ya * x - xa * y, x * xa + y * ya ) : a;

/* Same for solution 2. */
   sb = sin ( b2 );
   cb = cos ( b2 );
   x = cb * xb  - sb * zb;
   y = snp * sb * xb + cnp * yb + snp * cb * zb;
   a2 = ( x * x + y * y ) != 0.0 ?
        atan2 ( ya * x - xa * y, x * xa + y * ya ) : a;

/* Apply the index errors. */
   *enca1 = a1 - ia;
   *encb1 = b1 - ib;
   *enca2 = a2 - ia;
   *encb2 = b2 - ib;

/* Status. */
   *j = notok;

}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             %
%  TCSpk Programmer's Manual  %
%                             %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% ----------
% Stationery
% ----------
\def\Europaper{Europaper}     % European A4
\def\USpaper{USpaper}         % US letter

\def\papersize{USpaper}

% ------------------
% Document licensing
% ------------------

\def\TPS{TPS}                 % Tpoint Software
\def\RAL{RAL}                 % Rutherford Appleton Lab

\def\license{RAL}

% ----------------
% Document variant
% ----------------

\def\vfull{vfull}             % full (i.e. normal) version
\def\vshort{vshort}           % abridged version

\def\vdoc{vshort}

%-------------------------------------------------------------------------------

\documentclass[12pt,fleqn,twoside]{article}
\pagestyle{headings}
\pagenumbering{roman}

\renewcommand{\_}{{\tt\char'137}}     % re-centres the underscore

%-------------------------------------------------------------------------------

% Definitions to suit stationery
\ifx\papersize\Europaper
\setlength{\textwidth}{160mm}       %
\setlength{\textheight}{230mm}      % European A4
\setlength{\topmargin}{5mm}         %
\else
\setlength{\textwidth}{167mm}       %
\setlength{\textheight}{220mm}      % US Letter
\setlength{\topmargin}{5mm}         %
\fi

%-------------------------------------------------------------------------------

\setlength{\oddsidemargin}{0mm}
\setlength{\evensidemargin}{0mm}
\setlength{\parindent}{0mm}
\setlength{\parskip}{\medskipamount}
\setlength{\unitlength}{1mm}

%------------------------------------------------------------------------------

\newcommand{\tpoint}    {{\it Published by:~~~}\\[1mm]
                         {\Large \tt Tpoint}
                         \begin{picture}(7,7)(-3.5,-1.2)
                         \put(0,0){\circle{6}}
                         \put(-4,0){\line(1,0){2.5}}
                         \put(4,0){\line(-1,0){2.5}}
                         \put(-1.08,-0.94){\mbox{\boldmath$\ast$}}
                         \put(0,-4){\line(0,1){2.5}}
                         \put(0,4){\line(0,-1){2.5}}
                         \end{picture}
                         {\Large \tt Software} \\[2mm]
                         19~Sutton~Wick~Lane, Drayton, \\
                         Abingdon, Oxfordshire, OX14~4HH \\
                         United~Kingdom\\[3mm]
                         {\it www.tpsoft.demon.co.uk}}
\newcommand{\radec}     {$[\,\alpha,\delta\,]$}
\newcommand{\hadec}     {$[\,h,\delta\,]$}
\newcommand{\mhadec}     {$[\,-h,\delta\,]$}
\newcommand{\xieta}     {$[\,\xi,\eta\,]$}
\newcommand{\azel}      {$[\,Az,El~]$}
\newcommand{\ecl}       {$[\,\lambda,\beta~]$}
\newcommand{\gal}       {$[\,l^{I\!I},b^{I\!I}\,]$}
\newcommand{\xy}        {$[\,x,y\,]$}
\newcommand{\xyz}       {$[\,x,y,z\,]$}
\newcommand{\xyzd}      {$[\,\dot{x},\dot{y},\dot{z}\,]$}
\newcommand{\xyzxyzd}   {$[\,x,y,z,\dot{x},\dot{y},\dot{z}\,]$}
\newcommand{\degree}[2] {$#1^{\circ}
                        \hspace{-0.35em}.\hspace{0.04em}#2$}
\newcommand{\arcsec}[2] {\arcseci{#1}$\hspace{-0.4em}.#2$}
\newcommand{\arcseci}[1] {$#1\hspace{0.05em}$\raisebox{-0.5ex}
                         {$^{'\hspace{-0.1em}'}$}}
\newcommand{\dms}[4]    {$#1^{\circ}\,#2\raisebox{-0.5ex}
                        {$^{'}$}\,$\arcsec{#3}{#4}}
\newcommand{\tsec}[2]   {\tseci{#1}$\hspace{-0.3em}.#2$}
\newcommand{\tseci}[1]  {$#1$\mbox{$^{\rm s}$}}
\newcommand{\hms}[4]    {$#1^{\rm h}\,#2^{\rm m}\,$\tsec{#3}{#4}}
\newcommand{\notelist}  {\goodbreak \vspace{1ex} Notes:
                        \vspace{-3ex}}
\newcommand{\anotelist}  {\goodbreak \vspace{1ex} Note:
                        \vspace{-3ex}}
\newcommand{\abridged}  {\vspace{3ex} \begin{center}
                        \framebox(50,14){\vspace*{1mm}
                        \large \it material omitted}
                        \end{center}\vspace{3ex}}

%------------------------------------------------------------------------------

\newcommand{\ab}         {$[\,a,b~]$}
\newcommand{\dab}        {$[\Delta a,\Delta b\,]$}
\newcommand{\mazel}      {$[\,\pi\!-\!Az,El~]$}
\newcommand{\gagb}       {$[\,GA,GB\,]$}
\newcommand{\ia}         {{\rm IA}}
\newcommand{\ib}         {{\rm IB}}
\newcommand{\vd}         {{\rm VD}}
\newcommand{\ca}         {{\rm CA}}
\newcommand{\np}         {{\rm NP}}
\newcommand{\aw}         {{\rm AW}}
\newcommand{\an}         {{\rm AN}}
\newcommand{\ga}         {{\rm GA}}
\newcommand{\gb}         {{\rm GB}}
\newcommand{\iatx}       {$\ia$}
\newcommand{\ibtx}       {$\ib$}
\newcommand{\vdtx}       {$\vd$}
\newcommand{\catx}       {$\ca$}
\newcommand{\nptx}       {$\np$}
\newcommand{\awtx}       {$\aw$}
\newcommand{\antx}       {$\an$}
\newcommand{\gatx}       {$\ga$}
\newcommand{\gbtx}       {$\gb$}

%------------------------------------------------------------------------------

\newcommand{\routine}[2]
{
  \newpage
  \rule{\textwidth}{0.3mm}\\ \nopagebreak
  {\Large {\bf #1} \hfill #2 \hfill {\bf #1}}
  \vspace{-1ex}
}

\newcommand{\routinennp}[2]
{
  \goodbreak
  \rule{\textwidth}{0.3mm}\\ \nopagebreak
  {\Large {\bf #1} \hfill #2 \hfill {\bf #1}}
  \vspace{-1ex}
}
\newcommand{\call}[1]
{
  \goodbreak
  \begin{description}
    \item[CALL]: \\[0.5ex] \nopagebreak
        {\tt #1}
  \end{description}
  \vspace{-3ex}
}
\newcommand{\action}[1]
{
  \goodbreak
  \begin{description}
    \item[ACTION]: \\[0.5ex] \nopagebreak
        #1
  \end{description}
  \vspace{-3ex}
}
\newcommand{\args}[2]
{
  \goodbreak
  \begin{description}
  \item[#1]: \\[1.5ex] \nopagebreak
    \hspace*{-0.9em}
    \begin{tabular}{p{4.5em}p{5.8em}p{23.5em}}
      #2
    \end{tabular}
  \end{description}
  \vspace{-3ex}
}
\newcommand{\blank}[1]
{
  \goodbreak
  \begin{description}
  \item~ \\[1.5ex] \nopagebreak
    \hspace*{-0.9em}
    \begin{tabular}{p{4.5em}p{5.8em}p{23.5em}}
      #1
    \end{tabular}
  \end{description}
  \vspace{-3ex}
}
\newcommand{\specsubhead}[1]
{
  \multicolumn{3}{l}{\hspace*{-2em}{\sc #1~:}}
}
\newcommand{\spec}[3]
{
  {\em {#1}} & {\bf \mbox{#2}} & {#3}
}
\newcommand{\specel}[2]
{
  \multicolumn{1}{c}{#1} & {} & {#2}
}
\newcommand{\anote}[1]
{
  \goodbreak
  \begin{description}
    \item[NOTE]: \\[0.5ex] \nopagebreak
        #1
  \end{description}
  \vspace{-3ex}
}
\newcommand{\notes}[1]
{
  \goodbreak
  \begin{description}
    \item[NOTES]: \nopagebreak
        #1
  \end{description}
  \vspace{-3ex}
}
\newcommand{\aref}[1]
{
  \goodbreak
  \begin{description} \\[0.5ex]
    \item[REFERENCE]:
        #1
  \end{description}
  \vspace{-3ex}
}
\newcommand{\refs}[1]
{
  \goodbreak
  \begin{description} \\[0.5ex]
    \item[REFERENCES]:
        #1
  \end{description}
  \vspace{-3ex}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\thispagestyle{empty}
\begin{center}
\vspace*{30mm}~

\framebox(40,14){\vspace*{-1mm} \Huge TCSpk\,}

\vspace{20mm}

{\huge \bf TCSpk Programmer's Manual}

\ifx\vdoc\vshort
\vspace{5mm}
{\Large \it Abridged Version}
\fi

\vspace{20mm}

Version 7.5 \\
1st January 2007

\vfill

\ifx\license\TPS
\tpoint
\else
{\it TCSpk is licensed to:}\\[3mm]
{\bf Space Science \& Technology Department, \\
Rutherford Appleton Laboratory, \\
United Kingdom}
\fi

\vspace{8mm}

{\footnotesize \bf TCSpk (TM) and TPOINT (TM) are trademarks.}
\end{center}

\newpage
\thispagestyle{empty}
~
\vfill
\begin{center}

\ifx\license\RAL
\tpoint
\vfill
\fi

\parbox{20em}{\small
Information in this document is subject to change without notice.

\vspace{4mm}

\copyright\ Copyright 2006 Tpoint Software, UK, and
P.\,T.\,Wallace. All Rights Reserved. Reproduction, adaptation, or
translation without prior written permission is prohibited, except
as allowed under the copyright laws.  Transmission of text or
content to third parties, including disclosure via the Internet,
is prohibited. }
\end{center}
~
\newpage

\setlength{\parskip}{0mm}
\thispagestyle{empty}
\tableofcontents
\setlength{\parskip}{\bigskipamount}


%------------------------------------------------------------------------------

\newenvironment{tabs}{\goodbreak\begin{tabbing}}{\end{tabbing}}
\newenvironment{cmnds}{\begin{tabs}
XXX \= XX \= XXXXXXXXXXXXXXXXXXXX \= \kill}{\end{tabs}}
\newenvironment{cmd}{\begin{tabbing}
XXXXXX \= XX \= XXXXXXXXXXXX \= \kill}{\end{tabbing}}

\newcommand{\fstring}[1]{\hbox{\hspace{0.05em}$'${\tt#1}\hspace{0.05em}$'$}}

\renewcommand{\_}{{\tt\char'137}}

\cleardoublepage
\section{INTRODUCTION}
\pagenumbering{arabic}

\ifx\vdoc\vshort
This is {\it abridged version}\/ of the TCSpk Programmer's Manual.  It
omits substantial amounts of technical reference material but retains
the descriptive sections, including full details of the
demonstration applications.

The unabridged version is about 210 pages in length.
\fi

\subsection{What is TCSpk?}

TCSpk is a suite of just over 60 ANSI~C functions, around
which a state-of-the-art
telescope control system (TCS) can be developed. The
functions implement the astrometric pointing kernel part of a TCS
in an accurate, general and modular way.
As well as the functions themselves, there are a number of
demonstration programs, some of which need only minor
adaptation to become real telescope control applications.

Because TCSpk does a specialized job and is intended
to be merely a part of a complete TCS, it is designed to
place as few constraints on the TCS developer as possible.  There is no
preferred operating system or user-interface technique for example, and
even the real-time requirements can be met in a variety of
ways.  This
freedom makes TCSpk easy to integrate within a TCS design
and even to retrofit to an existing system.

TCSpk uses the SLALIB/C library for
all its positional-astronomy transformations and a
subset of the TPOINT pointing-analysis
software for calculating pointing corrections.  Both are
{\it de~facto}\/ standards, reducing maintenance
concerns and allowing TCSpk to be
seamlessly integrated into observatory operations.

\subsection{Key Features}

It is of course perfectly possible to write a simple pointing kernel
without using TCSpk, using standard positional-astronomy
transformations to compute mount encoder demands that
correspond to the science target \radec.  However, not only does
TCSpk make this basic job
much easier to do properly (and get right first time),
but it offers important
additional capabilities that
are much harder to develop {\it ab initio,} such as:

\begin{itemize}
\item All TCS applications provide as their basic function the
      ability to point and track the mount in order to
      follow the sky coordinates of a specified target.  TCSpk
      goes a crucial step further by
      additionally allowing the image position in
      the focal plane to be specified.

      This explicit control over \xy\ means that a TCSpk-based
      system delivers, as a matter of course, rapid
      transfer of images
      from acquisition device to instrument, fast dithering,
      precise blind positioning on slits and fibers and so on.

      A typical TCS that is not based on TCSpk will
      perform such operations by making {\it ad~hoc}\/ changes
      to the pointing, sometimes perturbing the target \radec,
      sometimes introducing spurious pointing-model offsets.  A cascade
      of further {\it ad~hoc}\/ adjustments is then required, for
      example to correct the guide-probe positioning.  In
      contrast, a TCSpk-based TCS has all these capabilities
      simply as part of the way the system works.
\item The target image remains centered on an off-axis instrument
      ``hot-spot'' even when the rotator is turned.
\item Tip-tilt sub-reflectors are treated not as a free-standing
      device but as one component of an integrated pointing
      system.  Guiding while chopping (perhaps while tracking a
      moving object) happens naturally, and advanced techniques such as
      bandwidth splitting between the slow mount and a fast
      sub-reflector are easy to implement.
\item TCSpk provides for instrument rotators and autoguiders
      at Nasmyth and coud\'{e} foci.
\item There is integrated handling of autoguiding, with differential
      refraction and atmospheric dispersion taken care of at a
      system level.  A TCSpk-based system will as a matter
      of course handle ``difficult''
      cases such as guiding at coud\'e, using
      a blue guide star at the edge of the field, positioning the
      image of a solar-system moving
      target on an off-axis thermal-IR detector while adjustments are
      being made to the rotator angle and chopping parameters.
\item Target positions can be accurately logged, and there is
      support for World Coordinate System mapping.
\item Control of instrument rotator angle is handled rigorously,
      ensuring accurate results even near the pole of the mounting.
      Field orientation is controlled at the pointing origin
      (which is in general not at the rotator axis) enabling
      precise alignment between celestial and instrument coordinates.
      Mosaicking is facilitated by specifying, on successive exposures,
      the same celestial coordinates but different instrument coordinates.
\item The basic pointing transformations are rigorous and glitch-free
      even for large mechanical
      errors and near the pole and zenith.
\item High computational efficiency is built into the
      design.  On a typical PC, hundreds or even thousands
      of highly accurate astrometric transformations per second
      are possible, should the TCS design require it.
\item With TCSpk, the pointing model can be upgraded without writing
      new code.  Calibration and operational implementation of
      the pointing model are tautologically linked, and hence there
      are no hidden sign errors or subtle distortions.
\end{itemize}

Note that TCSpk caters for both optical/IR telescopes and radio
telescopes, including the provision of different atmospheric
refraction models for the two cases.  In this manual, the terms
``telescope'' and ``antenna'' can be regarded as interchangeable.

\subsection{Quick Start}

TCSpk comes with a Unix makefile that builds the library and the
demonstrator applications.  The quickest way to learn about the system
is to build it, run the {\tt tcs\_demo} program and then to examine the
{\tt tcs\_demo.c} source code.  This program, which could easily form
the nucleus of a real TCS, sets up a
data context, then uses it to predict mount demands to track a star;
finally it shows how to call TCSpk routines to transform between
sky, focal plane and encoder coordinates.  A detailed code walkthrough
is presented on p\pageref{tcs_demo}ff.

The principle of writing a TCSpk-based
telescope control application is as follows.
Access to date and time is assumed (note that TCSpk comes with a
dummy routine {\tt tcsTime}, for testing).
\begin{enumerate}
\item Set up a data context containing the items needed to drive
      TCSpk.  The demonstration program {\tt tcs\_demo} and
      associated header file {\tt tcsctx.h} show how this is done.
      Another example is {\tt tcs\_dsa} + {\tt dsactx}.
\item Provide ways for the operator to change the context, in
      particular by announcing a new target.
\item Arrange to call {\tt tcsSlow} once every minute and
      {\tt tcsMedium} once every 5~seconds, to update different
      parts of the context.
\item Arrange to call {\tt tcsFast} or some equivalent every
      50~ms to generate the tracking demands.
\end{enumerate}
The end result will be a stream of time-stamped encoder values
that track the specified target, taking into account both the
complex and changing astrometric transformations and the telescope
pointing model.

\ifx\vdoc\vfull
\subsection{Changes, Version~6 to Version~7}
Changes were introduced after Version~6, including many imporovements
and corrections to program comments and the addition of a number of
new functions.  Unlike previous updates, some of the changes mean that
Version~7 functions are incompatible with a
Version~6 application.

Here is the list of the more important changes:
\begin{itemize}
\item Redundant arguments {\tt ga} and {\tt gb} were removed from
      the functions {\tt tcsG2po} and {\tt tcsG2tar}.  (These
      functions express the
      current guiding corrections as adjustments to the pointing origin
      and target respectively;  the guiding corrections are, in fact,
      implicit in the {\tt enca} and {\tt encb} arguments, which
      are the pointing demands to the mount.)
\item Redundant arguments {\tt tlat}, {\tt tlr} and {\tt hm} were
      removed from the function {\tt tcsSlow}.  (The
      refraction calculation which, in the past, needed these
      arguments was changed to a faster algorithm that does not.
      They may be
      needed for high-accuracy refraction predictions implemented
      by the user's supplied refraction function and so remain
      part of the {\tt tcsPtran} and {\tt tcsPtrani} calls.)  The
      calls to {\tt tcsSlow} in the demonstration programs
      {\tt tcs\_demo.c},
      {\tt tcs\_dsa.c},
      {\tt tcs\_equ.c},
      {\tt tcs\_pa.c},
      {\tt tcs\_test.c},
      {\tt tcs\_tpt.c} and
      {\tt tcs\_zt.c}
      were changed accordingly.
\item From Version~7, the {\tt tcsRotator} function
      supported two forms of
      field de-rotation, optimized for slit instruments and field
      instruments respectively.  This enhamncement required an additional
      argument, with consequent changes to
      {\tt tcsctx.h},
      {\tt tcsFast},
      {\tt tcs\_demo.c},
      {\tt tcs\_dsa.c},
      {\tt tcs\_equ.c},
      {\tt tcs\_pa},
      {\tt tcs\_test},
      {\tt tcs\_tpt} and
      {\tt tcs\_zt}.  The two options are as follows:
      \begin{itemize}
      \item ``Slit-optimized''
      means that two stars lying on a specified line
      remain there, though their separation may vary because of
      differential refraction.
      \item ``Field-optimized''
      relaxes this condition to achieve a greater overall reduction in
      field rotation.
      \end{itemize}
      The difference is always small, and of importance
      only for wide-field applications.
\item An additional target frame is was introduced, namely
      topocentric apparent
      place (ID = {\tt APPT\_TOPO}).  This is useful for the case of
      solar-system targets, where parallax and aberration for the
      observer's location have been fully accounted for.  If geocentric
      apparent place (ID = {\tt APPT}) were used, an unwanted
      diurnal aberration correction would be introduced.
\item The function {\tt tcsEnc2s\_c} was removed, replaced by
      the new function
      {\tt tcsVTsky\_c}.  (See the next item.)
\item A number of new functions were added, variants of existing
      functions that used \xyz\ arguments instead of spherical.  The
      new functions
      gave the TCS designer additional choices, and eliminated
      wasteful Cartesian-spherical-Cartesian and
      spherical-Cartesian-spherical transformations.  The new functions
      were as follows:
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt tcsAimtrk   \> aim vector to mount demands \\
\> \tt tcsTartr\_c \> like {\tt tcsTartran} but target Cartesian \\
\> \tt tcsTrack\_c \> like {\tt tcsTrack} but target Cartesian \\
\> \tt tcsVTenc\_c \> like {\tt tcsVTenc} but target Cartesian \\
\> \tt tcsVTsky\_c \> like {\tt tcsVTsky} but Cartesian result \\
\> \tt tcsVTxe\_c  \> like {\tt tcsVTxe} but target Cartesian \\
\> \tt tcsVTxy\_c  \> like {\tt tcsVTxy} but target Cartesian
\end{tabbing}
\item The macro definitions were moved to a new header file,
      {\tt tcsmac.h}.  The type definitions and function
      prototypes remained in {\tt tcs.h}.
\item Two new functions were added to facilitate making dynamic
      changes to the pointing model, for example during start-of-night
      calibrations.  The function {\tt tcsIterm} returns the
      coefficient name and value for a term, given its position in
      the model.  The function {\tt tcsSterm} allows the value of the
      coefficient for a given named term to be changed.  The demonstration
      program {\tt tcs\_demo.c} illustrates ways to use these routines.
\item Changes were made to the {\tt tcs.h} header file so that when
      using a C++ compiler the {\tt const} qualifier is applied to arrays
      (including character strings) used as ``in'' arguments.  This
      eliminates having to use casts when using TCSpk functions in C++
      classes.  (Differences between the treatment of
      {\tt const} in the ANSI C and C++ standards unfortunately
      prevent the same mechanism being used in the C case, despite the
      safer code that would result.)
      The affected functions were
      {\tt tcsAddtrm},
      {\tt tcsAim2s\_c},
      {\tt tcsAstup},
      {\tt tcsFast},
      {\tt tcsG2po},
      {\tt tcsG2tar},
      {\tt tcsIntpm},
      {\tt tcsIterm},
      {\tt tcsMedium},
      {\tt tcsPmt},
      {\tt tcsPorup},
      {\tt tcsProbeV},
      {\tt tcsPtran},
      {\tt tcsPtrani},
      {\tt tcsPup},
      {\tt tcsRotator},
      {\tt tcsSky2a\_c},
      {\tt tcsSky2aim},
      {\tt tcsSpm},
      {\tt tcsSterm},
      {\tt tcsTargup},
      {\tt tcsTartr\_c},
      {\tt tcsTartran},
      {\tt tcsTrack},
      {\tt tcsTrack\_c},
      {\tt tcsVtenc},
      {\tt tcsVtenc\_c},
      {\tt tcsVtsky},
      {\tt tcsVtsky\_c},
      {\tt tcsVtxe},
      {\tt tcsVtxe\_c},
      {\tt tcsVtxy} and
      {\tt tcsVtxy\_c}.
\end{itemize}

\subsection{Acknowledgements}

In am grateful to David~Terrett and Gary~Hovey for their many
extremely valuable comments and suggestions.
\fi

\newpage
\section{PRELIMINARIES}

Before beginning to look at TCSpk itself, it is important to place the
system into context by considering (i)~its interactions with the
subsystems that actually control the mount and instrument rotators
and (ii)~the way the various operations are scheduled.

\subsection{Servo and Encoder Issues}

TCSpk provides predictions of the mount axis settings needed to track
celestial sources.  For these predictions to cause mount movement they
have to be connected up to the driving hardware.  This section looks at
various aspects of this all-important interface.

\subsubsection{TCS designs}

The classic TCS design treats the
real-time control computer as programmable hardware that
implements a fixed timing diagram.
The observatory
timing system generates precisely regular interrupts that trigger
pointing
computations that must be complete before the next interrupt;  the
results of the computations are then strobed into hardware
that in one way or another generates the required motor torques.

Such TCS designs rely upon total reliability, with no lost or spurious
interrupts and no processing overruns.  The required reliability is
achieved by using dedicated communication links,
a specialized real-time operating system (RTOS) and
paying careful attention to priority assignment and code design.

TCSpk is, in fact, highly suitable for use in such a system.  However,
TCS designers
are increasingly looking for ways to minimize the expense and
specialized programming of working within a dedicated RTOS, and TCSpk
is specifically designed to support this
``soft real-time'' outlook.  These days, it is
possible to build a high-performance
TCS entirely on a Unix or Windows computer,
communicating with the hardware through a shared Local Area
Network;  the design will still include
a steady flow of timing ``ticks'', typically at 10-20~Hz,
but there is no longer reliance on extremely accurate timing nor
in-time delivery of pointing predictions.

Of course, the buck has to stop somewhere, and that is usually in
the ``mount control system'' (MCS), the dedicated computer(s) and/or
servo boards that actually drive the mount.  These subsystems tend to be
designed in an old-fashioned way that places rigid demands on the
controlling device, with zero tolerance for missed or
duplicated demands for example.  The interface is best managed by
providing ``fail-soft'' logic at the MCS level that tolerates a
degree of irregularity in the demands
from the TCS while providing the
stream of tick-perfect demands that drive the lower levels in the
system.

\subsubsection{Time-stamped positions}

Flexibility on the TCSpk side of the interface is achieved by associating
the mount angle demands with {\it absolute}\/ times.  This can be
contrasted with the classic TCS, where each tick would generate
just the position (or a position + velocity), and its arrival at
the MCS would implicitly
associate it with the time to which it applied.  By
``time-stamping'' the position demand, each one becomes merely a
{\it sample}\/ of a smooth locus.  The MCS can turn this
stream of samples back into
time-specific demands by interpolation (or extrapolation) to meet
the specific needs of its local timing and input-output
arrangements.

Note that in an architecture where the TCS is running in a
general-purpose computer and the MCS is the only hard real-time
computer, highly accurate time needs to be
available only to the MCS.  It is clearly important that the TCS
has access to {\it reasonably}\/ accurate time, say to 50~ms, otherwise
rapid differential motions such as pressing guide buttons will be
compromised.  But for ordinary pointing
and tracking, only the MCS needs precise time.

The method by which the MCS interprets the TCS demands is
application-dependent, but the simplest and perhaps best way is
simply to perform linear interpolations and extrapolations using
two recent time-stamped positions.  (More elaborate schemes involving
velocity predictions, cubic splines {\it etc.}~are sometimes
used, but on critical examination the total computation and
input-output load for a given accuracy tend to be no less than for
straightforward linear interpolation.)  On the other
hand, some sophisticated servo systems allow offsets and tracking to be
separately demanded, using different
response characteristics for the
two types of move;  to exploit a system of this kind may require
adroit use of TCSpk, for example having two contexts running in
parallel that treat offset activity and background tracking
separately.

\label{glitch}{\it n.b.} Some finesse is
called for in how the interpolation/extrapolation is carried out.
Measures must be taken to ensure that a new position is {\it not}\/
used until the time of the previous sample has been passed.  In
other words, at least one of the two positions must lie in the
past.  The
reason for this is that any sudden jump in position, such as will
occur whenever an offset or slew is demanded, will, if
extrapolated backwards
to before the first of the two positions that contain the jump, cause
a glitch, the axis briefly driving in the wrong direction.  This problem
is extremely easy to introduce by accident and is known to
afflict several 8m-class telescopes.

Perhaps the simplest way to avoid this difficulty is as follows:
\begin{itemize}

\item The TCS tracking routine is invoked at or just after time T.

\item The TCS computes the pointing P for time T+tick.

\item The TCS computes the velocity V for time T as
      (P(T+tick)$-$P(T))/tick.

\item The TCS sends P,V,T to the MCS.

\item The MCS (which may be running on a different clock, perhaps
      skewed relative to the TCS) maintains two P,V,T samples.
      One, the {\it active}\/ one, is in the past. The other, the
      {\it next}\/ one, may or may not be present.

\item If the current time is later than the time-stamp of the
      {\it active}\/ P,V,T sample, and if a {\it next}\/ P,V,T
      sample is available, the {\it next}\/ P,V,T is moved into
      {\it active,} and {\it next}\/ becomes vacant.

\item Whenever a new P,V,T sample is received by the MCS, it
      becomes the {\it next}\/ sample, {\bf if and only if
      vacant.} If {\it next}\/ is not vacant, so that there is
      a {\it next}\/ P,V,T sample waiting to be used, the new
      sample is {\bf discarded}.

\end{itemize}
Note that with the above scheme the effects of any TCS/MCS clock
skew depend on its sense. If the TCS is ahead of the MCS, the rate
at which P,V,T samples are accepted is automatically throttled
back and high-frequency features in the locus will be suppressed.
If the TCS is behind the MCS, high frequency features will be
delayed.

\subsubsection{Slewing and tracking}

Note that TCSpk itself has no concept of slewing and tracking as separate
concepts.  The ideal MCS is one that accepts a sudden and large
change in the demand position and does whatever is necessary to move
the mount smoothly to the new attitude.  Some MCSs are not able to
do this without flagging an error condition, or there may be other
reasons not to use all the available performance of the drives.  In
such cases it is necessary to signal-shape the demands before they
go to the MCS, to keep within predetermined speed, acceleration and/or
jerk limits.

\subsubsection{Encoder readings}

The primary role of the encoder readings is of course to close the
position servo loops, something that happens on the MCS side of the
system.  However, the readings are, as a rule, also made available
to the TCS.  It tends to be assumed that
the readings are vital information, both so that the TCS
knows where the telescope is actually pointing and, especially, for
pointing calibration.  However, this assumption can be questioned.

First, it is not important to have accurate
on-the-fly encoder readings during
slewing.  A rough idea, used for displaying
the progress of the slew, is useful, but there is no need for
the readings to be precisely timed for instance.  Secondly,
during pointing tests it is not
the encoder reading that should be logged, it is {\it what the TCS
asked the encoder readings to be.}  By logging the demands rather
than the readings, any servo peculiarities such as fixed offsets
or lags are automatically allowed for in the pointing model.

\subsubsection{Servo design}

TCSpk itself does not include a software servo.  If the interface
to the mount drives is an analog demand to a
velocity servo it will be necessary for the TCS developer
to write software that closes the position loop through the encoder
readings.

The tried-and-tested design is as follows:
\begin{itemize}
\item Based on a PID servo.
\item Uses velocity feedforward, leaving the integrator
      to correct any residual errors in the demanded versus
      achieved velocity calibration.
\item Anti-wind-up is achieved by resetting the integrator to zero
      whenever the position error exceeds a specified amount.
\item For all but small position errors, the
      servo law must switch from PID to square-root-of-error.
      This will produce constant deceleration;  the gain
      should be set to just within the available
      hardware performance.
\item Signal shaping is required, limiting position, velocity,
      acceleration and jerk to agreed maxima.
\item Measures are needed to prevent running into a position limit
      at speed.
\end{itemize}
On altazimuth mounts precautions need to be taken
to prevent the situation where at high tracking speeds (near the
zenith) the azimuth drive fails to keep up with the
anti-wind-up integrator window.  In the design of the software
servo, it is worth considering performing continuous refinement of the
calibration between demanded and achieved velocity to avoid this
effect.  The ideal result is of course where the velocity feedforward
alone achieves the required track.

Such a software servo will
often out-perform a specialized motor controller.  The
latter tend to be optimized for smaller-scale machinery such as
NC milling machines.  In comparison, a telescope or antenna has an
{\it enormous}\/ dynamic range, from slewing at perhaps $2^\circ\!$/s
to tracking at \arcsec{0}{1}/s.  Some specialized telescopes and
antennas have higher slew rates still.

\subsection{Scheduling Considerations}

TCSpk places very few demands on the host TCS application, but
clearly it is necessary for the TCSpk software to be started up
and the appropriate parts subsequently executed on the basis of
time and external events.

\subsubsection{Threads}
\label{threads}

The details of the real-time design (processes, time services,
interrupts {\it etc.}) are the responsibility of the TCS application.
TCSpk makes no assumptions about how this is done, and hence
places few restrictions on the application architecture, choice
of operating system and so on.

TCSpk can run in a single thread, but
is designed to work best when the TCS application
runs two threads with a shared context.  One thread, at lower
priority, keeps the context up to date, while the other,
at higher priority or operating in
a separate processor (perhaps the
same computer or DSP that is controlling the
mount servos), interprets the
context in order to generate time-stamped positions
for the mount axes and the rotator.  The context may be truly shared,
or the high-priority ``FAST'' thread may keep its own copy of the context
that the lower-priority thread is maintaining.

In fact TCSpk further subdivides the low-priority thread
into SLOW and MEDIUM components.  It is usual to run
the SLOW update every 60~s or so, although a much slower rate
would do.  MEDIUM is typically run every 5~s.  The functions
{\tt tcsSlow} and {\tt tcs Medium} are provided as off-the-peg
implementations;  in some TCS applications
it may be appropriate to provide local adaptations, for example
to achieve finer-grain control of the various MEDIUM activities
or conversely to combine the SLOW and MEDIUM activities.

In a typical TCS application, the SLOW/MEDIUM threads are
triggered by a combination of (i)~timer interrupts and, in the
MEDIUM case,
(ii)~notifications from the user-interface that
something has changed.  The FAST thread is triggered at,
say, 20~Hz, probably by timer interrupts.  The TCS application may
decide to trigger the high-priority thread also by the low-priority
thread, to cause it to download pieces of changed context into
a local copy.  This
technique is demonstrated in the supplied program {\tt tcs\_demo.c}.

Single-thread operation is also possible, and avoids the need to
manage two copies of the context.  In this design, the comparatively
heavy SLOW and MEDIUM updates may hold up the FAST processing, causing
delayed or even missed tracking updates.  On modern computers, and
with a forgiving TCS to mount controller interface
design, these effects may be of little or no importance.

(Note that in addition to the TCSpk thread(s), there must be provision
for reading the instrument rotator angle, which is needed
for the pointing calculations.)

\subsubsection{Time scales}

A typical TCS uses Coordinated Universal Time (UTC)
for logging and display
purposes, often supplemented by use of local time (and date).  However,
many TCSs use UTC also for driving the pointing
calculation, and this is an unwise choice because of the need for leap
second handling.  It is strongly recommended that the whole TCS,
including instrument control but in particular the pointing
calculation, be driven by International Atomic Time (TAI),
and this is what TCSpk assumes is the case.

The pointing is a function of Universal Time (UT1), which differs
from UTC by up to 0.9~s.\footnote{The 0.9~s maximum
difference between UT1 and UTC is correct at the time of
writing.  However, certain groups involved in the
distribution of time by radio have proposed that leap seconds
be discontinued.  If this happens, UT1$-$UTC will grow essentially
without limit.  This controversial change
fortunately poses no difficulties for TCSpk.}
The quantity UT1$-$UTC is constant
for long periods but then changes
abruptly by 1~s at a leap second, whereas the quantity TAI$-$UT1
changes smoothly and continuously and is unaffected by leap seconds.
If the TCS application confines the use of
UTC to less critical functions such as logging,
any informality in introducing a leap second will have only relatively
benign effects.  The pointing calculations carried out by
TCSpk require only that the supplied UT1$-$UTC and TAI$-$UTC
values are consistent;  there is no leap-second handling
as such and it is
perfectly in order for the leap second to be introduced (by adding 1~s
to both quantities) a few days before or after the event.

Note that pointing at solar-system targets requires a different time
scale, not related to UT, to be used.  Strictly speaking, the correct
time scale is Barycentric Dynamical Time TDB (or in the case of JPL
predictions the almost identical T$_{eph}$), but as this differs by
less than 2~ms from Terrestrial Time (TT) it is best to use the
latter, which has a fixed offset with respect to TAI.  Whether the
TT time scale is visible to the telescope operator depends on the
user-interface design.  The best approach is to point at
solar-system objects using orbital elements (see Section~\ref{solsys},
p\pageref{solsys})
and to bypass the need for the user to look up positions, rates and
times.

\subsubsection{Scheduling in detail}
\label{scheduling}

The list below sets out what actions the TCS application needs to take
when various external events occur.  Note that it is assumed that the
supplied low-frequency and medium-frequency update routines
{\tt tcsSlow} and {\tt tcsMedium} are being
used (application-specific adaptations are not uncommon,
for example so that different frequencies can be used for the component
updates) and that there
is a routine {\tt tcsFast} that both accepts context
updates and performs the high-priority ({\it e.g.}~20~Hz) calculations
that produce the stream of time-stamped positions.  This is the scheme
used in the demonstration program {\tt tcs\_demo.c}.

\begin{center}
\begin{tabular}{p{27ex}p{48ex}}
  EVENT                      & ACTION \\ \\

  \raggedright {\bf Start-up}
                               & \raggedright Primary
                               initialization of the context,
                               then calls to {\tt tcsInit2},
                               {\tt tcsSlow} and {\tt tcsMedium}.
                               Begin scheduling periodic
                               {\tt tcsSlow} and {\tt tcsMedium} updates.
                               Establish the means of reading the
                               achieved rotator angle and
                               velocity (unless this is all done in
                               the high-priority thread).  Call
                               {\tt tcsFast} to cause it to copy the
                               whole of the context. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf Every 60~s (say)}
                            & \raggedright Call {\tt tcsSlow}. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf Every 5~s (say)}
                             & \raggedright Call {\tt tcsMedium}, then
                               call {\tt tcsFast}
                               to cause it to copy the whole
                               context. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf User asks
  for a different
  position-angle}            & \raggedright Obtain the new
                               information and then
                               call {\tt tcsFast} to cause it to copy the
                               context items that have changed. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf User asks
  for a different
  pointing-origin}           & \raggedright Obtain the new
                               information and then
                               call {\tt tcsFast} to cause it to copy the
                               context items that have changed. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf User
  updates the
  pointing-origin or
  the associated
  offsets from base}         & \raggedright Obtain the new
                               information and then
                               call {\tt tcsFast} to cause it to copy the
                               context items that have changed. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf User
  supplies a new
  target}                    & \raggedright Obtain the new
                               information and then
                               call {\tt tcsTargup} to calculate the
                               current net position.  Call {\tt tcsMedium}
                               to update the transformation to
                               match the new position, and then call
                               {\tt tcsFast} to cause it to copy the
                               context items that have changed.  It
                               is usually appropriate to zero the
                               guiding corrections, called say
                               ({\tt ga,gb}), at this point. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf User
  updates the target
  offsets from base or
  differential tracking
  rates}                     & \raggedright Obtain the new
                               information and then
                               call {\tt tcsFast} to cause it to copy the
                               context items that have changed.  A
                               refinement would be to test whether
                               the target position had changed
                               significantly (more than a few
                               arcminutes) and, if so, to call
                               {\tt tcsMedium} before the call to
                               {\tt tcsFast}. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf Guiding
  activity occurs}           & \raggedright Call {\tt tcsFast} to
                               cause it to copy the
                               updated {\tt ga} and {\tt gb} values. \\
\end{tabular}
\\[\medskipamount]
\begin{tabular}{p{27ex}p{48ex}}
  \raggedright {\bf Every
  50~ms (say)}               & Trigger {\tt tcsFast} to cause it to
                               calculate new mount and rotator
                               positions.  A good time to choose is
                               that of the next 20~Hz interrupt. \\
\end{tabular}
\end{center}

It is usually best to handle the slow and medium processing
in one thread rather
than having separate scheduling arrangements.  On most occasions,
{\tt tcsMedium} alone will be called
(followed by a call to {\tt tcsFast} to pick up the
context changes), but once every
so many invocations the call to {\tt tcsMedium} will be preceded by a
call to {\tt tcsSlow}.  It is also possible to take this idea
one step further by using a
single-thread strategy (see Section~\ref{threads}, p\pageref{threads}).

All the TCSpk demonstrations (see Section~\ref{demos}, p\pageref{demos})
work on the principle that when the context is changed {\tt tcsMedium}
is explicitly run, in addition to regular clock-driven
updates.
A radically different approach, making for cleaner code and
improved efficiency, is
not to call {\tt tcsMedium} explicitly
but to flag when the relevant parts of the context
need refreshing.  In a single-thread TCSpk implementation, this provides
an opportunity for the FAST processing to coordinate itself with the
(more CPU-hungry) MEDIUM and SLOW processing, for example by allowing
the latter only immediately after the FAST processing.  A further
refinement is for the FAST processing itself to decide when the
context needs updating.

\newpage
\section{TCSpk CONCEPTS}

Most of the TCSpk functions are for either (a)~maintaining a data
context describing the current state of the telescope
or (b)~transforming coordinates from one form to another.  However,
there are a number of concepts that underlie the system and we
will look at those before going into more detail on specific
capabilities.

\subsection{Different Types of Mount}

It is still usual to write the control system for a new telescope
from scratch, and so concepts such as ``altazimuth mount''
tend to be built into the design.  However, the TCSpk algorithm
avoids this by fully generalizing the two-axis ``gimbal'' mount.
In the remainder of the present document, ``hour angle, declination''
and ``azimuth, elevation'' are given the generic names ``roll,
pitch''.  Specifically, roll and pitch correspond to \mhadec\ for
an equatorial and \mazel\ for an altazimuth. These two types of
mount are, in fact special cases: TCSpk supports any
mount orientation.  The orientation defines a frame (the ``mount
frame'') whose z-axis is the mount roll axis and whose x-axis is
at right-angles to the pitch axis for roll=0;  the y-axis is at
right-angles to the other two.  (Note that the roll/pitch
non-perpendicularity is not involved.  Indeed, the TCSpk algorithm
allows any angle between the axes, not merely a nominal $90^\circ$.)

A further respect in which the TCSpk algorithm is generalized
is that the location of the instrument rotator is selectable,
depending upon which part of the structure the rotator is mounted:
\begin{itemize}

\item {\it OTA:}~~the instrument mount is fixed to the telescope
tube. This option embraces Cassegrain, bent Cassegrain, prime
focus, Newtonian and so on. (OTA stands for ``Optical Telescope
Assembly''.  The term is used here in a completely generic sense:
it could equally well be the dish of a radio-telescope.)

\item {\it Nasmyth:}~~the instrument mount moves with roll but not
pitch.

\item {\it Coud\'{e}:}~~the instrument mount is fixed to the
ground.

\end{itemize}

\ifx\vdoc\vshort
\abridged
\else
The TCSpk pointing algorithm deals principally with the OTA case,
where the
instrument rotator is fixed to the telescope, for instance at the
Cassegrain focus. Writing $\theta$ for the Cass-equivalent rotator
angle that the algorithm requires, the following table shows how
this angle is obtained from $\theta_M$, the actual mechanical
angle (corrected for any index error):

\begin{center}
\begin{tabular}{|l|c|} \hline
{\it location} & $\theta$ \\
\hline
OTA & $\theta_M$ \\
Nasmyth left & $\theta_M - b$ \\
Nasmyth right & $\theta_M + b$ \\
coud\'{e} right & $\theta_M + a - b$ \\
coud\'{e} left & $\theta_M + a + b$ \\
\hline
\end{tabular}
\end{center}
where $a$ and $b$ are the mount roll and pitch angles. The sign
convention for both $\theta$ and $\theta_M$ is that a positive
change makes the projection of the focal plane on the sky rotate
counter-clockwise.

It must be understood, however, that any additional moving parts
(image rotators, driven mirrors {\it etc}.),
over and above mount roll and pitch,
are not allowed for by TCSpk itself and would call for additional
software specially designed for the application.
\fi

\subsection{Sky-Patch Matrices}
\label{SPMs}

In TCSpk, parts of the complicated transformation chain between
sky coordinates and mount coordinates are summarized into
``sky-patch matrices'' (SPMs).  The technique allows very rapid
computation of the astrometric transformations, which can be important
in a TCS that is managing an instrument rotator,
multiple autoguiders, chopping and
so on.  A less obvious advantage of the scheme is that it packages
different transformations into a standard and
linear form, so book-keeping is
simplified and the complications of, for example, transformations
for different colors
do not intrude into the internal logic. A
further benefit is that the forward and backward transformations
are rigorous inverses of each other, not easy to achieve for
effects such as refraction.

The SPMs are obtained by sampling the sky in three places around the
target position, called ``probe vectors'' and
by default about \degree{0}{3} apart, and deriving
from the original and transformed probe vectors
a $3\times3$ matrix that correctly transforms all three samples.
The resulting
SPMs represent rigid
frame rotations rigorously, but also have enough ``give''
to make a good job of modeling components such as refraction
that stretch and distort the picture slightly.  Around
the target position, the accuracy of the final result
is a few milliarcseconds.

\ifx\vdoc\vfull
For further details of how the SPMs are derived, see the description of
the {\tt tcsSpm} function on p\pageref{tcsSpm}.
\fi

Recalculating the SPMs is the most onerous
part of the MEDIUM processing, and some TCSpk-based
applications employ strategies to avoid doing so
unnecessarily.  In a complex system there may even be
advantages in managing a
cache of SPMs, shared by the different virtual telescopes as
appropriate and being refreshed as circumstances (how old they are,
how far the telescope has moved, whether they have been used
recently) dictate.

\subsection{Special Refraction}

TCSpk uses fast refraction routines that give excellent results down to
a few degrees altitude. If special performance is required, there is
provision for substituting a user-written function that will be
called in place of the standard routine.  The mechanism involves
a context variable called {\tt rfun} and of type {\tt PRF} that
contains a pointer to the function.  Its use is demonstrated in
the {\tt tcs\_dsa} program.

\subsection{The Virtual Telescope}

A central concept in TCSpk is the {\it Virtual Telescope} (VT).

The phrase has been used for many years simply to mean a software
object that behaves like a perfect telescope, with the details of
the pointing transformations and corrections hidden from view.  An
application wishing to offset the telescope by a precise
$[\,\Delta\alpha,\Delta\delta\,]$ could simply present those
numbers and the telescope would go there, allowing for differential
refraction and pointing errors {\it etc.} without the application
knowing or caring.

In TCSpk the VT has some specific properties regarding
the functions it supports.  The software object itself contains all
the required details of the celestial transformation, the
pointing-correction model, and it knows about where the instrument
rotator (if any) is located and its current orientation, all kept
up to date by periodic injections of information about the time,
the telescope attitude, the weather readings and the wavelength.
But the job it
does is to take any two items from the following list and to
predict the third:
\begin{itemize}
\item The target direction (almost always an \radec).
\item The pointing model (the \xy\ in the focal plane where
      the image lies).
\item The mount angles ({\it i.e.}~the azimuth and elevation
      encoder readings in the case of an altazimuth mount).
\end{itemize}
The most important application supported by the VT
is straightforward tracking of a star, where a fixed \radec\ is
imaged on a fixed \xy\ by setting the mount to the appropriate
\azel\ (or \hadec\ in the case of an equatorial mount);  time is
steadily changing, and hence the mount coordinates move from one
iteration to the next, so tracking the target. But, equally well,
the VT can be asked to predict the \radec\ for a
given \xy\ and {\it vice versa}, for a given mount attitude.  All
three of these modes are rigorously supported by the TCSpk pointing
algorithm, with no small-angle approximations or other ways for
systematic errors to creep in.  This rigor is called in TCSpk
``total pointing integrity'', which means that multiple VT
calculations can be linked or differenced without small discrepancies
compromising the result.  Full interoperability between different
parts of the system is assured.

Many TCSs use just one VT.  More complicated examples may involve
autoguiders, each one implemented as an additional VT, all
perforce sharing the same mount but differing markedly in other
respects, such as the target star (and color) and the image
location in the focal plane
({\it i.e.}~where to place the probe). Control of a tip/tilt subreflector
can also be handled by VTs, and with a suitable array of VTs
it is possible to offer such capabilities as guiding with
different autoguider probes in different chop states.

A later section looks at the set of transformations that
form the internal workings of the TCSpk Virtual Telescope.  The
mathematical aspects are covered by the paper {\it A Rigorous
Algorithm for Telescope Pointing,}\/ Advanced Telescope and
Instrumentation Control Software~II, Ed.~Lewis, Hilton, Proceedings
of the SPIE, Volume~484, pp125-136 (2002).

\newpage
\section {RESPONSIBILITIES OF THE TCS}

TCSpk is a {\it pointing kernel,} a specialized component of
a full TCS.  The entire TCS application
is much too large a topic to be discussed here,
but it is worth at least listing some of the issues that
it is up to the TCS developer to address:

\subsection{Application Framework}

The TCSpk functions are a kit, not a ready-built TCS.
They have to be suitably
interconnected to form a full-blown TCS kernel supporting
multiple guiders, steerable optics, several focal stations {\it
etc.}\/ as required.

\subsection{Real-Time Architecture}

The TCS needs a real-time architecture---how
the clock is handled and how the different parts of the
calculation are scheduled.

\subsection{User Interface}
A user-interface must be provided.  It must support the
three types of guide ``paddle'' (target, instrument, pointing),
multiple pointing-origins (``hot-spots''), provide targets
and control all the other kernel capabilities.

\subsection{Projection Geometry}

The TCSpk algorithm assumes ``pinhole camera'' optics.  Any
departures from tangent-plane projection will require additional
steps.

\subsection{Ancillary Optics}

Ancillary optics such as atmospheric dispersion
compensators and image rotators will need special treatment.  A
related issue is direct support of instrument focal-plane
coordinates (pixels for instance).

\subsection{Pointing Calibration}

There must be provision for pointing calibrations, both
full-scale and start-of-night.  The TPOINT manual contains advice
on providing the necessary facilities.

\subsection{Special Pointing Control}

The TCS may need to support chopping, nodding and other
features that involve special pointing behaviour.  A
powerful technique is to implement software ``filters'' to feed
information from one VT to another, thereby achieving special
effects such as directing low frequencies to the mount and
high frquencies to a steerable subreflector.  Facilities for offsetting,
dithering, scanning, sequencing, dawdling and so on may also be
required.

\subsection{Meteorological Inputs}

Arrangements for accepting inputs from weather sensors are
needed for the refraction calculations.  These may involve
averaging, glitch prevention, manual intervention and so on.

\subsection{Sky Coordinate Systems}

The range of supported sky coordinate systems must be decided.  In
fact the need for this is diminishing, and many
future TCSs will choose to offer ICRS \radec\ and
topocentric \azel\ only, with conversions from B1950 {\it etc.}\
provided at the data input stage.  However, in special cases, for
example solar telescopes, other systems will be important, such as
topocentric apparent \radec.

\subsection{World Coordinate Systems}

The pointing kernel must be able to export World
Coordinate System (WCS) information,
from which data headers can be generated.  One way
to do this is to sample the focal plane in several (say five) places
and for each of these \xy\ positions using the TCSpk facilities
to determine the current \radec.  SLALIB calls can then be used to
convert the \radec\ coordinates into \xieta\ ``standard coordinates''
and to determine a best-fit 6-coefficient ``affine transformation''
between the \xy\ and \xieta\ coordinates.  This is one expression of
the WCS and can easily be transformed into other forms, for example
suitable for FITS headers.

\subsection{Servo Control}

As described earlier, the interface
between the TCS kernel and the mount (and
rotator) servos must be carefully planned, including the precise
arrangements for interpolation/extrapolation and the provision of
any required ``signal shaping''.

\subsection{Cable Wraps}

Most telescope and antenna designs have a restricted range over
which the axes can be moved (the same applies to instrument
rotators).  TCSpk deals only in the pure angles, so that azimuths
of $500^\circ$, $140^\circ$ and $-220^\circ$ are all
the same as far as TCSpk is concerned.  All the logic of deciding
what wrap state to select, when to unwrap and what control over wrap
to offer the operator is left to the application.

\subsection{Parking}

Moving the telescope into ``park'' positions, such as the zenith or
horizontal, often involves overriding normal limits.  TCSpk does not
attempt to deal with this form of control.

\subsection{Trajectory Control}

On an altazimuth mount, slewing from one place in the sky to another
can, as a rule, be accomplished by allowing each axis to move as
quickly as possible to its individual destination.  The details of the
trajectory followed are unimportant.

This is not
necessarily the case for other designs such as equatorials, where
uncoordinated movements of the two axes can temporarily violate
maximum zenith-distance limits.  A simple and effective
remedy for the latter
case is to command the servos such that there is a speed limit
reduction for the closest axis such that both axes reach their
destination at the same time.  This will produce a trajectory that
is a straight line in mount cylindrical coordinates;  a zenith-distance
limit plotted in the same coordinate system is almost everywhere concave
relative to the accessible region.

\subsection{Alternative Mount Attitudes}

When TCSpk predicts the mount attitude, \ab, there are zero, one or two
solutions.  If there are two solutions, they
correspond to such cases as east and west of the
pier on a ``German'' or cross-axis equatorial mount, or ``beyond
the zenith'' on certain altazimuth designs.  It is up to the
TCS application to arbitrate between the two postures.

For the case where there are zero solutions, see Section~\ref{zph}
on p\pageref{zph}.

\subsection{Solar-System Targets}
\label{solsys}

The TCSpk facilities for tracking solar-system objects are
limited to differential tracking rates.  The user interface of the
TCS application can provide direct access to these, or can offer
more elaborate capabilities that allow objects to be specified
by name and/or orbital elements.  There is good support in SLALIB
for providing such facilities.  For example the function {\tt slaPlante}
will take the conventional heliocentric orbital elements for a
solar-system body and generate the topocentric
apparent \radec.  Two such predictions
can be differenced to provide the differential tracking rate.  Other
SLALIB routines provide for conversion to J2000 \radec, applying
perturbations {\it etc.}

The SLALIB routines are compatible with the elements supplied by
the JPL Horizons and Minor Planet Center services.  Full details of
the correspondence between the different choices of element set
are presented in the SLALIB documentation.

\subsection{Zenith/Pole Handling}
\label{zph}

Near the pole of the mounting there will, in general, be places
on the sky that cannot be imaged, no matter what attitude the
mount assumes.  How these zenith/pole special cases are
handled is up to the application.  As described
earlier, TCSpk offers a simple
``radius of avoidance'' feature, overriding the target
coordinates to execute a track around rather than through the
difficult region.  Other schemes are possible.

Some telescopes may additionally call for Sun or Moon avoidance
when slewing.

\subsection{Coordinate Conventions}

In any particular TCSpk application, there are likely to be
existing coordinate conventions that differ from those used by TCSpk.
Azimuth is one obvious example, where attention must be paid to both
the zero-point and the handedness.  Especially tricky are instrument
and rotators plus any apparatus mounted upon them.  {\it Do not be
tempted to modify TCSpk code to make the functions
comply with local conventions;}\  the
right way is to leave the TCSpk source code strictly alone and
to implement layers of software outside TCSpk to select
and apply the appropriate transformation whenever values enter or
leave the pointing kernel.

\newpage
\section{VIRTUAL TELESCOPES}

As mentioned earlier, the TCSpk design is based on a software object
called the Virtual Telescope, a pointing context that can
be solved for target position, image position and encoder readings
as required.  This section describes the internal workings of the
VT and how they can be used.

\subsection{The Transformation Chain}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%
% The LaTeX source for this Figure is generated by the
% Fortran program that appears at the end of this file.
%

\begin{figure}[p]
\centering

\thicklines
\begin{picture}(100,170)(30,0)

\put(  80.00,   9.50){\oval(  18.00,   8.07)}
\put(  80.00,   9.50){\makebox(0,0){[1,0,0]}}
\put(  80.00,  13.54){\line( 0, 1){   4.27}}
\put(  80.00,  19.95){\makebox(0,0){{\it OTA/pitch non-perpendicularity}}}
\put(  80.00,  22.09){\line( 0, 1){   4.27}}
\put(  80.00,  28.50){\makebox(0,0){{\it vertical deflection}}}
\put(  80.00,  30.64){\vector( 0, 1){   4.27}}
\put(  80.00,  38.95){\oval(  52.00,   8.07)}
\put(  80.00,  38.95){\makebox(0,0){TELESCOPE [$x_T,y_T,z_T$]}}
\put(  80.00,  42.99){\line( 0, 1){   4.27}}
\put(  80.00,  49.40){\makebox(0,0){{\it [$\xi,\eta$]}}}
\put(  80.00,  51.54){\line( 0, 1){   4.28}}
\put(  80.00,  57.95){\makebox(0,0){{\it guiding}}}
\put(  80.00,  60.09){\line( 0, 1){   4.27}}
\put(  80.00,  68.40){\oval(  54.00,   8.07)}
\put(  80.00,  68.40){\makebox(0,0){BORESIGHT [$x_B,y_B,z_B$]}}
\put(  80.00,  72.44){\line( 0, 1){   4.27}}
\put(  80.00,  78.85){\makebox(0,0){{\it pitch}}}
\put(  80.00,  80.99){\line( 0, 1){   4.28}}
\put(  80.00,  87.40){\makebox(0,0){{\it roll/pitch non-perpendicularity}}}
\put(  80.00,  89.54){\line( 0, 1){   4.28}}
\put(  80.00,  95.95){\makebox(0,0){{\it roll}}}
\put(  80.00,  98.09){\line( 0, 1){   4.28}}
\put(  80.00, 106.40){\oval(  38.00,   8.07)}
\put(  80.00, 106.40){\makebox(0,0){AIM [$x_A,y_A,z_A$]}}
\put(  80.00, 114.71){\vector( 0,-1){   4.27}}
\put(  80.00, 116.85){\makebox(0,0){{\it mount orientation}}}
\put(  80.00, 118.99){\line( 0, 1){   4.28}}
\put(  80.00, 125.40){\makebox(0,0){{\it refraction}}}
\put(  80.00, 127.54){\line( 0, 1){   4.28}}
\put(  80.00, 133.95){\makebox(0,0){{\it [$h,\delta$]$\rightarrow$[$az,el$]}}}
\put(  80.00, 138.70){\makebox(0,0){{\it Earth rotation}}}
\put(  80.00, 140.84){\line( 0, 1){   4.28}}
\put(  80.00, 147.25){\makebox(0,0){{\it precession-nutation}}}
\put(  80.00, 152.00){\makebox(0,0){{\it aberration}}}
\put(  80.00, 156.75){\makebox(0,0){{\it light deflection}}}
\put(  80.00, 158.89){\vector( 0, 1){   4.27}}
\put(  80.00, 167.20){\oval(  38.00,   8.07)}
\put(  80.00, 167.20){\makebox(0,0){TARGET [$\alpha,\delta$]}}
\put(  35.00,  49.40){\oval(  16.00,   8.07)}
\put(  35.00,  49.40){\makebox(0,0){$x,y$}}
\put(  43.00,  49.40){\vector( 1, 0){  30.50}}
\put(  73.50,  49.40){\vector(-1, 0){  30.50}}
\put(  35.00,  78.85){\oval(  12.00,   8.07)}
\put(  35.00,  78.85){\makebox(0,0){$B$}}
\put(  41.00,  78.85){\vector( 1, 0){  32.50}}
\put(  73.50,  78.85){\vector(-1, 0){  32.50}}
\put(  35.00,  95.95){\oval(  12.00,   8.07)}
\put(  35.00,  95.95){\makebox(0,0){$A$}}
\put(  41.00,  95.95){\vector( 1, 0){  34.00}}
\put(  75.00,  95.95){\vector(-1, 0){  34.00}}
\put( 125.00,  19.95){\makebox(0,0){{\scriptsize\sf CA}}}
\put( 121.50,  19.95){\vector(-1, 0){  11.50}}
\put( 125.00,  28.50){\makebox(0,0){{\scriptsize\sf VD}}}
\put( 121.50,  28.50){\vector(-1, 0){  24.50}}
\put( 125.00,  49.40){\makebox(0,0){{\small rotator angle}}}
\put( 112.50,  49.40){\vector(-1, 0){  26.00}}
\put( 125.00,  57.95){\makebox(0,0){{\scriptsize\sf GA,GB}}}
\put( 119.00,  57.95){\vector(-1, 0){  31.00}}
\put( 125.00,  78.85){\makebox(0,0){{\scriptsize\sf IB}}}
\put( 121.50,  78.85){\vector(-1, 0){  35.00}}
\put( 125.00,  87.40){\makebox(0,0){{\scriptsize\sf NP}}}
\put( 121.50,  87.40){\vector(-1, 0){  12.50}}
\put( 125.00,  95.95){\makebox(0,0){{\scriptsize\sf IA}}}
\put( 121.50,  95.95){\vector(-1, 0){  36.50}}
\put( 125.00, 116.85){\makebox(0,0){{\scriptsize\sf AW,AN}}}
\put( 118.50, 116.85){\vector(-1, 0){  20.50}}
\put( 125.00, 125.40){\makebox(0,0){{\small weather, color}}}
\put( 112.00, 125.40){\vector(-1, 0){  22.00}}
\put( 125.00, 136.09){\makebox(0,0){{\small site location, UT1}}}
\put( 109.00, 136.09){\vector(-1, 0){  15.00}}
\put( 125.00, 152.00){\makebox(0,0){{\small TT}}}
\put( 121.00, 152.00){\vector(-1, 0){  25.00}}

\end{picture}

\caption{The TCSpk chain of pointing transformations.}
\begin{quote}
\begin{small}

The diagram shows the sequence of transformations and adjustments
that make up the TCSpk telescope pointing algorithm.
%The entities in
%boxes are vectors representing directions in various frames, while
%the items in italics are the operations that link the vectors.
The virtual-telescope facilities that implement this sequence support
three end-points: target direction in the sky \radec\ (usually),
mount encoder readings \ab\ and pointing-origin \xy; knowing any
two of these, plus additional information such as the rotator
angle, the third can be calculated.  The telescope
or antenna's pointing
model, typically 10-20 terms, is compressed before use into a
7-term summary, the terms being IA, IB, VD, CA, NP, AW and AN.

\end{small}
\end{quote}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Figure~1 shows the chain of transformations that implement the
TCSpk Virtual Telescope.  A perhaps surprising feature of the diagram
is that the mount [roll,pitch] angles $A$ and $B$, in
traditional designs being the end point of the chain,
appear in the {\it middle}\/
of the chain.  The reason for this layout is that TCSpk
breaks down the pointing problem into three independent pieces:
\begin{itemize}
\item The transformation between the target coordinates and the
direction of the incoming light in the mount frame.
The latter is called the aim vector.

\item The direction of the pointing direction in a frame fixed to
the pitch axis. This is called the {\sc Boresight} vector and is
usually close to [\,1,\,0,\,0\,].

\item The ``posture matrix'', a rotation matrix that links {\sc Aim}
and {\sc Boresight} by two large rotations (namely the mount roll/pitch
angles) and one rotation rotation that typically is very
small (namely the non-perpendicularity between the two axes) except
in some siderostat designs.
\end{itemize}

\subsection{The Pointing Model}

Note that the pointing model used in the transformation chain is
an idealized one, consisting of only seven terms: two give mount
attitude, two are non-perpendicularities, one is a vertical
displacement and two are zero-point errors.  How are they related
to the real pointing model, which may have a large number of terms
in addition to (or even instead of) those described so far?

In the TCSpk design, only the seven terms already described are
implemented in the pointing kernel, with each individual term in
the full pointing model contributing to whichever of the seven
basic terms seems most natural.  Whereas the traditional approach
to telescope pointing corrections
forces each pointing effect to be expressed as if it were
a contribution to the index errors \dab , the TCSpk approach
additionally offers the other five basic terms as candidates for
the role.  This simplifies the mathematics and promotes rigor.

\subsubsection{The ``collimation'' terms}

The TCSpk scheme minimizes spurious interaction between the pointing
terms by separately accumulating the various combinations and only
then evaluating the net effect of the seven-term ``summary''.  In
the traditional approach used in many
existing TCSs, there is a particular problem with the
so-called ``collimation'' terms, all of which have the effect of
moving the place in the focal plane on which the image should
fall.  These include the two non-perpendicularities as well as
the pointing origin \xy\ itself. If the various components are
separately computed, each with complicated pole or zenith
handling, the results are inaccurate and may even be unstable
(given the changing attitude of the mount and rotator).  In the
TCSpk algorithm, the two non-perpendicularities and the pointing
origin all play distinct roles in an integrated and stable solution.

\subsubsection{The seven terms}
\label{generic}

All seven generic terms in the TCSpk algorithm correspond to
well-known terms in existing pointing models.  For example, the
TPOINT pointing analysis tool has terms for equatorial and
altazimuth telescopes that match the generic terms as follows:

\begin{center}
\begin{tabular}{|c|l||c|c|} \hline
{\it term} & {\it generic} & {\it equatorial} & {\it altazimuth} \\
\hline
roll index error & ~\iatx & $-$IH & IA \\
pitch index error & ~\ibtx & ~~ID & IE \\
vertical deflection & ~\vdtx & ~~FLOP & FLOP \\
OTA/pitch nonperp & ~\catx & $-$CH & CA \\
roll/pitch nonperp & ~\nptx & $-$NP & NPAE \\
roll axis\ldots & ~\awtx & $-$MA & AW \\
\ldots misalignment & ~\antx & ~~ME & AN \\ \hline
\end{tabular}
\end{center}

Most terms in the TPOINT repertoire do not of course have a 1:1
correspondence with the generic terms.  In each such case, a
choice of generic term has been made to receive the correction,
based on the likely mechanical causes.  For example, the TPOINT
``tube flexure'' term TF adds an increment of TF$\,\sin{\zeta}$ to
the vertical deflection \vdtx.

Three of the generic terms, \iatx, \ibtx\ and \nptx, have
individual roles in the pointing algorithm.  Another two, the roll
axis misalignment terms \awtx\ and \antx, are used to form the
``mount attitude matrix''.  The final two terms,
\catx\ and \vdtx, are used to form the {\sc Telescope} vector.  The
translation is, as a rule,
telescope-attitude-dependent and hence time-dependent. It is up
to the telescope or antenna
control application to decide when to refresh
the translation;  typically this is done by calling the
{\tt tcsMedium} function every few seconds.

\subsubsection{Relation between pointing analysis and operational pointing}

Compatibility between the pointing algorithm and offline
pointing-analysis tools can be guaranteed by sharing the relevant
code, and TCSpk offers this option by providing a subset of
functions that are part of the TPOINT pointing analysis package.
This approach not only guarantees complete consistency of mathematical
treatment, but also enables currently unused terms to be present
in the control system ready to be activated if and when required,
without code changes.

When developing a TCS, it is vital to demonstrate that the pointing
corrections being calculated do match the pointing model.  This is
best done with a ``dummy pointing test'', where the TCS pretends to
drive the telescope to a series of calibration stars, then logs
the telescope setting as if perfect alignment with each calibration
star was achieved without guiding adjustments.  When this set of
fake observations is analyzed, the originally-assumed
pointing model should be faithfully reproduced.  In practice, when
such experiments are performed using TCSpk/TPOINT for control and
TPOINT for analysis, the original pointing model is retrieved to
milliarcsecond accuracy.

A simpler alternative that might suit some TCS developers is to
hard-code the specific pointing model for the telescope or antenna
into a customized version of {\tt tcsPup} and to provide a
replacement for {\tt tcsIntpm}.  Only these two TCSpk functions
call TPOINT routines.

\subsection{Guiding}

Guiding means making {\it ad~hoc}\/ adjustments to the telescope
tracking. It is a somewhat problematical aspect in any pointing
scheme because it addresses something that is not supposed to be
there: a discrepancy between the scheme and reality. The
traditional remedy is to apply small changes to the target \radec.
However, this is wrong in principle if the target coordinates
are, in fact, accurately known.  Some advanced telescope control
systems can also offer the option of adjusting the desired image
\xy, but again this may not correspond to reality.

The approach taken in the TCSpk algorithm is that guiding
adjustments \gagb\ are small changes to the telescope pointing
model, specifically changes to the position of the \xy\ origin in
the focal plane. It is important to understand that all three
methods of moving the telescope---\radec, \xy\ and \gagb---are
needed in order to achieve different effects, and that it is the
operator's responsibility to make the right choice.  Considerate
user-interface design is essential here.

\subsection{Relationship between target coordinates and aim vector}
The mount attitude matrix is a $3\times3$ rotation
matrix that forms part of the
transformation between the target coordinates and the aim
vector.  The other parts allow for the standard
positional-astronomy effects, including precession-nutation,
aberration, light deflection, Earth rotation and refraction.
As described earlier,
although this could be done by standard positional-astronomy
transformations, the
TCSpk kernel in fact uses
the ``sky-patch matrix'' approach, and
interpolation scheme that has certain advantages
including computational efficiency and rigorous inversion.

\subsection{Using Virtual Telescopes}

As we saw earlier, a TCSpk Virtual Telescope links
a place in the sky, called the
``target'', with a place in the focal plane, called the ``pointing
origin'', and with a mechanical pointing direction for the telescope.

Fully-fledged TCS applications will use several VTs and these
will be connected in one way or another so that the set cooperate
as a network.  It is very likely that all the VTs share site and
weather information, though it is possible that one or more may be
operating at different times, for example to provide a ``preview''
facility or to look ahead for wrap limits.  Some of the VTs may
share the same target, most will share the one mount orientation,
some will share coordinate transformation parameters and so on.

Each virtual telescope uses internally the different sets
of coordinates, as follows:

\begin{center}
\begin{tabular}{p{22ex}p{54ex}}
{\sc TARGET}     & Where in the sky is to be imaged.  This is
                   typically an \radec\ (usually a J2000/ICRS \radec)
                   but topocentric ({\it i.e.}~unrefracted)
                   \azel\ is also supported. \\
\end{tabular}
\\[\bigskipamount]
\begin{tabular}{p{22ex}p{54ex}}
AIM              & The line-of-sight to the target, with respect to
                   the mount frame.  The latter is typically close
                   to either \azel\ or \hadec. \\
\end{tabular}
\\[\bigskipamount]
\begin{tabular}{p{22ex}p{54ex}}
POINTING-ORIGIN  & The $x,y$ in the focal plane that is to
                   receive the image of the target. \\
\end{tabular}
\\[\bigskipamount]
\begin{tabular}{p{22ex}p{54ex}}
BORESIGHT        & The direction towards the light entering the
                   telescope and forming an image at the pointing
                   origin.  The $xy$ plane of the coordinate frame
                   contains the telescope, as defined by the rotator
                   axis, and the ``pitch'' axis of the mount. \\
\end{tabular}
\\[\bigskipamount]
\begin{tabular}{p{22ex}p{54ex}}
TELESCOPE        & In the same coordinate frame as the {\sc Boresight}
                   vector, the direction in which the telescope,
                   as defined by the rotator axis, is pointing.
                   This vector is [1,0,0], if the collimation error
                   is zero.  Non-zero collimation error will affect
                   the $x$ and $y$ components. \\
\end{tabular}
\\[\bigskipamount]
\begin{tabular}{p{22ex}p{54ex}}
ENCODER          & The mount roll and pitch encoder demands
                   needed to image the
                   target at the pointing-origin. \\
\end{tabular}
\end{center}

\ifx\vdoc\vshort
\abridged
\else
The TCSpk package includes a number of routines which transform
between these coordinates in various ways.  They are set out below;
the given coordinates are marked ``in'' and the computed coordinates are
marked ``out'':

\begin{center}
\begin{tabular}{|l||c|c|c|c|c|c|} \hline
                  & {\it TAR}
                         & {\it AIM}
                               & {\it PO}
                                     & {\it BS}
                                           & {\it TEL}
                                                 & {\it ENC}
                                                       \\ \hline \hline
{\tt tcsAim2enc } &     & in  & in  &     & in  & out \\ \hline
{\tt tcsAim2s\_c} & out & in  &     &     &     &     \\ \hline
{\tt tcsAim2xe  } &     & in  & out &     & in  &     \\ \hline
{\tt tcsAimtrk  } &     & in  & in  &     & in  & out \\ \hline
{\tt tcsBs      } &     &     & in  & out & in  &     \\ \hline
{\tt tcsEnc2aim } &     & out &     & in  &     & in  \\ \hline
{\tt tcsSky2aim } & in  & out &     &     &     &     \\ \hline
{\tt tcsSky2a\_c} & in  & out &     &     &     &     \\ \hline
{\tt tcsTrack   } & in  & out & in  &     & in  & out \\ \hline
{\tt tcsTrack\_c} & in  & out & in  &     & in  & out \\ \hline
{\tt tcsVTenc   } & in  &     & in  &     & in  & out \\ \hline
{\tt tcsVTenc\_c} & in  &     & in  &     & in  & out \\ \hline
{\tt tcsVTsky   } & out &     & in  &     & in  & in  \\ \hline
{\tt tcsVTsky\_c} & out &     & in  &     & in  & in  \\ \hline
{\tt tcsVTxe    } & in  &     & out &     & in  & in  \\ \hline
{\tt tcsVTxe\_c } & in  &     & out &     & in  & in  \\ \hline
{\tt tcsVTxy    } & in  &     & out &     & in  & in  \\ \hline
{\tt tcsVTxy\_c } & in  &     & out &     & in  & in  \\ \hline
\end{tabular}
\\
\end{center}
Notes:
\begin{itemize}

\item The routines with names ending in ``{\tt \_c}''omit a
      conversion between Cartesian and spherical coordinates.

\item The {\tt tcsAim2xe}, {\tt tcsVTxe} and {\tt tcsVTxe\_c}
      functions return coordinates \xieta\ in the
      {\it non-rotating}\/ focal plane.  The {\tt tcsVTxy} and
      {\tt tcsVTxy\_c} functions return coordinates \xy\
      in the {\it rotating}\/ focal plane.  In all
      cases the results are in natural units
      ({\it i.e.}~the unit is 1 focal length).

\end{itemize}
\fi

\subsubsection{The basics: controlling mount and rotator}

The TCSpk functions can be interconnected to provide
pointing integrity throughout a complicated system that can
perform complex tasks such as autoguiding while chopping on a
solar-system target. But the best examples of TCSpk in
action are the more basic functions of controlling the principal
moving parts: the two axes of the mount, and the instrument
rotator.

Generating mount demands is extremely straightforward.  The
target coordinates are transformed, for some time in the near
future, into an aim vector, using {\tt tcsSky2aim}, which is then
transformed into encoder demands using {\tt tcsAim2enc}.

Many otherwise competent altazimuth control systems are let down
by their parallactic-angle-based rotator predictions, which fail
to take account of field rotation effects near the zenith due to
pointing corrections in azimuth.  A much better method, supported
by TCSpk, is to take two trial points either side of the
pointing-origin, along a specified line
\ifx\vdoc\vfull
(see Section~\ref{fieldor},
p\pageref{fieldor}),
\fi
and, knowing the
predicted mount angles for the time in question, projecting them
onto the sky (see {\tt tcsEnc2aim} and {\tt tcsSky2aim}). The resulting
coordinates yield the position-angle of the specified line on the
sky, which is then compared with that desired, and the current
rotator demand adjusted accordingly.

\subsubsection{Autoguiders}
The principle of autoguiding with TCSpk is as follows:
\begin{itemize}
\item One virtual telescope generates the mount and rotator
      settings.
\item Another virtual telescope takes the mount and rotator
      demands and the guide star \radec\ and deduces the
      \xy\ of the guide star image.
\end{itemize}
The autoguider measures the actual \xy\ of the guide star image;
knowing where the image is supposed to be, it calculates the
differences and uses them to change the telescope guiding
corrections {\tt ga,gb}.

These arrangements will set the telescope to the dead-reckoning
position.  If the autoguider hardware is sufficiently precise
and the guide star coordinates are accurate then blind acquisition
of invisible targets is possible.  This mode is called ``blind offset
guiding''.  Often these conditions are not met:  the science target
has been acquired and peaked-up independently, the autoguider may be
unstable, the guide star \radec\ may not be known accurately.
For these cases, it is necessary to make {\it ad hoc}\/
adjustments to the guide star \radec;  this will have the effect
of moving the probe and in turn dragging the field around.  If
the science target image is already in position, this process of
adjusting the guide star \radec\ can be accomplished by feeding the
guider signals not into {\tt ga,gb} but into the guide star \radec.
This is sometimes called ``probe guiding''.  Once enough time has
elapsed for the process to have converged, the normal
telescope guiding mode can be entered.  This
maneuver---a period of probe guiding before switching to normal
guiding---is sometimes called ``hold it right there'' mode.

Note that an autoguider is part of a servo loop, and the TCSpk
support addresses only astrometric aspects.  A real autoguider
will typically have
quite complicated arrangements to do with filtering, smoothing,
noise rejection, gains, intervening fast steering optics and so on.

\subsubsection{Rotator and mount interactions}
Unless the pointing origin is on the rotator axis,
pointing the telescope involves knowing the rotator angle.  This
angle can be either the demanded or achieved value, depending on
the effect that is wanted.

Using the {\it achieved}\/ rotator angle means that the star will be
acquired immediately the mount has finished slewing, even if the
rotator is still moving.  Using the {\it demanded}\/ rotator angle
means that only when the rotator has reached its destination will
the star be acquired.

For generating the mount demands it is usually better to use
the achieved rotator angle.  Stars will then be acquired while the
rotator is still moving:  the field will continue turning until the
rotator reaches its demand, but acquisition can be verified
in the meantime.

However, using the achieved rotator angle introduces other difficulties.
Guider probes will move around to track the changing astrometric
context,
and there can be problems very close to the zenith
where the mount and rotator are both influencing field orientation
and find themselves competing with one another.

The solution is to use separate virtual telescopes:
\begin{itemize}
\item One virtual telescope knows the achieved rotator angle and
      generates the mount pointing and tracking demands.
\item The other virtual telescope uses the demand rotator angle
      as its input and generates mount angles that are then used
      for the rotator and autoguider calculations.
\end{itemize}

\subsubsection{Mosaicking}
Mosaicking, and related techniques such as chopping, involves moving
the telescope within a single astrometric context.  To first order this
can be done simply by changing the target \radec\
(or the pointing-origin \xy).  However, the new target will be treated
as a new field, and this can cause unexpected (though usually small)
changes in rotator angle that are an unwanted overhead and spoil the
alignment of adjacent exposures.  The movement occurs because as the
telescope moves the rotator has also to move
in order to keep north aligned.  The amount of rotation depends
on how close to the pole the mosaic field is located.

The solution is to manage the rotator control using a single target
(call it the master \radec)
that remains throughout the mosiacking run but is moved around in \xy:
\begin{itemize}
\item The \radec\ or \xy\ for the new mosaic sample is asserted
      and causes the mount to move accordingly.
\item A virtual-telescope calculation is performed which uses (i)~the
      master \radec\ and (ii)~the current mount angles to
      predict (iii)~the \xy\ where the master \radec\ will be imaged.
\item The rotator's virtual telescope calculation uses as its
      pointing origin this predicted \xy.
\end{itemize}

\newpage
\section{THE TCSpk DATA CONTEXT}

\ifx\vdoc\vshort
\abridged
\else
Here is a summary of the context information required to drive
a TCSpk ``instance''.  In places, the names of specific macros and
variables are quoted;  these are from the standard context definition
provided in the header file {\tt tcsctx.h}.  The latter will be
analyzed in detail in a later section.

\subsection{Initialization}

\begin{itemize}

\item {\bf Site longitude, latitude and height above sea level}

      Inaccurate site coordinates will show up as spurious
      polar/azimuth/roll axis misalignment parameters.  If
      grossly wrong, the refraction predictions will be
      unreliable.  Height makes little difference (but air
      pressure does---see below).

\item {\bf Telescope focal length}

      If the TCS does not support the pointing-origin feature,
      this can be set to any sensible value (say 1.0).

\item {\bf UT1--UTC}

      Zero will suffice on equatorial telescopes that do not
      have absolute encoding in RA, because the omission will be
      canceled out at ``sync'' time.

\item {\bf TAI--UTC}

      Zero will suffice on equatorial telescopes that do not
      have absolute encoding in RA.  The omission will be
      canceled out at ``sync'' time, except for second-order
      effects.

\item {\bf TT--TAI}

      Always 32.184~s.

\item {\bf Polar motion}

      Maximum amplitude about \arcsec{0}{5}: zero will
      suffice on all but the most accurate telescopes.

\item {\bf Refraction data}

      Temperature, pressure and relative humidity are all
      required, to whatever accuracy they are available.
      Pressure is the most critical one, and high-accuracy
      telescopes need it to 1~hPa (= 1~mB).  A fixed value for the
      tropospheric lapse rate of 0.0065~K/m is always
      acceptable.  For radio applications, high-accuracy
      temperature and (especially) humidity are also needed.  Finally,
      for optical/IR applications, a reference wavelength
      needs to be chosen, for example $0.5~\mu$m.

\item {\bf Mount type}

      One of {\tt ALTAZ}, {\tt EQUAT} or {\tt GIMBAL} needs to
      be specified.  If {\tt GIMBAL},
      there are numerical parameters as well, to specify the
      gimbal orientation.  (The other two are just special cases
      of the generalized gimbal.)

\item {\bf Rotator location}

      Use {\tt OTA} for ordinary non-Nasymyth, non-coud\'{e} applications,
      or where there is no rotator.

\item {\bf Initial mount coordinates}

      Some legal values are needed to start the system.  They
      do not have to reflect the actual attitude.

\item {\bf Zenith avoidance distance}

      TCSpk will divert tracks through the zenith so as to comply with
      this parameter.

\item {\bf Coordinate frames}

      Sky reference frames for controlling the telescope and rotator
      must be specified.  {\tt FK5} is the sensible default.  Along
      with each frame ID, an equinox is needed:  2000.0 is the
      obvious choice.  A wavelength has to be chosen as well,
      perhaps $0.55~\mu$m micrometers for visual use.  (Note that
      ICRS coordinates are the same as FK5 2000 coordinates to
      better than the $\sim$\arcsec{0}{1} accuracy required here.)

\item {\bf Pointing model}

      A pointing model is required.  It can be set up in two
      different ways, either term by term or by reading the file
      that the telescope pointing analysis package TPOINT writes
      when the {\tt OUTMOD} command is invoked.  It is possible to change
      the coefficient values while running (or even the form of
      the model);  the new corrections will take effect the
      next time the MEDIUM routine is run.  However, this is not
      usual.

\item {\bf Guiding adjustments}

      These should be initialized to zero.

\item {\bf Rotator readings}

      The system needs a rotator angle, plus a velocity
      and time-stamp, even if physically there is no
      rotator.  Simple equatorial and radio-antenna
      applications where
      there is no rotator should set all these to zero.

\end{itemize}

\subsection{Refraction}

\begin{itemize}

\item {\bf Meteorological readings plus color}

      The temperature, pressure, humidity, tropospheric lapse rate and
      reference wavelength can be changed at any time.  The
      changes will take effect when the SLOW routine is next
      run.  In the case of
      small telescopes of modest accuracy, although it
      is worth getting a pressure reading it is unlikely to
      need changing during the night.  If a pressure reading $p$
      is unavailable, it can be estimated (in hPa) from the observatory
      height above sea level in meters $h$ as follows:

      \[ p = 1013.25 e^{-h/(29.3 t_0)} \]

      where $t_0$ is the approximate sea-level air temperature in K.
      Note, however, that the refraction is proportional to the
      pressure and that an accurate pressure is important for
      serious work.

\end{itemize}

\subsection{Field Orientation}

This entire feature can be omitted if there is no rotator.
All the angles involved (IAA, IPA, RMA) should be set to
zero and then left alone.  (See also Section~\ref{fieldor},
p\pageref{fieldor}.)

\begin{itemize}

\item {\bf Instrument Alignment Angle}

      The IAA is specified by its sine and cosine.  The
      angle is nominated by the user and is likely to remain
      fixed for the whole session.

\item {\bf Instrument Position Angle}

      The user may wish to change the angle on the sky of
      the projection of his instrument.  On each occasion,
      all that is needed is the new angle.  The angle can
      be changed while tracking a target.

\item {\bf De-rotation criterion}

      The rotator demands that are generated can either
      freeze the IPD on the sky (``slit-optimized'')
      or can eliminate any overall
      rotation component (``field-optimized'').

\end{itemize}

\subsection{Pointing Origin}

Small-telescope applications may omit the entire
pointing-origin feature, though it can be useful if both a viewing
eyepiece and a CCD are used: the star can be slewed into
the eyepiece, centered, and then sent to the middle of the CCD
simply by changing the pointing-origin $x,y$.  To disable
the feature, set the first base $x,y$ and all
its offsets to zero, and (using the standard context
definitions) set {\tt npos} to zero in order to
select this pointing-origin.

\begin{itemize}

\item {\bf Base pointing-origins (NPOS of them)}

      The pointing-origin should be set to 0,0 by default,
      corresponding to the rotator axis (if there physically is a
      rotator).  Changing the $x,y$ while tracking will cause
      the star image to move to the specified location.

\item {\bf Offsets from base in x,y (three for each base; they add)}

      This is an advanced feature, used for such things
      as trailing the image along a spectrograph slit.
      The offsets should be left at zero if the feature
      is unwanted.

\item {\bf Pointing-origin selection}

      This integer, in the range 0 to {\tt NPOS}$-1$, selects which
      of the NPOS pointing-origins is to be used.  The target
      image will then transfer to this place in the focal
      plane automatically.

\end{itemize}

\subsection{Frames and Target}

The sky coordinate systems for controlling the mount and the
instrument rotator may be chosen individually.  The minimum
implementation would be a fixed frame of FK5/2000 (effectively the
same thing as Hipparcos/ICRS) for the mount and the same for the
rotator.

Although a fixed choice of sky frame can be used, all TCS
applications require the ability to change the target coordinates
of course.

\begin{itemize}

\item {\bf Mount frame (and equinox if needed)}

      This is the sky frame in which the mount pointing and tracking
      will be reckoned. In a modern TCS, FK5/2000 (equivalent to
      ICRS for practical purposes) can be used for
      almost everything.  However, for
      tracking the Sun or planets, topocentric apparent place may
      also be needed, depending on how the ephemeris
      data are being calculated.

\item {\bf Color for mount and rotator tracking}

      This allows atmospheric dispersion to be corrected.
      On small telescopes leave it set to (say)
      $0.55~\mu$m.

\item {\bf Rotator frame (and equinox if needed)}

      This is the sky frame in which the field orientation
      will be reckoned.  It specifies which sort of ``north''
      is to be used, for example J2000 or apparent.

\item {\bf Target coordinates}

      The target \radec\ (or \azel) can be changed at any
      time, on their own, causing the telescope to move
      to the new coordinates.  Various other actions may
      be required at the same time, for example resetting
      the offsets from base, reverting to the rotator-axis
      pointing-origin, resetting the guiding
      corrections and so on---it is up to the TCS designer
      to decide.

\item {\bf Differential rates and reference time}

      These allow solar-system objects to be tracked.  The
      reference time is the TAI MJD at which the supplied
      \radec\ was, or will be, correct.

\item {\bf Offsets from base}

      These allow advanced features such as scan patterns
      to be implemented.  It is better to use the offsets
      than the target coordinates, because the original
      (base) target can be recovered simply by resetting
      the offsets to zero.

\end{itemize}

\newpage
\fi

\section{HEADER FILES}

\ifx\vdoc\vshort
\abridged
\else
Four TCSpk {\tt \#include} files are provided:
\begin{itemize}

\item {\tt tcs.h} -- typedefs and function prototypes.

\item {\tt tcsmac.h} -- macros.

\item {\tt tcsctx.h} -- defines a typical {\tt context}, the
variables driving a TCSpk invocation.

\item {\tt dsactx.h} -- an example of an application-specific
context definition.

\end{itemize}
Most TCS applications require one use of {\tt tcsctx.h} (or some
adaptation of it) to define the data context for pointing at a
target. The definitions are {\tt static} and default
initialization to zero is assumed.  The main
program of the application and some individual functions
within an application will require {\tt tcs.h} in order to call
TCSpk functions.

\subsection{The tcs.h Header File}
\label{tcsdoth}

Most of the {\tt tcs.h} header file is taken up with function prototypes,
preceded by the definitions for the
types {\tt FRAMETYPE}, {\tt ROTLOC}, {\tt MTYPE} and {\tt PRF}.
Any TCS routine that needs to access a function with the {\tt tcs} or
{\tt tpt} prefix will need to include this header file.

\subsection{The tcsmac.h Header File}
\label{tcsmacdoth}

The following mathematical and physical constants are defined
in {\tt tcsmac.h}:
\begin{quote}
\begin{tabular}{ll}
{\tt DPI}   & $\pi$ \\
{\tt D2PI}  & $2\pi$ \\
{\tt DPI2}  & $\pi/2$ \\
{\tt DH2R}  & hours to radians \\
{\tt DS2R}  & seconds to radians \\
{\tt DD2R}  & degrees to radians \\
{\tt DAS2R} & arcseconds to radians \\
{\tt C}     & speed of light (AU/day) \\
{\tt AU2KM} & 1 AU in km \\
{\tt UTST}  & ratio of SI to ST second \\
{\tt STRPD} & Earth spin rate (radians/UT day) \\
\end{tabular}
\end{quote}

In addition there are some system constants, including {\tt DEL}, the
probe-vector spacing for Sky-Patch-Matrix generation
(default 0.005~radians).

\subsection{The tcsctx.h Header File}
\label{tcsctxdoth}

The {\tt \#include} file {\tt tcsctx.h}
defines the data items that make up a typical TCSpk context.

Note that a TCSpk context is not global: a
given application may support more than one.  For instance it
could be useful to provide a
separate context for the next science
target, allowing its observability to be assessed ahead
of time.  Devices such as autoguiders and tip-tilt
subreflectors will share most of the context but have their
own targets, coordinate transformations and so on.  An interferometer
might have a context with multiple telescope or antenna locations.

Nor is the layout or content of a TCSpk context fixed.  A given
application may elect not to support all the TCSpk capabilities, or
it may have additional locally-implemented ones.  An illustration
of this is the file {\tt dsactx.h}, which defines a context for a
deep-space tracking antenna application.

This flexibility is possible because the TCSpk functions pass everything
via arguments.  The context resides only in the application-specific
layer:  the same function can be called with different
arguments where required,
and zeroes or other dummy values may be specified where a given
feature is not of interest.

The context defined in {\tt tcsctx.h} is actually a rather
elaborate one, used in the {\tt tcs\_demo} demonstration.  Its
components are discussed in order of appearance.

\subsubsection{Site and telescope constants}
\begin{tabular}{lll}
{\tt tlongm} & {\tt double} & site mean east longitude (radians) \\
{\tt tlatm}  & {\tt double} & site mean geodetic latitude (radians) \\
{\tt hm}     & {\tt double} & site elevation, meters above sea-level \\
{\tt fl}     & {\tt double} & telescope focal length \\
\end{tabular}

\notelist
\begin{itemize}
\item For most observations, the site elevation is of little
      importance.
\item The telescope focal length is in any convenient units;  for
      example it can be set to unity. Its effect is to change the
      units in which pointing origin $x,y$ is specified.
\end{itemize}

\subsubsection{Time and Earth orientation constants}
\begin{tabular}{lll}
{\tt delut}  & {\tt double} & current UT1$-$UTC (day) \\
{\tt delat}  & {\tt double} & TAI$-$UTC (day) \\
{\tt ttmtai} & {\tt double} & TT$-$TAI (day) \\
{\tt xpmr}   & {\tt double} & polar-motion angle $x$ \\
{\tt ypmr}   & {\tt double} & polar-motion angle $y$ \\
\end{tabular}

\subsubsection{Atmospheric refraction}
\begin{tabular}{lll}
{\tt temp}  & {\tt double} & ambient temperature (K) \\
{\tt press} & {\tt double} & pressure (mB) \\
{\tt humid} & {\tt double} & relative humidity (0-1) \\
{\tt tlr}   & {\tt double} & tropospheric lapse rate (K per meter) \\
{\tt wavelr}& {\tt double} & reference wavelength ($\mu$m) \\
{\tt rfun}  & {\tt PRF}    & optional refraction function \\
\end{tabular}

\notelist
\begin{itemize}
\item mB = hPa.
\item Setting the pressure {\tt press} to zero is a good way to disable the
      refraction calculation when called for during debugging.
\item {\tt PRF} is a function pointer and defined in {\tt tcs.h}.
\end{itemize}

\subsubsection{Operational pointing model}
\begin{tabular}{lll}
{\tt model} & {\tt int[MAXTRM]} & term numbers for current model (0 = end) \\
{\tt coeffv} & {\tt double[MAXTRM]} & coefficient values (radians) \\
{\tt nterml} & {\tt int} & number of local terms \\
{\tt ntermx} & {\tt int} & number of terms implemented explicitly \\
{} & {} & \hfill (local+standard) \\
{\tt nterms} & {\tt int} & number of terms available currently \\
{} & {} & \hfill (local+standard+generic) \\
{\tt coeffn} & {\tt char[NTROOM][9]} & coefficient names (local,
                                standard, generic) \\
{\tt coform} & {\tt char[NTROOM][9]} & format of generic term \\
\end{tabular}

\notelist
\begin{itemize}
\item The size of the tables is controlled by the macros {\tt
NTROOM} and {\tt MAXTRM}. \item {\tt NTROOM} is the maximum number
of terms in the repertoire
      and is nominally set to 100.
\item {\tt MAXTRM} is the maximum number of terms in the
      model and is also set to 100.
\end{itemize}

\subsubsection{Mount}
\begin{tabular}{lll}
{\tt mount} & {\tt MTYPE} & mount type \\
{\tt ae2nm} & {\tt double[3][3]} & rotation matrix, \azel\ to nominal mount \\
\end{tabular}

\notelist
\begin{itemize}
\item {\tt MTYPE} is defined in {\tt tcs.h}. Three mount types are
      supported: {\tt EQUAT} for equatorial, {\tt ALTAZ} for altazimuth
      and {\tt GIMBAL} for generalized gimbal mount.
\item The {\tt ae2nm} matrix rotates target directions from true
      \azel\ to a perfect mount of the specified type.  It is the basis
      of the rotation from true \azel\ to the real mount, which will
      in general not be perfectly aligned.
\end{itemize}

\subsubsection{Location of instrument rotator}
\begin{tabular}{lll}
{\tt rotl} & {\tt ROTLOC} & rotator location \\
\end{tabular}

\anotelist
\begin{itemize}
\item {\tt ROTLOC} is defined in {\tt tcs.h}. Five options are supported:
      \begin{itemize}
      \item {\tt OTA} for = prime focus, Newtonian, Cassegrain,
            bent Cassegrain {\it etc.}
      \item {\tt NASMYTH\_L} for Nasmyth (left)
      \item {\tt NASMYTH\_R} for Nasmyth (right)
      \item {\tt COUDE\_L} for coud\'{e} (left)
      \item {\tt COUDE\_R} for coud\'{e} (right)
      \end{itemize}
\end{itemize}

\subsubsection{Pointing control}
\begin{tabular}{lll}
{\tt ia}    & {double} &       roll zero point \\
{\tt ib}    & {double} &       pitch zero point \\
{\tt np}    & {double} &       mount axes nonperpendicularity \\
{\tt xt}    & {double} &       telescope vector, $x$-coordinate \\
{\tt yt}    & {double} &       telescope vector, $y$-coordinate \\
{\tt zt}    & {double} &       telescope vector, $z$-coordinate \\
{\tt ae2mt} & {double[3][3]} & rotation matrix, \azel\ to mount \\
{\tt ga}    & {double} &       guiding adjustment, collimation \\
{\tt gb}    & {double} &       guiding adjustment, pitch \\
{\tt rnogo} & {double} &       mount pole avoidance radius \\
\end{tabular}

\notelist
\begin{itemize}
\item All of the above quantities are in radians (apart from the matrix).
\item The coefficients {\tt ia,ib,np}, the vector
      {\tt xt,yt,zt} and the matrix {\tt ae2mt} make up
      the basic pointing model. This is a condensed form of the operational
      pointing model.  The latter, which may have many terms, is
      periodically summarized into the basic form for rapid and
      singularity-free evaluation in real time.
\item The mount pole avoidance radius overrides the normal
      pointing
      when the target gets too close to the pole of the mount (for
      example the zenith in the altazimuth case).  If a different
      strategy is needed, this parameter may be set to zero.
\end{itemize}

\subsubsection{Site parameters, current}
\begin{tabular}{lll}
{\tt tlong} & {\tt double} & telescope longitude (true) \\
{\tt tlat} & {\tt double} & telescope latitude (geodetic, true) \\
{\tt uau} & {\tt double} & distance from spin axis (AU) \\
{\tt vau} & {\tt double} & distance from equator (AU) \\
{\tt ukm} & {\tt double} & distance from spin axis (km) \\
{\tt vkm} & {\tt double} & distance from equator (km) \\
{\tt diurab} & {\tt double} & diurnal aberration (radians) \\
\end{tabular}

\anotelist
\begin{itemize}
\item {\tt diurab} is the magnitude of the diurnal aberration vector, and
      is proportional to the site's distance from the Earth axis.
\end{itemize}

\subsubsection{Slowly changing target-independent items}
\begin{tabular}{lll}

{\tt t0} & {double} & raw clock time at reference time \\
{\tt st0} & {double} & LAST at reference time (radians) \\
{\tt tt0} & {double} & TT at reference time (MJD) \\
{\tt ttj} & {double} & TT at reference time (Julian Epoch) \\
{\tt amprms} & {double[21]} & target-independent mean-to-apparent parameters \\
{\tt refa} & {double} & refraction coefficient A for {\tt wavelr} \\
{\tt refb} & {double} & refraction coefficient B for {\tt wavelr} \\
\end{tabular}

\notelist
\begin{itemize}
\item The ``reference time'' is the TAI MJD of the last SLOW update
      and is used to extrapolate ST and TT

\item {\tt wavelr}, mentioned earlier, is the reference wavelength
      for
      which the {\tt refa,refb} refraction coefficients are calculated.
      Coefficients for other wavelengths are obtained by adjusting these
      reference coefficients.
\end{itemize}

\subsubsection{Tracking Frames}
\begin{tabular}{lll}
{\tt m\_cosys} & {FRAMETYPE} & mount tracking frame type \\
{\tt m\_eqx} & {double} & mount tracking frame equinox \\
{\tt m\_wavel} & {double} & mount tracking wavelength \\
{\tt r\_cosys} & {FRAMETYPE} & rotator orientation frame type \\
{\tt r\_eqx} & {double} & rotator orientation frame equinox \\
{\tt r\_wavel} & {double} & rotator orientation frame wavelength \\
\end{tabular}

\notelist
\begin{itemize}
\item A reference frame consists of a type and, in some cases,
      an equinox.
\item The type {\tt FRAMETYPE} is defined in {\tt tcs.h}.  Five
      options are supported:
      \begin{itemize}
      \item {\tt AZEL\_TOPO}: topocentric azimuth and elevation.
      \item {\tt APPT\_TOPO}: topocentric apparent \radec.
      \item {\tt APPT}: geocentric apparent \radec.
      \item {\tt FK5}: FK5 \radec\ (commonly equinox J2000).
      \item {\tt FK4}: FK4 \radec\ (commonly equinox B1950).
      \end{itemize}
\item For most practical purposes, FK5 J2000 is a synonym for ICRS.
\item It is not uncommon to use only two frame types, namely
      {\tt FK5} for pointing and {\tt AZEL\_TOPO} as a field-orientation
      option.
\item One approach to tracking solar-system targets is to supply
      astrometric places and let TCSpk pretend they are stars.  This
      breaks down for the Sun, and for Mercury and Venus when in or near
      transit, because of the way gravitational light deflection is
      handled.  For these targets, it is best to use topocentric
      apparent \radec.  This choice means that the target position
      takes into account parallax and aberration for the
      observer's location.
\item The mount and the rotator have independent frames, allowing for
      example tracking in J2000 \radec\ while stabilizing the
      instrument with respect to \azel.
\item There is a wavelength
      (for mount and rotator separately) which specifies which color
      in the dispersed image is being tracked.
\end{itemize}

\subsubsection{Target}
\begin{tabular}{lll}
{\tt m\_tar\_p0} & {\tt double[2]} & position at {\tt t0} \\
{\tt m\_tar\_dt} & {\tt double[2]} & differential tracking \\
{\tt m\_tar\_t0} & {\tt double} & reference time \\
{\tt m\_tar\_ob} & {\tt double[3][2]} & offsets from base \\
{\tt m\_tar\_op0} & {\tt double[2]} & offset position at {\tt t0} \\
{\tt m\_tar\_p} & {\tt double[2]} & final position \\
\end{tabular}

\notelist
\begin{itemize}
\item The target (where in the sky to point) consists of:
      \begin{itemize}
      \item position at reference time (spherical coordinates, radians)
      \item differential rates (radians/day)
      \item reference time (TAI MJD\footnote{The reference time would
            normally be specified in TT rather than TAI (or perhaps in
            UTC).  The responsibility for conversion into TAI
            lies outside TCSpk, for example in the user interface.})
      \item offsets from base (radians, threefold, additive)
      \item position at reference time including offsets from base
      \item current position including offsets and differential tracking.
      \end{itemize}
\item A target for the mount only is shown.  A more elaborate
      application might have a separate target for the rotator,
      enable the field orientation to be stabilized at a place
      in the focal plane different from the field center or
      science target.
\end{itemize}

\subsubsection{Pointing Origins}
\begin{tabular}{lll}
{\tt NPOS} & {\tt int} & number of preset pointing-origins \\
{\tt npo} & {\tt int} & currently-selected pointing-origin \\
{\tt m\_por\_p0} & {\tt double[NPOS][2]} & $x,y$ position \\
{\tt m\_por\_ob} & {\tt double[NPOS][3][2]} & offsets from base \\
{\tt m\_por\_p} & {\tt double[2]} & final $x,y$ \\
\end{tabular}

\notelist
\begin{itemize}
\item A pointing origin is the place in the focal plane
into
      which the image will be delivered.
\item It consists of:
      \begin{itemize}
      \item  $x,y$ position (same units as for focal length {\tt fl}, earlier)
      \item offsets from base (threefold, additive, same units)
      \end{itemize}
\item As a housekeeping aid, a list of {\tt NPOS} such pointing-origins is
      maintained to allow the application to direct the target's
      image to one of several places by changing just one integer,
      {\tt npo}.
      Setting {\tt NPOS} to 6 provides for rotator axis plus
      five deployable $x,y$ positions, perhaps push-button selectable
      on the user interface.
\item The pointing-origin $x,y$ coordinate system is fixed to the
      instrument rotator.  If the rotator is turned, the field will rotate
      about the currently selected pointing origin.
\item The offsets-from-base facility allows dithering and scanning
      relative to the pointing-origin concerned.
\item The final context item, {\tt m\_por\_p}, is the $x,y$ of the
      currently selected pointing origin, including any offsets.
\end{itemize}

\subsubsection{Field Orientation}
\label{fieldor}
\begin{tabular}{lll}
{\tt sia} & {\tt double} & sine of Instrument Alignment Angle \\
{\tt cia} & {\tt double} & cosine of Instrument Alignment Angle \\
{\tt pai} & {\tt double} & Instrument Position-Angle \\
{\tt jf}  & {\tt int}    & de-rotation criterion \\
\end{tabular}

\notelist
\begin{itemize}
\item The field orientation (how the image is oriented on the
      instrument) is specified in three stages:
      \begin{enumerate}
      \item The telescope user chooses some direction on the
            instrument that is convenient to work with.  This is
            called the {\it Instrument Principal Direction}\/ (IPD).  A
            typical choice of IPD would be the pixel $+y$ direction
            on a CCD.  Another would be the slit of a spectrograph.
      \item Through either mechanical preparation or
            on-the-sky calibration, the user provides the
            orientation of the IPD with respect to the $+y$ axis
            of the instrument rotator.  This angle is called the
            {\it Instrument Alignment Angle}\/ (IAA).
      \item The user then specifies what position-angle on the sky
            the IPD is to assume for the current observation.  This
            is called the {\it Instrument Position-Angle}\/ (IPA)
            and can be changed each time different field orientation
            on the instrument is required.
      \item Two choices of de-rotation are available.  ``Slit-optimized'',
            selected using {\tt jf=0}, means that stars near the
            pointing origin and lying along the IPD stay on that line,
            even though their separation may change slightly because
            of differential refraction.  ``Field-optimized'', selected
            by non-zero {\tt jf}, removes any overall residual rotation,
            without favouring the IPD.  The difference is always small,
            and setting {\tt jf=1} is usually safe.
      \end{enumerate}
\item The TCSpk-based system controls the rotator so that, where
      the pointing-origin is projected onto the sky, the projected IPD
      lies along the specified IPA.  The demand to the rotator that
      satisfies this condition is called the {\it Rotator Mechanical
      Angle}\/ (RMA).
\end{itemize}

\subsubsection{Sky-Patch Matrices}
Mount:

\begin{tabular}{lll}
{\tt m\_spm1   } & {\tt double[3][3]} & 1st SPM \\
{\tt m\_spm1\_i} & {\tt double[3][3]} & inverse of 1st SPM \\
{\tt m\_spm2   } & {\tt double[3][3]} & 2nd SPM \\
{\tt m\_spm2\_i} & {\tt double[3][3]} & inverse of 2nd SPM \\
\end{tabular}

Rotator:

\begin{tabular}{lll}
{\tt m\_spm1   } & {\tt double[3][3]} & 1st SPM \\
{\tt m\_spm1\_i} & {\tt double[3][3]} & inverse of 1st SPM \\
{\tt m\_spm2   } & {\tt double[3][3]} & 2nd SPM \\
{\tt m\_spm2\_i} & {\tt double[3][3]} & inverse of 2nd SPM \\
\end{tabular}

\notelist
\begin{itemize}
\item The {\it Sky-Patch matrices}\/ (SPMs) summarize important parts of the
      pointing transformation over a small region of sky, allowing fast
      but accurate astrometric transformations then to take
      place in that region.  They are refreshed typically every few seconds
      and give results accurate to a few milliarcseconds.
\item The first SPM in most cases describes the transformation from
      the user frame (say FK5 J2000 \radec)  to apparent \radec.
\item The second SPM in most cases describes the transformation
      from apparent \mhadec\ to mount coordinates.  Note that this
      includes refraction and mount misalignment.
\item ``In most cases'' means when the tracking frame is some kind
      of \radec;  however, the SPMs can also be used to control the
      telescope in an \azel\ frame.
\item Each SPM has a corresponding inverse, used for ``upstream''
      transformations---encoders to sky.
\item Between the first and second SPM there is a rotation about
      the $z$-axis. For the usual case where the user frame is an
      \radec, the rotation angle is the local apparent sidereal
      time.  For the case where the user frame is an \azel, the
      rotation angle is zero.
\item There are separate SPMs for mount and rotator.  The former look
      after tracking, while the second are used for calculating field
      orientation.
\item In an elaborate telescope that included autoguider probes,
      there would be additional sets of SPMs, dealing with the
      guide stars and probe positions.
\item The different sets of SPMs can be for different wavelengths so
      that, for example, a blue science target can be tracked using a
      red guide star.
\end{itemize}

\subsubsection{Mount/Rotator Status}
Mount:

\begin{tabular}{lll}
{\tt roll} & {\tt double} & demand mount roll angle (radians, lefthanded) \\
{\tt pitch} & {\tt double} & demand mount pitch angle (radians) \\
{\tt rota} & {\tt double} & demand rotator angle \\
{\tt jbp} & {\tt int} & {\tt TRUE} = ``below the pole'' \\
{\tt aux } & {\tt double[3]} & auxiliary readings \\
\end{tabular}

Rotator:

\begin{tabular}{lll}
{\tt rmat} & {\tt double} & time-stamp for rotator position and velocity \\
{\tt rma} & {\tt double} & rotator mechanical angle (radians) \\
{\tt rmav} & {\tt double} & rotator velocity (radians per tick) \\
\end{tabular}

\notelist
\begin{itemize}
\item The mount roll and pitch angles are \azel, \mhadec\ {\it
      etc.} \item The flag {\tt jbp} indicates the condition where the
      mechanical pitch angle lies outside $\pm\pi/2$. \item The
      ``auxiliary readings'' are any quantities other than mount
      attitude that affect the pointing corrections.  For example,
      there could be inputs from tilt-meters or temperature sensors.
\item The rotator velocity {\tt rmav} is the predicted change from
      time {\tt rmat} to the next time step or ``tick''.
\end{itemize}

\newpage
\fi

\section{THE TCSpk FILES}

This section gives details of all the ANSI C programs
and supporting files that make up the TCSpk
telescope control system pointing kernel.  There are five categories
of item, each dealt with separately.

The first category consists of all the TCSpk subroutines.  These C
functions make up the core of TCSpk and are designed
to be called directly by TCS applications.  As a
rule, special tailored versions will not be required ({\tt tcsMedium} is a
possible exception if greater control over scheduling is thought to
be desirable).
\ifx\vdoc\vshort
\abridged
\else
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt tcsAddtrm   \> add a pointing term to the model \\
\> \tt tcsAim2enc  \> aim vector to encoder demands \\
\> \tt tcsAim2s\_c \> aim vector to \xy \\
\> \tt tcsAim2xe   \> aim vector to \xieta \\
\> \tt tcsAimtrk   \> aim vector to mount demands \\
\> \tt tcsAstup    \> refresh the sky-patch matrices \\
\> \tt tcsBs       \> determine boresight \\
\> \tt tcsCasspa   \> transform rotator angle to Cassegrain equivalent \\
\> \tt tcsEnc2aim  \> encoder readings to target coordinates \\
\> \tt tcsG2po     \> absorb guiding corrections into pointing origin \\
\> \tt tcsG2tar    \> absorb guiding corrections into target \\
\> \tt tcsInit2    \> secondary initialization \\
\> \tt tcsIntpm    \> read pointing model from file \\
\> \tt tcsIterm    \> inquire pointing term \\
\> \tt tcsMedium   \> update pointing model and sky-patch matrices \\
\> \tt tcsPmt      \> translate summary pointing model into internal form \\
\> \tt tcsPorup    \> update the pointing-origin \\
\> \tt tcsPosture  \> form posture matrix from roll, pitch,
                                                      nonperpendicularity \\
\> \tt tcsProbev   \> generate probe vectors \\
\> \tt tcsPtran    \> transform sky vector to aim vector \\
\> \tt tcsPtrani   \> transform aim vector to sky coordinates\\
\> \tt tcsPup      \> update the pointing model \\
\> \tt tcsRotator  \> predict the rotator demand \\
\> \tt tcsSky2aim  \> transform sky coordinates to aim vector \\
\> \tt tcsSky2a\_c \> like {\tt tcsSky2aim} but Cartesian result \\
\> \tt tcsSlow     \> update slowly-changing target-independent items \\
\> \tt tcsSpm      \> obtain sky-patch matrix \\
\> \tt tcsSterm    \> set pointing term coefficient value \\
\> \tt tcsTargup   \> update the target coordinates \\
\> \tt tcsTartran  \> update the target transformation \\
\> \tt tcsTartr\_c \> like {\tt tcsTartran} but target Cartesian \\
\> \tt tcsTrack    \> generate mount demands to track a star \\
\> \tt tcsTrack\_c \> like {\tt tcsTrack} but target Cartesian \\
\> \tt tcsVTenc    \> virtual telescope: solve for encoder demands \\
\> \tt tcsVTenc\_c \> like {\tt tcsVTenc} but target Cartesian \\
\> \tt tcsVTsky    \> virtual telescope: solve for celestial coordinates \\
\> \tt tcsVTsky\_c \> like {\tt tcsVTsky} but Cartesian result \\
\> \tt tcsVTxe     \> virtual telescope: solve for \xieta \\
\> \tt tcsVTxe\_c  \> like {\tt tcsVTxe} but target Cartesian \\
\> \tt tcsVTxy     \> virtual telescope: solve for \xy \\
\> \tt tcsVTxy\_c  \> like {\tt tcsVTxy} but target Cartesian \\
\> \tt tcsXe2xy    \> \xieta\ to \xy \\
\> \tt tcsXy2xe    \> \xy\ to \xieta
\end{tabbing}
\fi
The second category includes those routines that are common to TCSpk
and the TPOINT pointing-analysis package.  In a few cases these
functions are directly callable by TCS applications but for the most
part they are called internally by TCSpk.
\ifx\vdoc\vshort
\abridged
\else
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt tptLength \> length of string excluding trailing blanks \\
\> \tt tptMinit  \> reset the pointing model \\
\> \tt tptPtappl \> apply one pointing term \\
\> \tt tptPterm  \> evaluate one pointing term \\
\> \tt tptPtermg \> evaluate a polynomial or harmonic pointing term \\
\> \tt tptPterml \> evaluate a local pointing term \\
\> \tt tptPterms \> evaluate a standard pointing term \\
\> \tt tptPtpre  \> preliminaries to evaluating a pointing term \\
\> \tt tptScomp  \> compare two strings ignoring trailing blanks \\
\> \tt tptTerm   \> translate a term name into a term number \\
\> \tt tptTrmgen \> add a polynomial or harmonic term to repertoire \\
\> \tt tptTrmloc \> add local terms to repertoire \\
\> \tt tptTrmstd \> add standard terms to repertoire
\end{tabbing}
\fi
The third category contains all the TCSpk subroutines not considered
to be part of the core set:
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt tcsFast    \> FAST routine used by {\tt tcs\_demo} demonstrator \\
\> \tt tcsRefsub  \> example refraction routine \\
\> \tt dsaRefsub  \> refraction routine used by {\tt tcs\_dsa}
                                                          demonstrator \\
\> \tt tcsTime    \> stub returning TAI time
\end{tabbing}
The fourth category contains main programs that demonstrate
TCSpk in various ways:
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt tcs\_demo \> TCS demonstration, optical telescope with rotator \\
\> \tt tcs\_dsa  \> deep-space tracking dish demonstration \\
\> \tt tcs\_equ  \> equatorial telescope TCS demonstration, no rotator \\
\> \tt tcs\_pa   \> determine P.A.~of instrument principal direction \\
\> \tt tcs\_test \> short TCSpk test \\
\> \tt tcs\_tpt  \> generate dummy observations for TPOINT analysis \\
\> \tt tcs\_zt   \> demonstrate altazimuth tracking through zenith \\
\end{tabbing}
The fifth and final category contains a few files that do not fit into
any of the previous categories:
\begin{tabbing}
xx \= xxxxxxxxxxxxxx \= \kill
\> \tt dsa.mod      \> specimen pointing-model file used by {\tt tcs\_dsa} \\
\> \tt makefile     \> Unix makefile \\
\> \tt refsub1.c    \> refraction routine, 1st example \\
\> \tt refsub2.c    \> refraction routine, 2nd example \\
\> \tt specimen.mod \> specimen pointing-model file used by {\tt tcs\_demo} \\
\end{tabbing}
All the TCSpk files are listed alphabetically at the end, with references to
the page numbers where their descriptions can be found.
\newpage
\subsection{TCSpk Core Functions}

This section gives details of all the functions that form the core of
TCSpk and will be called directly by TCS applications.

The functions are all re-entrant: there are no static variables.

Note that everything is passed through argument lists (some of which are
rather long as a consequence).  This is done so that multiple data
contexts and sub-contexts
can co-exist: there are no ``global data'' items.  With this
approach, there are fewer constraints on the host TCS application and,
crucially, multiple data contexts can be operated simultaneously.  The
latter property enables elaborate TCS applications to be constructed
that include multiple autoguiders, choreographed mount and tip-tilt
subreflector control, look-ahead and so on.

Only minimal use is made of data structures and type definitions, to
avoid consuming name-space.

When using a C++ compiler, all ``given'' arguments that are arrays are
declared with a const qualifier.

\ifx\vdoc\vshort
\abridged
\else

%-----------------------------------------------------------------------
\routine{tcsAddtrm}{Add Term to Pointing Model}
\label{tcsAddtrm}
\call{status = tcsAddtrm ( maxtrm, ntroom, cname, cvalue, nterms, \\
             \hspace*{10em} coeffn, coform, model, coeffv )}
\action{Add a pointing term to the model if it is not already present,
        and set its value.}
\args{GIVEN}
{
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{ntroom}{int}{maximum number of terms in repertoire} \\
\spec{cname }{char[9]}{name of term} \\
\spec{cvalue}{double}{coefficient value (radians)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{names of coefficients}
}
\args{RETURNED}{
\spec{nterms}{int*}{updated} \\
\spec{coeffn}{char[][9]}{updated} \\
\spec{coform}{char[][9]}{format of generic terms
                                               added to {\tt coeffn}} \\
\spec{model}{double[]}{term numbers for model (0 = end)} \\
\spec{coeffv}{double[]}{coefficient values}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
               status: & $ -2 = $ & no room left in model \\
                       & $ -1 = $ & unrecognized term \\
                       & $  0 = $ & no room for new generic term \\
                       & $ >0 = $ & term number (1\ldots) \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tcsAim2enc}{{\sc Aim} to Encoders}
\label{tcsAim2enc}
\call{tcsAim2enc ( xa, ya, za, rotl, rotap, ap, bp, xim, yim, \\
     \hspace*{6em} ia, ib, np, xt, yt, zt, ga, gb, \\
     \hspace*{6em} \&enca1, \&encb1, \&enca2, \&encb2, \&j )}
\action{Partial downstream (sky to encoders) tracking routine
        that starts with the {\sc Aim} vector and ends with the
        equivalent encoder readings.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} $x$-coordinate (Note~1)}\\
\spec{ya}{double}{{\sc Aim} $y$-coordinate (Note~1)}\\
\spec{za}{double}{{\sc Aim} $z$-coordinate (Note~1)}\\
\spec{rotl}{ROTLOC}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note~2)} \\
\spec{ap}{double}{predicted roll (Note~3)} \\
\spec{bp}{double}{predicted pitch (Note~3)} \\
\spec{xim}{double}{pointing origin $x$ (in focal lengths)} \\
\spec{yim}{double}{pointing origin $y$ (in focal lengths)} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{{\sc Telescope} vector, $x$-component (Note~4)} \\
\spec{yt}{double}{{\sc Telescope} vector, $y$-component (Note~4)} \\
\spec{zt}{double}{{\sc Telescope} vector, $z$-component (Note~4)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{enca1}{double*}{roll coordinate, first solution (Note~5)} \\
\spec{encb1}{double*}{pitch coordinate, first solution (Note~5)} \\
\spec{enca2}{double*}{roll coordinate, second solution (Note~5)} \\
\spec{encb2}{double*}{pitch coordinate, second solution (Note~5)} \\
\spec{j}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & no solutions (Note~6) \\
             \end{tabular}
             }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      target at the specified pointing-origin are calculated, starting
      from the {\sc Aim} vector.
\item The predicted rotator angle {\tt rotap} is the expected position of
      the mechanical rotator (whether at a coud\'{e} or Nasmyth focus,
      or mounted on the OTA) at the time for which the prediction is
      being made.
\item The arguments {\tt ap} and {\tt bp} are an estimate of the
      coordinates {\it a} and {\tt b} which are being computed.  The
      results are not very sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item If the mount is an altazimuth, the roll coordinate is $\pi-$azimuth
      and the pitch coordinate is elevation.  If the mount is an
      equatorial, roll is $-h$ and pitch is $\delta$.  For any
      accessible target, there are two solutions; depending on the type
      of mount, the two solutions correspond to above/below the pole,
      nearside/farside of the zenith, east/west of the pier, and so on.
\item Near the pole of the mount, especially when the collimation error
      or nonperpendicularity are large, there may be no combination of
      mount angles that images the target at the desired place.  In
      such cases, the status {\tt j} is set to the
      ``no solutions'' value, and
      the returned roll and pitch are set to safe values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsAim2s\_c}{{\sc Aim} to target xyz}
\label{tcsAim2s_c}
\call{tcsAim2s\_c ( xa, ya, za, spm1\_i, frame, sst, cst, spm2\_i, \\
      \hspace*{6em} \&xtar, \&ytar, \&ztar )}
\action{In a ``virtual telescope'', use the two inverse sky-patch
        matrices and an intermediate rotation to transform the
        {\sc Aim} vector into the target position in Cartesian form.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double}{{\sc Aim} $z$-coordinate (Note 1)} \\
\spec{spm1\_i}{double[3][3]}{inverse SPM \#1 (Note 3)} \\
\spec{frame}{\sc frametype}{tracking frame ID (Note 3)} \\
\spec{sst}{double}{sine of LAST (Notes 2,3)} \\
\spec{cst}{double}{cosine of LAST (Notes 2,3)} \\
\spec{spm2\_i}{double[3][3]}{inverse SPM \#2 (Note 3)}
}
\args{RETURNED}
{
\spec{xtar}{double*}{target $x$-coordinate} \\
\spec{ytar}{double*}{target $y$-coordinate} \\
\spec{ztar}{double*}{target $z$-coordinate}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the sky coordinates are predicted (in
      Cartesian form), starting from the {\sc Aim} vector.
\item The arguments {\tt sst} and {\tt cst}
      are the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1\_i}, {\tt sst}, {\tt cst} and
      {\tt spm2\_i} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \>  geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> topocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2\_i} \> topocentric \azel\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsAim2xe}{{\sc Aim} and \ab\ to \xieta}
\label{tcsAim2xe}
\call{tcsAim2xe ( xa, ya, za, a, b, np, xt, yt, zt, \&xi, \&eta, \&j )}
\action{In a ``virtual telescope'', given the {\sc Aim} vector,
        and knowing the mount roll/pitch \ab, determine the
        \xieta\ position of the image in the focal plane.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} $x$-coordinate} \\
\spec{ya}{double}{{\sc Aim} $y$-coordinate} \\
\spec{za}{double}{{\sc Aim} $z$-coordinate} \\
\spec{a}{double}{mount ``roll'' (Note 2)} \\
\spec{b}{double}{mount ``pitch'' (Note 2)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, x-component (Note 3)} \\
\spec{yt}{double}{telescope vector, y-component (Note 3)} \\
\spec{zt}{double}{telescope vector, z-component (Note 3)}
}
\args{RETURNED}
{
\spec{xi}{double*}{image $\xi$-coordinate (Note 4)} \\
\spec{eta}{double*}{image $\eta$-coordinate (Note 4)} \\
\spec{j}{int*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & star cannot be imaged
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates (sky,
      pointing-origin, mount), the
      missing coordinates can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the pointing origin is determined, starting
      from the {\sc Aim} vector and the encoder settings.
\item The roll and pitch are corrected for index errors,
      {\it i.e.}~they are the encoder settings plus the index errors.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item In impossible cases, zero is returned for both $\xi$
      and $\eta$, and the status {\tt j} is set to an error value.
\item This routine is optimized for speed, and accordingly only minimal
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible and safe values.
\end{enumerate}
}
\routine{tcsAimtrk}{{\sc Aim} to Tracking Demands}
\label{tcsAimtrk}
\call{tcsAimtrk ( xa, ya, za, rotl, rotap, \\
 \hspace*{5.5em} ap, bp, xim, yim, ia, ib, np,
                 xt, yt, zt, ga, gb, rnogo, \\
 \hspace*{5.5em} \&enca1, \&encb1, \&enca2, \&encb2, \&j ) }
\action{Part of the main telescope tracking routine: in a ``virtual
        telescope'', calculate the encoder demands required to image
        the target that corresponds to a given {\sc Aim} vector at a
        specified place in the focal plane.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double}{{\sc Aim} $z$-coordinate (Note 1)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note~2)} \\
\spec{ap}{double}{predicted roll (Note~3)} \\
\spec{bp}{double}{predicted pitch (Note~3)} \\
\spec{xim}{double}{pointing origin $x$ (in focal lengths)} \\
\spec{yim}{double}{pointing origin $y$ (in focal lengths)} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~4)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~4)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~4)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{rnogo}{double}{radius of ``no go'' region (radians, Note~5)}
}
\args{RETURNED}
{
\spec{enca1}{double*}{roll coordinate, first solution (Note~6)} \\
\spec{encb1}{double*}{pitch coordinate, first solution (Note~6)} \\
\spec{enca2}{double*}{roll coordinate, second solution (Note~6)} \\
\spec{encb2}{double*}{pitch coordinate, second solution (Note~6)} \\
\spec{}{int*}{\hspace{-1.8ex}
              \begin{tabular}[t]{lrl}
                 status: & $ +1 = $ & pole nogo =avoidance (Note~7) \\
                         & $  0 = $ & OK                      \\
                         & $ -1 = $ & no solutions (Note~7)   \\
              \end{tabular}
             }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      target corresponding to the specified {\sc Aim} vector at the
      specified pointing-origin are calculated.
\item The predicted rotator angle {\tt rotap} is the orientation that the
      mechanical rotator (whether at a coud\'e or Nasmyth focus, or
      mounted on the OTA) is expected to reach at the time for which
      the prediction is being made.  Note that it is the predicted
      achieved position, not a demand position.
\item The arguments {\tt ap} and {\tt bp} are an estimate of the coordinates
      {\tt a} and {\tt b} which are being computed.
      The results are not very
      sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Near the pole of the mounting ({\it i.e.}~the zenith in the case of an
      altazimuth) a variety of problems arises.  These include
      confusion about which way round to go, rivalry between the mount
      and rotator, and cases for which there are no solutions (see also
      Note~7).  In any event, there are limits to what speeds and
      accelerations the mechanical drives can achieve.  The present
      routine provides one strategy for avoiding difficulties in this
      region.

      The argument {\tt rnogo} specifies how close to the pole of the
      mounting the target is allowed to be.  If the target is too
      close, the routine aims instead for a fictitious target further
      out, on the edge of the forbidden region.  A warning status is
      set when this ``pole avoidance'' action is taken.

      It is permissible to set {\tt rnogo} to zero, and to handle any pole
      problems in the TCS application itself.  Two strategies that
      might be considered as an alternative to the {\tt rnogo} approach are
      (i)~progressive scaling back of certain of the pointing
      coefficients so that close to the pole the mount becomes
      nominally perfect, and (ii)~substituting a fictitious target that
      makes the telescope loiter on the edge of the awkward region
      until the real target catches up.
\item If the mount is an altazimuth, the roll coordinate is $\pi-$azimuth
      and the pitch coordinate is elevation.  If the mount is an
      equatorial, roll is $-h$ and pitch is $\delta$.  For any
      accessible target, there are two solutions; depending on the type
      of mount, the two solutions correspond to above/below the pole,
      nearside/farside of the zenith, east/west of the pier, and so on.
\item Near the pole of the mounting, especially when the collimation
      error or nonperpendicularity are large, there may be no mount
      posture that images the target at the desired place.  In these
      cases, the status {\tt j}
      is set to the ``no solutions'' value, and the
      returned roll and pitch are set to safe values.

      The ``no solution'' status overrides the ``pole avoidance'' status
      (see Note~5).
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsAstup}{Update Local Astrometry}
\label{tcsAstup}
\call{status = tcsAstup ( tai, ae2mt,
                          m\_cosys, m\_eqx, m\_wavel, \\
          \hspace*{9.6em} r\_cosys, r\_eqx, r\_wavel,
                          m\_tar\_p, t0, st0, ttj, \\
          \hspace*{9.6em} temp, press, humid, tlr, wavelr, refa, refb, \\
          \hspace*{9.6em} refsub, hm, tlat, diurab, amprms, \\
          \hspace*{9.6em} m\_spm1, m\_spm1\_i,
                          m\_spm2, m\_spm2\_i, \\
          \hspace*{9.6em} r\_spm1, r\_spm1\_i,
                          r\_spm2, r\_spm2\_i )}
\action{Update the local astrometry by recalculating the
        Sky-Patch Matrices.}
\args{GIVEN}
{
\spec{tai}{double}{time (TAI MJD = JD$-$2400000.5)} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount} \\
\spec{m\_cosys}{\sc frametype}{mount frame type} \\
\spec{m\_eqx}{double}{mount frame equinox} \\
\spec{m\_wavel}{double}{mount wavelength} \\
\spec{r\_cosys}{\sc frametype}{rotator orientation frame type} \\
\spec{r\_eqx}{double}{rotator orientation frame equinox} \\
\spec{r\_wavel}{double}{rotator orientation wavelength} \\
\spec{m\_tar\_p}{double[2]}{target coordinates} \\
\spec{t0}{double}{raw clock time at reference time} \\
\spec{st0}{double}{LAST at reference time (radians)} \\
\spec{ttj}{double}{TT at reference time (Julian epoch)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)    } \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavelr}{double}{reference wavelength (micrometers)} \\
\spec{refa}{double}{$\tan$ refraction constant} \\
\spec{refb}{double}{$\tan^3$ refraction constant} \\
\spec{refsub}{\sc prf}{optional refraction function} \\
\spec{hm}{double}{telescope height above sea level (meters)} \\
\spec{tlat}{double}{telescope latitude (true)} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\spec{amprms}{double[21]}{target-independent MAP parameters}
}
\args{RETURNED \rm (arguments)}
{
\spec{m\_spm1}{double[3][3]}{SPM \#1, mount} \\
\spec{m\_spm1\_i}{double[3][3]}{inverse SPM \#1, mount} \\
\spec{m\_spm2}{double[3][3]}{SPM \#2, mount} \\
\spec{m\_spm2\_i}{double[3][3]}{inverse SPM \#2, mount} \\
\spec{r\_spm1}{double[3][3]}{SPM \#1, rotator} \\
\spec{r\_spm1\_i}{double[3][3]}{inverse SPM \#1, rotator} \\
\spec{r\_spm2}{double[3][3]}{SPM \#2, rotator} \\
\spec{r\_spm2\_i}{double[3][3]}{inverse SPM \#2a, rotator}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & internal error (fatal) \\
             \end{tabular}
            }
}
\anote{Together with an intermediate
       rotation about the $z$-axis, the Sky-Patch Matrices
       summarize the
       transformation between target coordinates in the tracking frame
       and mount [roll,pitch].}
%-----------------------------------------------------------------------
\routine{tcsBs}{Obtain {\sc Boresight}}
\label{tcsBs}
\call{tcsBs ( xt, yt, zt, rotl, rma, a, b, ga, gb, xpo, ypo, \\
\hspace*{3.6em} \&xb, \&yb, \&zb ) }
\action{Determine the telescope {\sc Boresight} direction, in a righthanded
        Cartesian frame where the $x,y$ plane contains the nominal telescope
        and the pitch axis, and the $x$-axis is close to the telescope.}
\args{GIVEN}
{
\spec{xt}{double}{telescope vector, $x$-component (Note 1)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 1)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 1)} \\
\spec{rotl}{\sc rotloc}{rotator location (Note 2)} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{a}{double}{mount roll encoder reading (Note 3)} \\
\spec{b}{double}{mount pitch encoder reading (Note 3)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{xpo}{double}{pointing-origin $x$ (in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$ (in focal lengths)}
}
\args{RETURNED}
{
\spec{xb}{double*}{{\sc Boresight} $x$-coordinate (Note 4)} \\
\spec{yb}{double*}{{\sc Boresight} $y$-coordinate (Note 4)} \\
\spec{cb}{double*}{{\sc Boresight} $z$-coordinate (Note 4)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item If an invalid rotator-location code is presented, the OTA case
      (Cassegrain {\it etc.}) is assumed.
\item If the rotator location is OTA
      (Cassegrain {\it etc.}), the roll and pitch angles
      {\tt a} and {\tt b} are not used.
\item The {\sc Boresight} vector [xb,yb,zb] is expressed in a right-handed
      Cartesian frame where the $x,y$ plane contains the OTA and the
      pitch axis, and the $x$-axis is close to the OTA.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsCasspa}{RMA to Cass Equivalent}
\label{tcsCasspa}
\call{tcsCasspa ( rotl, rma, a, b, \&spa, \&cpa )}
\action{ Transform the rotator mechanical angle into the equivalent for
         rotator mounted at Cassegrain.  The angle is returned in the form
         of the sine and cosine.}
\args{GIVEN}
{
\spec{rotl}{\sc rotloc}{rotator location} \\
\spec{rma }{double}{rotator mechanical angle} \\
\spec{a}{double}{mount roll encoder reading} \\
\spec{b}{double}{mount pitch encoder reading}
}
\args{RETURNED}
{
\spec{spa}{double*}{sine of rotator angle} \\
\spec{cpa}{double*}{cosine of rotator angle}
}
\anote{If an invalid rotator-location code is presented, the
       Cassegrain ({\it i.e.}~OTA) case is assumed.}
%-----------------------------------------------------------------------
\routine{tcsEnc2aim}{Encoders \& {\sc Boresight} to {\sc Aim}}
\label{tcsEnc2aim}
\call{tcsEnc2aim ( enca, encb, xb, yb, zb, ia, ib, np, \&xa, \&ya, \&za )}
\action{In a ``virtual telescope'', calculate the {\sc Aim} vector
        that corresponds to the specified encoder readings and
        {\sc Boresight} vector.}
\args{GIVEN}
{
\spec{enca}{double }{mount ``roll'' encoder demand (Note 2)} \\
\spec{encb}{double }{mount ``pitch'' encoder demand (Note 2)} \\
\spec{xb}{double}{{\sc Boresight} $x$-coordinate} \\
\spec{yb}{double}{{\sc Boresight} $y$-coordinate} \\
\spec{zb}{double}{{\sc Boresight} $z$-coordinate} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)}
}
\args{RETURNED}
{
\spec{xa}{double*}{{\sc Aim} $x$-coordinate} \\
\spec{ya}{double*}{{\sc Aim} $y$-coordinate} \\
\spec{za}{double*}{{\sc Aim} $z$-coordinate}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the {\sc Aim} vector
      that corresponds to the given {\sc {\sc Boresight}} vector and
      the encoder readings is calculated.
\item If the mount is an altazimuth, {\tt enca} is $\pi-$azimuth
      and {\tt encb} is elevation.  If the mount is an equatorial,
      {\tt enca} is $-h$ and {\tt encb} is $\delta$.
\item This routine is optimized for speed, and accordingly no validation
      of the arguments is performed.  It is the caller's responsibility
      to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsG2po}{Absorb Guiding into P.O.}
\label{tcsG2po}
\call{tcsG2po ( tara, tarb, xpo, ypo, enca, encb, rotl, rma, \\
  \hspace*{4.6em} spm1, frame, sst, cst, spm2, \\
  \hspace*{4.6em} ia, ib, np, xt, yt, zt, \&obpox, \&obpoy, \&j )}
\action{Transform the guiding adjustments into pointing-origin offsets.}
\args{GIVEN}
{
\specsubhead{State before absorb operation} \\
\spec{tara}{double}{target ``roll'' coordinate ({\it e.g.}~$\alpha$)} \\
\spec{tarb}{double}{target ``pitch'' coordinate ({\it e.g.}~$\delta$)} \\
\spec{xpo}{double}{pointing-origin $x$-coordinate (in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$-coordinate (in focal lengths)} \\
\spec{enca}{double}{mount ``roll'' encoder demand (Note 2)} \\
\spec{encb}{double}{mount ``pitch'' encoder demand (Note 2)} \\
\specsubhead{Rotator} \\
\spec{rotl}{\sc rotloc}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\specsubhead{Celestial transformation} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 4)} \\
\spec{frame}{\sc frametype}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of local apparent sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of local apparent sidereal time (Notes 3,4)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 4)} \\
\specsubhead{Pointing model} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 5)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 5)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 5)}
}
\args{RETURNED}
{
\spec{obpox}{double*}{required change to $x$ (Note 1)} \\
\spec{obpoy}{double*}{required change to $y$ (Note 1)} \\
\spec{j}{int*}{\hspace{-1.8ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & impossible to do (Note 6)
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The ``absorb'' operation supported by the present routine
      re-expresses the current guiding adjustments as changes
      {\tt obpox,obpoy} to the pointing-origin \xy.

      Following the call to {\tt tcsG2po},
      if the guiding adjustments are reset
      to zero and {\tt obpox,obpoy} are added to the current
      pointing-origin \xy, the telescope will continue to track
      as if nothing has happened.

      A convenient way to apply the offsets is as ``offsets from base'',
      leaving the original pointing-origin \xy\ intact.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, enca is $\pi-$azimuth, {\tt encb} is elevation,
      {\tt tara} is $\alpha$ and {\tt tarb} is $\delta$.  If the mount
      is an equatorial, {\tt enca} is $-h$ and {\tt encb} is $\delta$.
      If the chosen
      frame is topocentric \azel, {\tt enca} is azimuth
      ({\it n.b.}~not $\pi-$azimuth) and {\tt encb} is elevation.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Only in pathological circumstances can an error status be
      returned.  Should this condition occur, however, the returned
      offsets are set to zero.
\item See also {\tt tcsG2tar}, which absorbs the guiding corrections into
      the target coordinates rather than the pointing origin.
\end{enumerate}
}
\routine{tcsG2tar}{Absorb Guiding into Target}
\label{tcsG2tar}
\call{tcsG2tar ( tara, tarb, xpo, ypo, enca, encb, rotl, rma, \\
   \hspace*{5em} spm1\_i, frame, sst, cst, spm2\_i, \\
   \hspace*{5em} ia, ib, np, xt, yt, zt, \\
   \hspace*{5.1em} \&obtara, \&obtarb ) }
\action{Transform the guiding adjustments into target coordinate offsets.}
\args{GIVEN}
{
\specsubhead{State before absorb operation} \\
\spec{tara}{double}{target ``roll'' coordinate ({\it e.g.}~$\alpha$)} \\
\spec{tarb}{double}{target ``pitch'' coordinate ({\it e.g.}~$\delta$)} \\
\spec{xpo}{double}{pointing-origin $x$-coordinate (in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$-coordinate (in focal lengths)} \\
\spec{enca}{double}{mount ``roll'' encoder demand (Note 2)} \\
\spec{encb}{double}{mount ``pitch'' encoder demand (Note 2)} \\
\specsubhead{Rotator} \\
\spec{rotl}{\sc rotloc}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\specsubhead{Celestial transformation} \\
\spec{spm1\_i}{double[3][3]}{inverse SPM \#1 (Note 4)} \\
\spec{frame}{\sc frametype}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of local apparent sidereal time (Notes 3,4)  } \\
\spec{cst}{double}{cosine of local apparent sidereal time (Notes 3,4)} \\
\spec{spm2\_i}{double[3][3]}{inverse SPM \#2 (Note 4)} \\
\specsubhead{Pointing model} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 5)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 5)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 5)}
}
\args{RETURNED}
{
\spec{obtara}{double*}{required change to target ``roll'' (Note 1)} \\
\spec{obtarb}{double*}{required change to target ``pitch'' (Note 1)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The ``absorb'' operation supported by the present routine
      re-expresses the current guiding adjustments as changes
      {\tt obtara, obtarb} (in radians) to the target coordinates.
      The latter are typically some form of \radec, and so
      {\tt obtara, obtarb} are typically $\Delta\alpha,\Delta\delta$.
      Following the call to {\tt tcsG2tar}, if the guiding adjustments
      are reset to zero and
      {\tt obtara,obtarb} are added to the current target, the
      telescope will continue to track as if nothing has happened.
      A convenient way to apply the offsets is as ``offsets from base'',
      leaving the original target coordinates intact.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, {\tt enca} is $\pi-$azimuth, {\tt encb} is elevation,
      {\tt tara} is $\alpha$ and {\tt tarb} is $\delta$.  If the mount
      is an equatorial, {\tt enca} is $-h$ and {\tt encb} is $\delta$.
      If the chosen frame is topocentric \azel, {\tt enca} is azimuth
      ({\it n.b.}~not $\pi-$azimuth) and {\tt encb} is elevation.
\item The arguments {\tt sst} and {\tt cst} are the sine
      and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1\_i}, {\tt sst}, {\tt cst} and
      {\tt spm2\_i} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \>  geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> topocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2\_i} \> topocentric \azel\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item See also {\tt tcsG2po}, which absorbs the guiding corrections
      into the pointing origin rather than the target coordinates.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsInit2}{Secondary Initialization}
\label{tcsInit2}
\call{status = tcsInit2 ( tlongm, tlatm, xpmr, ypmr, hm, \\
           \hspace*{9.6em}  mount, gim1z, gim2y, gim3x, \\
           \hspace*{9.6em}  ae2nm, tlong, tlat, uau, vau, ukm, vkm, diurab ) }
\action{Secondary initialization: prepare primary initialization
        data for use in the running system.}
\args{GIVEN}
{
\spec{tlongm}{double}{site mean east longitude (radians)} \\
\spec{tlatm}{double}{site mean geodetic latitude (radians)} \\
\spec{xpmr}{double}{polar-motion $x$ angle (radians)} \\
\spec{ypmr}{double}{polar-motion $y$ angle (radians)} \\
\spec{hm}{double}{site elevation, meters above sea-level} \\
\spec{mount}{\sc mtype}{mount type} \\
\spec{gim1z}{double}{mount orientation 1st rotation, about $z$ (see note)} \\
\spec{gim2y}{double}{mount orientation 2nd rotation, about $y$ (see note)} \\
\spec{gim3x}{double}{mount orientation 3rd rotation, about $x$ (see note)}
}
\args{RETURNED \rm (arguments)}
{
\spec{ae2nm}{double[3][3]}{rotation matrix, [Az,El] to nominal mount} \\
\spec{tlong}{double*}{telescope longitude (true)} \\
\spec{tlat}{double*}{telescope latitude (true)} \\
\spec{uau}{double*}{distance from spin axis (AU)} \\
\spec{vau}{double*}{distance from equator (AU)} \\
\spec{ukm}{double*}{distance from spin axis (km)} \\
\spec{vkm}{double*}{distance from equator (km)} \\
\spec{diurab}{double*}{diurnal aberration (radians)}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $      0 = $ & OK \\
                        & $ \neq 0 = $ & fatal error \\
             \end{tabular}
            }
}
\anote{The arguments {\tt gim1z}, {\tt gim2y} and {\tt gim3z} are the
       Euler angles that form the matrix {\tt ae2nm} =
       $R_1({\tt gim3x})R_2({\tt gim2y})R_3({\tt gim1z})$
       that rotates an \azel\ vector
       into nominal mount coordinates.}
%-----------------------------------------------------------------------
\routine{tcsIntpm}{Read Pointing Model from File}
\label{tcsIntpm}
\call{stat = tcsIntpm ( file, maxtrm, ntroom, \\
        \hspace*{8.6em} model, \&nterml, \&ntermx, \&nterms, \\
        \hspace*{8.6em} coeffn, coform, coeffv ) }
\action{Replace the current pointing model with one read from a file.
        The file must conform strictly to the format produced by the
        OUTMOD command in the TPOINT package, except that certain
        records and fields are ignored (Notes~1,2).}
\args{GIVEN}
{
\spec{file}{char[]}{the name of the file to be read} \\
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{ntroom}{int}{maximum number of terms allowed for}
}
\args{RETURNED \rm (arguments)}
{
\spec{model}{int[]}{term numbers for current model (0 = end)} \\
\spec{nterml}{int*}{number of local terms} \\
\spec{ntermx}{int*}{number of terms implemented explicitly} \\
\spec{}{}{\hfill (local+standard)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{coefficient names (local, standard, generic)} \\
\spec{coform}{char[][9]}{format of generic terms added to {\tt coeffn}} \\
\spec{coeffv}{double[]}{coefficient values}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                 status: & $  0 = $ & OK \\
                         & $ -1 = $ & unable to initialize model \\
                         & $ -2 = $ & unable to open input file \\
                         & $ -3 = $ & I/O error or premature EOF \\
                         & $ -4 = $ & unrecognized record \\
                         & $ -5 = $ & unable to add term to model \\
             \end{tabular}
            }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The file containing the pointing model must, as far as the
      basic layout is concerned, be exactly as
      written by the TPOINT's OUTMOD command
      (which indeed is the ideal way of generating the file).
      However, unlike TPOINT's
      INMOD command, the present routine does not support
      format changes and the insertion of comment records.  The
      first two records, which are ignored, may be used to record
      comments;  however, both must be present, as must the ``END''
      marker.  In the term records, the term name must start in
      column~3, and the coefficient value must not start before
      column~11.
\item Here is an example file (for an equatorial):

      \hspace*{2em}{\tt  AAT~~f/15~~1979/06/11} \\
      \hspace*{2em}{\tt  T~~~49~~~1.1206~~~52.015~~-0.0624} \\
      \hspace*{2em}{\tt  ~~IH~~~~~~~+174.7543~~~~~1.18854} \\
      \hspace*{2em}{\tt  ~=ZH~~~~~~~~~+3.5100} \\
      \hspace*{2em}{\tt  ~~ID~~~~~~~~+23.0464~~~~~0.35693} \\
      \hspace*{2em}{\tt \&=HFX~~~~~~~~+1.0000} \\
      \hspace*{2em}{\tt \&=HFD~~~~~~~~+1.0000} \\
      \hspace*{2em}{\tt \&~HF~~~~~~~~-18.7283~~~~~0.48982} \\
      \hspace*{2em}{\tt \&~X2HC~~~~~~~-3.1122~~~~~0.26477} \\
      \hspace*{2em}{\tt \&~NP~~~~~~~~~+2.9636~~~~~0.79658} \\
      \hspace*{2em}{\tt \&~CH~~~~~~~~-18.6889~~~~~1.20785} \\
      \hspace*{2em}{\tt  ~=ZE~~~~~~~~~+0.7000} \\
      \hspace*{2em}{\tt \&~ME~~~~~~~~+58.2504~~~~~0.43977} \\
      \hspace*{2em}{\tt \&~MA~~~~~~~~~+2.9518~~~~~0.24207} \\
      \hspace*{2em}{\tt  ~~TF~~~~~~~~~+8.9655~~~~~0.54629} \\
      \hspace*{2em}{\tt \&~TFP~~~~~~~~+1.1686~~~~~0.47733} \\
      \hspace*{2em}{\tt  END}

      Note the two initial records, which must be present but which are
      not interpreted, and the mandatory {\tt END} record.  Each of
      the remaining records defines a term and the corresponding coefficient
      value (in arcseconds).  For example, the record:

      \hspace*{2em}{\tt \&~ME~~~~~~~~+58.2504~~~~~0.43977}

      defines a term called {\tt ME} with a value of +58.2504~arcsec.  The
      additional flag and number are ignored.
\item If any invalid record is detected, the pointing model
      is reset and the rest of the input file is ignored.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsIterm}{Inquire Pointing Term}
\label{tcsIterm}
\call{status = tcsIterm ( iterm, maxtrm, model, coeffn, coeffv, \\
             \hspace*{9.5em} cname, cvalue )}
\action{Inquire name and value for a term in the pointing model.}
\args{GIVEN}
{
\spec{iterm }{int}{number of term to inquire (first = 1)} \\
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{model}{double[]}{term numbers for model (0 = end)} \\
\spec{coeffn}{char[][9]}{names of coefficients} \\
\spec{coeffv}{double[]}{coefficient values}
}
\args{RETURNED}{
\spec{cname }{char[9]}{name of inquired term} \\
\spec{cvalue}{double}{coefficient value (radians)}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
               status: & $ -1 = $ & specified term does not exist \\
                       & $  0 = $ & OK \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tcsMedium}{Medium-Frequency Updates}
\label{tcsMedium}
\call{status = tcsMedium ( tai, \\
            \hspace*{10em} maxtrm, model, coeffv, nterml, ntermx, nterms, \\
            \hspace*{10em} coeffn, coform, \\
            \hspace*{10em} mount, ae2nm, roll, pitch, jbp, aux, \\
            \hspace*{10em} m\_cosys, m\_eqx, m\_wavel, \\
            \hspace*{10em} r\_cosys, r\_eqx, r\_wavel, \\
            \hspace*{10em} m\_tar\_p, t0, st0, ttj, \\
            \hspace*{10em} temp, press, humid, tlr, \\
            \hspace*{10em} wavelr, refa, refb, refsub, \\
            \hspace*{10em} hm, tlat, diurab, amprms, \\
            \hspace*{10em} ia, ib, np, xt, yt, zt, ae2mt, \\
            \hspace*{10em} m\_spm1, m\_spm1\_i, m\_spm2, m\_spm2\_i, \\
            \hspace*{10em} r\_spm1, r\_spm1\_i, r\_spm2, r\_spm2\_i ) }
\action{The MEDIUM process: housekeeping tasks that operate at medium
        frequency, typically every few seconds.  The
        pointing corrections are updated and the
        sky-patch matrices recalculated.}
\args{GIVEN}
{
\specsubhead{Current Time} \\
\spec{tai}{double}{time (TAI MJD = JD$-$2400000.5)} \\
\specsubhead{Pointing Model} \\
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{model}{int[]}{term numbers for current model (0 = end)} \\
\spec{coeffv}{double[]}{coefficient values} \\
\spec{nterml}{int*}{number of local terms} \\
\spec{ntermx}{int*}{number of terms implemented explicitly} \\
\spec{}{}{\hfill (local+standard)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{coefficient names (local, standard, generic)} \\
\spec{coform}{char[][9]}{format of generic terms added to coeffn} \\
\specsubhead{Mount} \\
\spec{mount}{{\sc mtype}}{mount type} \\
\spec{ae2nm}{double[3][3]}{rotation matrix: [Az,El] to nominal mount} \\
\spec{roll}{double}{demand mount roll (radians, righthanded)} \\
\spec{pitch}{double}{demand mount pitch (radians)} \\
\spec{jbp}{int}{TRUE = ``below the pole''} \\
\spec{aux}{double[3]}{auxiliary readings}
}
\blank
{
\specsubhead{Frames} \\
\spec{m\_cosys}{{\sc frametype}}{mount frame type} \\
\spec{m\_eqx}{double}{mount frame equinox} \\
\spec{m\_wavel}{double}{mount wavelength} \\
\spec{r\_cosys}{{\sc frametype}}{rotator orientation frame type} \\
\spec{r\_eqx}{double}{rotator orientation frame equinox} \\
\spec{r\_wavel}{double}{rotator orientation wavelength} \\
\specsubhead{Target} \\
\spec{m\_tar\_p}{double[2]}{target coordinates} \\
\specsubhead{Time-Scales} \\
\spec{t0}{double}{raw clock time at reference time} \\
\spec{st0}{double}{LAST at reference time (radians)} \\
\spec{ttj}{double}{TT at reference time (Julian epoch)} \\
\specsubhead{Refraction} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavelr}{double}{reference wavelength (micrometers)} \\
\spec{refa}{double}{$\tan$ refraction constant} \\
\spec{refb}{double}{$\tan^3$ refraction constant} \\
\spec{refsub}{{\sc prf}}{optional refraction function} \\
\specsubhead{Site} \\
\spec{hm}{double}{telescope height above sea level (meters)} \\
\spec{tlat}{double}{telescope latitude (true)} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\specsubhead{Mean-to-Apparent} \\
\spec{amprms}{double[21]}{target-independent MAP parameters}
}
\newpage
\args{RETURNED \rm (arguments)}
{
\spec{ia}{double*}{roll zero point} \\
\spec{ib}{double*}{pitch zero point} \\
\spec{np}{double*}{mount axes nonperpendicularity } \\
\spec{xt}{double*}{telescope vector, $x$-component} \\
\spec{yt}{double*}{telescope vector, $y$-component} \\
\spec{zt}{double*}{telescope vector, $z$-component} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount} \\
\spec{m\_spm1}{double[3][3]}{SPM \#1, mount} \\
\spec{m\_spm1\_i}{double[3][3]}{inverse SPM \#1, mount} \\
\spec{m\_spm2}{double[3][3]}{SPM \#2, mount} \\
\spec{m\_spm2\_i}{double[3][3]}{inverse SPM \#2, mount} \\
\spec{r\_spm1}{double[3][3]}{SPM \#1, rotator} \\
\spec{r\_spm1\_i}{double[3][3]}{inverse SPM \#1, rotator} \\
\spec{r\_spm2}{double[3][3]}{SPM \#2, rotator} \\
\spec{r\_spm2\_i}{double[3][3]}{inverse SPM \#2, rotator}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & internal error (fatal) \\
             \end{tabular}
            }
}
\anote{In the normal case, where there is no user-supplied refraction
       function, the argument {\tt refsub} should be set to zero (or NULL).
       If this is achieved by referring to a function pointer variable,
       it is vital that it be initialized to zero (or NULL).  This can
       be achieved by an explicit declaration or by using static and
       relying on default initialization.  Failure to do this will
       result in undefined behaviour.}
%-----------------------------------------------------------------------
\routine{tcsPmt}{Translate Pointing Model}
\label{tcsPmt}
\call{status = tcsPmt ( pmodel, ae2nm, ota, jbp, \\
          \hspace*{8.5em} \&ia, \&ib, \&np, \&xt, \&yt, \&zt, ae2mt ) }
\action{Translate the pointing model from geometrical coefficients into the
        form needed for use.}
\args{GIVEN}
{
\spec{pmodel}{double[7]}{basic pointing model (Note~1)} \\
\spec{ae2nm}{double[3][3]}{nominal mount orientation matrix (Note~2)} \\
\spec{ota}{double[3]}{telescope \azel\ vector (Note~3)} \\
\spec{jbp}{int}{TRUE = ``below the pole''}
}
\args{RETURNED \rm (arguments)}
{
\spec{ia}{double*}{roll zero point (radians)} \\
\spec{ib}{double*}{pitch zero point (radians)} \\
\spec{np}{double*}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double*}{telescope vector, $x$-component (Note~4)} \\
\spec{yt}{double*}{telescope vector, $y$-component (Note~4)} \\
\spec{zt}{double*}{telescope vector, $z$-component (Note~4)} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
\item The matrix {\tt ae2nm} is the nominal \azel\ to [roll,pitch] rotation
      matrix.
\item The vector {\tt ota} is the best estimate of the current
      orientation of
      the (deflected) telescope optical axis in the \azel\ frame.  It
      is used to calculate the correction that must be applied to the
      demanded [roll,pitch] to compensate for vertical deflection.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsPorup}{Update P.O.~\xy}
\label{tcsPorup}
\call{tcsPorup ( por\_p0, por\_ob, por\_p ) }
\action{The pointing-origin \xy\ coordinates are updated, taking into account
        offsets from base.}
\args{GIVEN}
{
\spec{por\_p0}{double[2]}{base pointing-origin \xy} \\
\spec{por\_ob}{double[3][2]}{offsets from base}
}
\args{RETURNED}
{
\spec{por\_p}{double[2]}{current pointing-origin \xy}
}
%-----------------------------------------------------------------------
\routine{tcsPosture}{Obtain Posture Matrix}
\label{tcsPosture}
\call{ tcsPosture ( a, b, np, p ) }
\action{In a ``virtual telescope'', calculate the mount posture matrix for
        given roll, pitch and nonperpendicularity.}
\args{GIVEN}
{
\spec{a }{double}{mount ``roll'' (Note~2)} \\
\spec{b }{double}{mount ``pitch'' (Note~2)} \\
\spec{np}{double}{roll/pitch nonperpendicularity (radians)}
}
\args{RETURNED}
{
\spec{p}{double[3][3]}{the {\sc Boresight}-to-{\sc Aim} rotation matrix}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the rotation matrix
      {\tt p} that links the {\sc {\sc Boresight}} and
      {\sc Aim} vectors is determined, given the $yxz$ Euler angles
      {\tt b+ib}, {\tt np} and $-$({\tt a+ia}).
\item The supplied roll and pitch are already corrected for index
      errors, {\it i.e.}~the index errors {\tt ia}
      and {\tt ib} have been added to the
      the encoder readings before the present function is called.
\item This routine is optimized for speed, and accordingly no validation
      of the arguments is performed.  It is the caller's responsibility
      to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsProbev}{Generate SPM Probe Vectors}
\label{tcsProbev}
\call{ tcsProbev ( v0, del, v1, v2, v3 ) }
\action{Generate three probe vectors suitable for sampling the pointing
        transformation.}
\args{GIVEN}
{
\spec{v0}{double[3]}{central position} \\
\spec{del}{double}{radial distance of probe vectors (Note~3)}
}
\args{RETURNED}
{
\spec{v1}{double[3]}{1st probe vector} \\
\spec{v2}{double[3]}{2nd probe vector} \\
\spec{v3}{double[3]}{3rd probe vector}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item This routine returns three vectors surrounding the given one.
      The pattern is essentially an equilateral triangle with one
      vertex in the $+z$ direction;  each probe vector is {\tt del} radians
      from {\tt v0}.  Except for pathological cases, the method does not
      depend critically on any particular pattern or spacing.
\item The probe vectors are intended to be transformed in the
      application in order to explore the nature of the transformation
      in the region, the end result being a $3\times3$ matrix called the
      ``sky-patch matrix''.  The matrix is generated with the routine
      {\tt tcsSpm}.
\item If a {\tt del} value less than zero is supplied, a pattern is returned
      in which the third probe vector, {\tt v3}, is coincident with the central
      position, {\tt v0}.  This will ultimately yield SPMs that give perfect
      answers for the direction {\tt v0}.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsPtran}{{\sc Sky} to {\sc Aim}}
\label{tcsPtran}
\call{tcsPtran ( tdbj, amprms, ae2mt, hm, tlat, diurab, cosys, usreqx, \\
   \hspace*{5em} prepre, refa, refb, temp, press, humid,
                 tlr, wavel, \\
   \hspace*{5em} refsub, sst, cst, u, a, h, e ) }
\action{Pointing transformation: {\sc Sky} to {\sc {\sc Aim}}.}
\args{GIVEN}
{
\spec{tdbj}{double}{TDB Julian Epoch (TT will do)} \\
\spec{amprms}{double[21]}{mean to apparent parameters} \\
\spec{ae2mt}{double[3][3]}{\azel\ to mount [roll,pitch] matrix} \\
\spec{hm}{double}{height above sea level (meters)} \\
\spec{tlat}{double}{true geodetic latitude} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\spec{cosys}{{\sc frametype}}{reference frame ID (see below)} \\
\spec{usreqx}{double}{reference frame equinox (if a mean \radec)} \\
\spec{prepre}{double[3][3]}{user frame to B1950 or J2000 (if required)} \\
\spec{refa}{double}{refraction constant A} \\
\spec{refb}{double}{refraction constant B} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{refsub}{{\sc prf}}{optional refraction function} \\
\spec{sst}{double}{sine of LAST} \\
\spec{cst}{double}{cosine of LAST}
}
\args{RETURNED}
{
\spec{u}{double[3]}{target \xyz\ in tracking reference frame} \\
\spec{a}{double[3]}{target \xyz\ in pre-rotation frame} \\
\spec{h}{double[3]}{target \xyz\ in post-rotation frame} \\
\spec{e}{double[3]}{target \xyz\ in mount [roll,pitch] frame}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The {\tt u} vector is the {\sc Sky} target;
      the {\tt e} vector is the {\sc Aim}.
\item In the typical case, {\tt cosys} and {usreqx} are FK5 and J2000
      respectively, the vector {\tt u} is the nominated type of mean
      \radec, {\tt a} is geocentric apparent \radec,
      the rotation is sidereal time and {\tt h} is apparent \mhadec.
\item No check on {\tt cosys} validity is made.
      The serendipitous default is FK4.
\item For ICRS coordinates use FK5 J2000, which is a good
      (sub-\arcsec{0}{1}) approximation.
\item Topocentric and geocentric apparent \radec\ differ in that the
      former already contains diurnal aberration (and parallax) terms,
      making it especially suitable for solar-system targets.
\end{enumerate}
}
\routine{tcsPtrani}{{\sc Aim} to {\sc Sky}}
\label{tcsPtrani}
\call{tcsPtrani ( xa, ya, za, tdbj, amprms, ae2mt, hm, tlat, diurab, \\
  \hspace*{5.5em} cosys, usreqx, refa, refb, \\
  \hspace*{5.5em} temp, press, humid, tlr, wavel, refsub, sst, cst, \\
  \hspace*{5.5em} target ) }
\action{Inverse pointing transformation: {\sc {\sc Aim}} to {\sc Sky}.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} vector (mount frame) $x$} \\
\spec{ya}{double}{{\sc Aim} vector (mount frame) $y$} \\
\spec{za}{double}{{\sc Aim} vector (mount frame) $z$} \\
\spec{tdbj}{double}{TDB Julian Epoch (TT will do)} \\
\spec{amprms}{double[21]}{mean to apparent parameters} \\
\spec{ae2mt}{double[3][3]}{\azel\ to mount [roll,pitch] matrix} \\
\spec{hm}{double}{height above sea level (meters)} \\
\spec{tlat}{double}{true geodetic latitude} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\spec{cosys}{{\sc frametype}}{reference frame ID (see below)} \\
\spec{usreqx}{double}{reference frame equinox (if a mean \radec)} \\
\spec{refa}{double}{refraction constant A} \\
\spec{refb}{double}{refraction constant B} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{refsub}{{\sc prf} }{optional refraction function} \\
\spec{sst}{double}{sine of LAST} \\
\spec{cst}{double}{cosine of LAST}
}
\args{RETURNED}
{
\spec{target}{double[2]}{sky spherical coordinates, tracking frame}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item In the typical case, cosys and usreqx are FK5 and J2000
      respectively, the coordinates are \radec\ and the rotation is
      sidereal time.
\item In the typical case, {\tt cosys} is FK5/J2000,
      the coordinates are $\alpha$ and $\delta$
      and the rotation is sidereal time.
\item No check on {\tt cosys} validity is made.  The serendipitous default
      is FK4.
\item For ICRS coordinates use FK5 J2000, which is a good enough
      (sub-\arcsec{0}{1}) approximation.
\item Topocentric and geocentric apparent \radec\ differ in that the
      former already contains diurnal aberration (and parallax) terms,
      making it especially suitable for solar-system targets.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsPup}{Update the Pointing Model}
\label{tcsPup}
\call{status = tcsPup ( maxtrm, model, coeffv, nterml, ntermx, nterms, \\
        \hspace*{8.5em} coeffn, coform, mount,
                        ae2nm, roll, pitch, jbp, \\
        \hspace*{8.5em} aux, tlat,
                        \&ia, \&ib, \&np, \&xt, \&yt, \&zt, ae2mt ) }
\action{Update the pointing model.}
\args{GIVEN}
{
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{model}{int[]}{term numbers for current model (0 = end)} \\
\spec{coeffv}{double[]}{coefficient values} \\
\spec{nterml}{int*}{number of local terms} \\
\spec{ntermx}{int*}{number of terms implemented explicitly} \\
\spec{}{}{\hfill (local+standard)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{coefficient names (local, standard, generic)} \\
\spec{coform}{char[][9]}{format of generic terms added to coeffn} \\
\spec{mount}{{\sc mtype}}{mount type} \\
\spec{ae2nm}{double[3][3]}{rotation matrix: [Az,El] to nominal mount} \\
\spec{roll}{double}{demand mount roll (radians, righthanded)} \\
\spec{pitch}{double}{demand mount pitch (radians)} \\
\spec{jbp}{int}{TRUE = ``below the pole''} \\
\spec{aux}{double[3]}{auxiliary readings} \\
\spec{tlat}{double}{telescope latitude (true)}
}
\args{RETURNED \rm (arguments)}
{
\spec{ia}{double*}{roll zero point} \\
\spec{ib}{double*}{pitch zero point} \\
\spec{np}{double*}{mount axes nonperpendicularity} \\
\spec{xt}{double*}{telescope vector, $x$-component (Note~2)} \\
\spec{yt}{double*}{telescope vector, $y$-component (Note~2)} \\
\spec{zt}{double*}{telescope vector, $z$-component (Note~2)} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The chained/parallel option for the TPOINT pointing terms is
      not supported by the present routine.  The model is built by
      starting with the latest mount demands and calculating each
      term as a function of the current coordinates, as affected by
      the previous terms.  The resulting 7-term ``summary'' model is
      then used by starting with the observed place and working
      towards demanded mount roll and pitch.  The TPOINT options
      that provide the best match to this behaviour are ``adjust
      telescope'' and ``all terms chained''.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The function should be called whenever anything has changed
      that may affect the pointing significantly.  During
      tracking, it is usually
      sufficient to schedule calls at fairly frequent regular
      intervals, say 5\,s.  However, it may be also necessary
      to trigger an update when the demanded roll and pitch angles
      have changed by more than some threshold amount.  This is
      particularly true if the telescope or antenna is unusually
      agile or if the model contains terms of large amplitude
      and/or high spatial frequency.
\end{enumerate}
}
\routine{tcsRotator}{Predict Rotator Angle}
\label{tcsRotator}
\call{tcsRotator ( xa, ya, za, rotl, rdp, jbp, ad, bd, xpo, ypo, \\
     \hspace*{6em} ia, ib, np, xt, yt, zt, ga, gb, sia, cia, \\
     \hspace*{6em} r\_spm1\_i,
                   r\_frame, sst, cst,
                   r\_spm2\_i, pai, jf, \\
     \hspace*{6em} \&rd, \&j ) }
\action{Use ``virtual telescope'' techniques to predict the
        instrument rotator angle demand.}
\args{GIVEN}
{
\spec{xa}{double}{{\sc Aim} $x$-coordinate (Note~1)} \\
\spec{ya}{double}{{\sc Aim} $y$-coordinate (Note~1)} \\
\spec{za}{double}{{\sc Aim} $z$-coordinate (Note~1)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rdp}{double}{predicted rotator demand} \\
\spec{jbp}{int}{FALSE/TRUE = above/below pole (Note~2)} \\
\spec{ad}{double}{demand roll (Note~2)} \\
\spec{bd}{double}{demand pitch (Note~2)} \\
\spec{xpo}{double}{pointing-origin $x$(in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$(in focal lengths)} \\
\spec{ia}{double}{roll zero point} \\
\spec{ib}{double}{pitch zero point} \\
\spec{np}{double}{nonperpendicularity} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~3)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~3)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~3)} \\
\spec{ga}{double}{guiding adjustment, collimation} \\
\spec{gb}{double}{guiding adjustment, pitch} \\
\spec{sia}{double}{sine of Instrument Alignment Angle} \\
\spec{cia}{double}{cosine of Instrument Alignment Angle} \\
\spec{r\_spm1\_i}{double[3][3]}{inverse SPM \#1 for the rotator frame} \\
\spec{r\_frame}{{\sc frametype}}{rotator tracking frame ID} \\
\spec{sst}{double}{sine of sidereal time (Note~5)} \\
\spec{cst}{double}{cosine of sidereal time (Note~5)} \\
\spec{r\_spm2\_i}{double[3][3]}{inverse SPM \#2 for the rotator frame} \\
\spec{pai}{double}{requested Instrument Position Angle} \\
\spec{jf}{int}{true = optimize for field (Note~6)}
}
\args{RETURNED}
{
\spec{rd}{double*}{required rotator mechanical angle} \\
\spec{j }{int*}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, virtual telescope techniques are used to project
      from the focal plane to the sky and thereby establish the field
      orientation.
\item The predicted demand roll and pitch,
      {\tt ad} and {\tt bd}, are for the time
      for which the rotator demand is required.  If the call to
      {\tt tcsRotator} immediately follows
      a call to {\tt tcsTrack}, which is
      commonly the case, then {\tt ad} and {\tt bd}
      are simply the roll and pitch
      demands just calculated.  The above/below pole flag,
      {\tt jbp}, is in
      principle superfluous, because it can be deduced from the demand
      pitch.  However, it is in practice more convenient to treat the
      flag and the predicted demands as separate entities.  The result
      is in any case insensitive to the precise vaues of
      {\tt ad} and {\tt bd} supplied.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The basic method is as follows.  First a partial sky-to-encoders
      transformation is performed, starting with the {\sc Aim} vector and
      using as the rotator angle the estimated demand for the time in
      question, and predicting the corresponding encoder readings.
      Then, transformations back up to target coordinates (in the
      rotator tracking frame) are performed for small displacements
      of the pointing-origin lying along the user's specified
      Instrument Principal Direction (IPD).  The disposition of these
      points on the sky therefore defines the IPD's position-angle for
      the predicted demand rotator angle.  The error, {\it i.e.}~the
      difference between the requested and actual demand rotator angle,
      is calculated.  The new rotator demand is simply the estimated
      demand minus the error.

      Repeated calls to this routine, using the new demand as the
      estimated demand for the next iteration, will lead to
      convergence.  Explicit iteration is unlikely to be needed
      operationally if the rotator calculation is being performed
      as part of the regular tracking updates, say at 20~Hz.
\item The arguments {\tt sst} and {\tt cst}
      are the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The basic algorithm predicts the rotator angle that fixes the IPD
      on the sky.  This is optimal for a slit instrument (assuming that
      the slit is chosen as the IPD).  The {\tt jf} argument allows an
      alternative compromise to be made that minimizes the field
      rotation overall, rather than favouring the IPD.  For {\tt jf=0},
      the ``slit'' optimization is selected;  otherwise ``field''
      optimization is selected.  (Field optimization is accomplished by
      sampling the rotation a second time, at right angles to the IPD,
      and averaging the two results.)  If in doubt, set {\tt jf=1}.
\item This routine is optimized for speed, and accordingly no
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible values.
\item Bad status ({\tt j}$<0$) should not
      be possible if the TCS application
      has taken measures to ensure that the {\sc Aim} vector does not lie in
      the inaccessible region near the roll pole of the mount.  If the
      condition does occur for some reason, a harmless result will be
      returned.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsSky2aim}{Target to {\sc Aim} Vector}
\label{tcsSky2aim}
\call{tcsSky2aim ( tara, tarb, spm1, frame, sst, cst, spm2, \\
   \hspace*{6.1em} \&xa, \&ya, \&za ) }
\action{In a ``virtual telescope'', for the specified target, predict the
        {\sc Aim} vector (the direction in which to aim,
        in mount coordinates).}
\args{GIVEN}
{
\spec{tara}{double}{target ``roll'' coordinate (Note 1)} \\
\spec{tarb}{double}{target ``pitch'' coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 3)} \\
\spec{sst}{double}{sine of sidereal time (Notes 2,3)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)}
}
\args{RETURNED}
{
\spec{xa}{double*}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double*}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double*}{{\sc Aim} $z$-coordinate (Note 1)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the {\sc Aim} vector is calculated, starting
      from the sky target.
\item The arguments {\tt sst} and {\tt cst}
      are the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item This routine is optimized for speed, and accordingly no
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible values.
\end{enumerate}
}
\routine{tcsSky2a\_c}{Target xyz to {\sc Aim}}
\label{tcsSky2a_c}
\call{tcsSky2a\_c ( xtar, ytar, ztar, spm1, frame, sst, cst, spm2, \\
      \hspace*{6em} \&xa, \&ya, \&za ) }
\action{In a ``virtual telescope'', use the two sky-patch matrices and an
        intermediate rotation to transform the target position in Cartesian
        form into the {\sc Aim} vector (the direction in
        which to aim, in mount coordinates).}
\args{GIVEN}
{
\spec{xtar}{double}{target $x$-coordinate (Note 1)} \\
\spec{ytar}{double}{target $y$-coordinate (Note 1)} \\
\spec{ztar}{double}{target $z$-coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{tracking frame ID (Note 3)} \\
\spec{sst}{double}{sine of LAST (Notes 2,3)} \\
\spec{cst}{double}{cosine of LAST (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)}
}
\args{RETURNED}
{
\spec{xa}{double*}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double*}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double*}{{\sc Aim} $z$-coordinate (Note 1)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the {\sc Aim} vector is calculated, starting
      from the sky target expressed in Cartesian coordinates.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsSlow}{Low-Frequency Updates}
\label{tcsSlow}
\call{tcsSlow ( tai, delut, delat, ttmtai, \\
\hspace*{4.6em} temp, press, humid, wavelr, tlong, \\
\hspace*{4.6em} t0, st0, tt0, ttj, amprms, refa, refb ) }
\action{The SLOW process:  housekeeping tasks that operate at low
        frequency, say once a minute.  The items that are
        are updated are slowly-changing and target-independent.}
\args{GIVEN}
{
\spec{tai}{double}{time (TAI Modified Julian Date, JD$-$2000000.5)} \\
\spec{delut}{double}{current UT1$-$UTC (day)} \\
\spec{delat}{double}{TAI$-$UTC (day)} \\
\spec{ttmtai}{double}{TT$-$TAI (day)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{wavelr}{double}{reference wavelength (micrometers)} \\
\spec{tlong}{double}{telescope longitude (true)}
}
\args{RETURNED}
{
\spec{t0}{double*}{reference time (TAI MJD)} \\
\spec{st0}{double*}{LAST at reference time (radians)} \\
\spec{tt0}{double*}{TT at reference time (MJD)} \\
\spec{ttj}{double*}{TT at reference time (Julian Epoch)} \\
\spec{amprms}{double[21]}{target-independent MAP parameters} \\
\spec{refa}{double*}{$\tan$ refraction constant} \\
\spec{refb}{double*}{$\tan^3$ refraction constant}
}
%-----------------------------------------------------------------------
\routine{tcsSpm}{Form a Sky-Patch Matrix}
\label{tcsSpm}
\call{status = tcsSpm ( v1, v2, v3, v1r, v2r, v3r, spm ) }
\action{Solve probe vector samples to form the sky-patch matrix.}
\args{GIVEN}
{
\specsubhead{The probe vectors before transformation} \\
\spec{v1}{double[3]}{1st probe vector} \\
\spec{v2}{double[3]}{2nd probe vector} \\
\spec{v3}{double[3]}{3rd probe vector} \\
\specsubhead{The probe vectors after transformation} \\
\spec{v1r}{double[3]}{1st transformed probe vector} \\
\spec{v2r}{double[3]}{2nd transformed probe vector} \\
\spec{v3r}{double[3]}{3rd transformed probe vector}
}
\args{RETURNED \rm (argument)}
{
\spec{spm}{double[3][3]}{sky-patch matrix}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & singularity (fatal) \\
             \end{tabular}
            }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item On the basis of three ``probe vectors'' in a small region of interest
      which have been transformed in some locally smooth way, this routine
      determines a matrix, called the ``sky-patch matrix'' (SPM)
      which describes the three probe transformations
      exactly and which may therefore be expected to describe other
      transformations in the same area to some useful degree of
      approximation.
\item The probe vectors can be generated using the routine {\tt tcsProbev}.
\item To show how a matrix can be devised that satisfies
      all three of
      the probe transformations, consider the vectors laid out as three
      sets of simultaneous equations (nomenclature:  $x_1$ is {\tt v1[0]},
                      $x_1^r$ is {\tt v1r[0]} {\it etc.}):
      \begin{eqnarray*}
      x_1^r & = & \alpha x_1 + \beta y_1 + \gamma z_1 \\
      x_2^r & = & \alpha x_2 + \beta y_2 + \gamma z_2 \\
      x_3^r & = & \alpha x_3 + \beta y_3 + \gamma z_3
      \end{eqnarray*}
      This set can be solved for $\alpha,\beta,\gamma$.
      \begin{eqnarray*}
      y_1^r & = & \delta x_1 + \epsilon y_1 + \zeta z_1 \\
      y_2^r & = & \delta x_2 + \epsilon y_2 + \zeta z_2 \\
      y_3^r & = & \delta x_3 + \epsilon y_3 + \zeta z_3
      \end{eqnarray*}
      This set can be solved for $\delta,\epsilon,\zeta$.
      \begin{eqnarray*}
      z_1^r & = & \eta x_1 + \theta y_1 + \iota z_1 \\
      z_2^r & = & \eta x_2 + \theta y_2 + \iota z_2 \\
      z_3^r & = & \eta x_3 + \theta y_3 + \iota z_3
      \end{eqnarray*}
      This set can be solved for $\eta,\theta,\iota$.

      Note that the matrix of coefficients in each case is the same:
      \[ \left( \begin{array}{ccc}
                x_1 & y_1 & z_1 \\
                x_2 & y_2 & z_2 \\
                x_3 & y_3 & z_3
                \end{array} \right) \]
      and so only one matrix inversion has to be carried out to solve
      all three sets.

      Dropping the numerical subscripts, the solutions to
      these nine equations can be written out as:
      \[ \left( \begin{array}{c}
                   x^r \\
                   y^r \\
                   z^r
                \end{array} \right) =
         \left( \begin{array}{ccc}
                   \alpha & \beta    & \gamma \\
                   \delta & \epsilon & \zeta \\
                   \eta   & \theta   & \iota
                \end{array} \right) \times
         \left( \begin{array}{c}
                   x \\
                   y \\
                   z
                 \end{array} \right) \]
      Thus the relationship between the three probe vectors and their
      transformations, and to some hopefully useful accuracy the
      relationship between any other vector in the region and its
      transformation, is encapsulated in the matrix, which is called
      the ``sky-patch matrix'' (SPM).
\item The inverse SPM is obtained simply by calling the present routine
      with the roles of the two vectors reversed.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsSterm}{Set Pointing Term}
\label{tcsSterm}
\call{status = tcsSterm ( cname, cvalue, maxtrm, model, coeffn, coeffv )}
\action{Set the coefficient value for a specified term in the pointing model.}
\args{GIVEN}
{
\spec{cname }{char[9]}{name of term} \\
\spec{cvalue}{double}{new coefficient value (radians)} \\
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{model}{double[]}{term numbers for model (0 = end)} \\
\spec{coeffn}{char[][9]}{names of coefficients}
}
\args{RETURNED \rm (argument)}
{
\spec{coeffv}{double[]}{coefficient values}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
               status: & $ -1 = $ & specified term is not in model \\
                       & $  0 = $ & OK \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tcsTargup}{Update Target}
\label{tcsTargup}
\call{tcsTargup ( tai, tar\_t0, tar\_p0, tar\_dt, tar\_ob,
                  tar\_op0, tar\_p ) }
\action{The target coordinates are updated, taking into account
        differential tracking and offsets from base.}
\args{GIVEN}
{
\spec{tai}{double}{time (TAI MJD = JD$-$2400000.5)} \\
\spec{tar\_t0}{double}{reference time (TAI MJD)} \\
\spec{tar\_p0}{double[2]}{position at reference time (spherical} \\
\spec{}{}{\hfill coordinates, {\it e.g.}~\radec, in radians)} \\
\spec{tar\_dt}{double[2]}{differential rates (radians/day)} \\
\spec{tar\_ob}{double[3][2]}{offset(s) from base (radians)}
}
\args{RETURNED}
{
\spec{tar\_op0}{double[2]}{target coordinates at reference time} \\
\spec{tar\_p}{double[2]}{current target coordinates}
}
\anote{The coordinates {\tt tar\_op0}
       include offsets from base but do not
       include the effects of differential tracking.  The coordinates
       {\tt tar\_p} include both.}
%-----------------------------------------------------------------------
\routine{tcsTartr\_c}{Update xyz Target Transformation}
\label{tcsTartr_c}
\call{status = tcsTartr\_c ( tdbj, amprms, ae2mt, hm, tlat, diurab, \\
           \hspace*{10.5em} refa, refb, temp, press, humid, tlr, wavel, \\
           \hspace*{10.5em} refsub, sst, cst, cosys, usreqx, \\
           \hspace*{10.5em} xtar, ytar, ztar, \\
           \hspace*{10.5em} spm1, spm1\_i,
                            spm2, spm2\_i ) }
\action{Update target transformation.  The target is
        specified in Cartesian form.}
\args{GIVEN}
{
\spec{tdbj}{double}{TDB Julian Epoch (TT will do)} \\
\spec{amprms}{double[21]}{mean to apparent parameters} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount} \\
\spec{hm}{double}{height above sea level (meters)} \\
\spec{tlat}{double}{true geodetic latitude} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\spec{refa}{double}{refraction constants A and\ldots} \\
\spec{refb}{double}{\ldots B for tracking wavelength (radians)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{refsub}{{\sc prf}}{optional refraction function} \\
\spec{sst}{double}{sine of LAST} \\
\spec{cst}{double}{cosine of LAST} \\
\spec{cosys}{{\sc frametype}}{tracking frame ID} \\
\spec{usreqx}{double}{tracking frame equinox (mean \radec\ only) } \\
\spec{xtar}{double}{target $x$-coordinate (see note)} \\
\spec{ytar}{double}{target $y$-coordinate (see note)} \\
\spec{ztar}{double}{target $z$-coordinate (see note)}
}
\args{RETURNED \rm (arguments)}
{
\spec{spm1}{double[3][3]}{SPM \#1} \\
\spec{spm1\_i}{double[3][3]}{inverse of SPM \#1} \\
\spec{spm2}{double[3][3]}{SPM \#2} \\
\spec{spm2\_i}{double[3][3]}{inverse of SPM \#2}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & internal error (fatal) \\
             \end{tabular}
            }
}
\anote{The target vector is right-handed, so special care must be
       taken if using \azel, which is a left-handed system.  The
       procedure in this case is to perform the standard
       spherical-to-Cartesian transformation and then to reverse the
       sign of the {x}-coordinate.}
%-----------------------------------------------------------------------
\routine{tcsTartran}{Update Target Transformation}
\label{tcsTartran}
\call{status = tcsTartran ( tdbj, amprms, ae2mt, hm, tlat, diurab, \\
           \hspace*{10.5em} refa, refb, temp, press, humid, tlr, wavel, \\
           \hspace*{10.5em} refsub, sst, cst, cosys, usreqx, target, \\
           \hspace*{10.5em} spm1, spm1\_i,
                            spm2, spm2\_i ) }
\action{Update target transformation.}
\args{GIVEN}
{
\spec{tdbj}{double}{TDB Julian Epoch (TT will do)} \\
\spec{amprms}{double[21]}{mean to apparent parameters} \\
\spec{ae2mt}{double[3][3]}{rotation matrix, \azel\ to mount} \\
\spec{hm}{double}{height above sea level (meters)} \\
\spec{tlat}{double}{true geodetic latitude} \\
\spec{diurab}{double}{diurnal aberration (radians)} \\
\spec{refa}{double}{refraction constants A and\ldots} \\
\spec{refb}{double}{\ldots B for tracking wavelength (radians)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (mB=hPa)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{refsub}{{\sc prf}}{optional refraction function} \\
\spec{sst}{double}{sine of LAST} \\
\spec{cst}{double}{cosine of LAST} \\
\spec{cosys}{{\sc frametype}}{tracking frame ID} \\
\spec{usreqx}{double}{tracking frame equinox (mean \radec\ only) } \\
\spec{target}{double[2]}{target spherical coordinates, tracking frame }
}
\args{RETURNED \rm (arguments)}
{
\spec{spm1}{double[3][3]}{SPM \#1} \\
\spec{spm1\_i}{double[3][3]}{inverse of SPM \#1} \\
\spec{spm2}{double[3][3]}{SPM \#2} \\
\spec{spm2\_i}{double[3][3]}{inverse of SPM \#2}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $  0 = $ & OK \\
                        & $ -1 = $ & internal error (fatal) \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tcsTrack}{Generate Tracking Demands}
\label{tcsTrack}
\call{tcsTrack ( tara, tarb, spm1, frame, sst, cst, spm2, rotl, rotap, \\
 \hspace*{5.1em} ap, bp, xim, yim, ia, ib, np,
                 xt, yt, zt, ga, gb, rnogo, \\
 \hspace*{5.1em} \&xa, \&ya, \&za, \&enca1, \&encb1,
                 \&enca2, \&encb2, \&j ) }
\action{The main telescope tracking routine:  in a ``virtual telescope'',
        calculate the encoder demands required to image a given target
        at a specified place in the focal plane.

        The routine also returns the {\sc Aim} vector,
        needed for the rotator predictions.}
\args{GIVEN}
{
\spec{tara}{double}{target ``roll'' coordinate (Note 1)} \\
\spec{tarb}{double}{target ``pitch'' coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 3)} \\
\spec{sst}{double}{sine of sidereal time (Notes 2,3)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note 4)} \\
\spec{ap}{double}{predicted roll (Note 5)} \\
\spec{bp}{double}{predicted pitch (Note 5)} \\
\spec{xim}{double}{pointing origin $x$(in focal lengths)} \\
\spec{yim}{double}{pointing origin $y$(in focal lengths)} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 6)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 6)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 6)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{rnogo}{double}{radius of ``no go'' region (radians, Note 7)}
}
\args{RETURNED}
{
\spec{xa}{double*}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double*}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double*}{{\sc Aim} $z$-coordinate (Note 1)} \\
\spec{enca1}{double*}{roll coordinate, first solution (Note 8)} \\
\spec{encb1}{double*}{pitch coordinate, first solution (Note 8)} \\
\spec{enca2}{double*}{roll coordinate, second solution (Note 8)} \\
\spec{encb2}{double*}{pitch coordinate, second solution (Note 8)} \\
\spec{}{int*}{\hspace{-1.8ex}
              \begin{tabular}[t]{lrl}
                 status: & $ +1 = $ & pole avoidance (Note 9) \\
                         & $  0 = $ & OK                      \\
                         & $ -1 = $ & no solutions (Note 9)   \\
              \end{tabular}
             }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      specified sky target at the specified pointing-origin are
      calculated.  The {\sc Aim} vector, an intermediate result, is also
      returned, so that it can be used in a subsequent call to the
      {\tt tcsRotator} function.
\item The arguments {\tt sst} and {\tt cst}
      are the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The predicted rotator angle {\tt rotap} is the orientation that the
      mechanical rotator (whether at a coud\'e or Nasmyth focus, or
      mounted on the OTA) is expected to reach at the time for which
      the prediction is being made.  Note that it is the predicted
      achieved position, not a demand position.
\item The arguments {\tt ap} and {\tt bp} are an estimate of the coordinates
      {\tt a} and {\tt b} which are being computed.
      The results are not very
      sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Near the pole of the mounting ({\it i.e.}~the zenith in the case of an
      altazimuth) a variety of problems arises.  These include
      confusion about which way round to go, rivalry between the mount
      and rotator, and cases for which there are no solutions (see also
      Note 9).  In any event, there are limits to what speeds and
      accelerations the mechanical drives can achieve.  The present
      routine provides one strategy for avoiding difficulties in this
      region.

      The argument {\tt rnogo} specifies how close to the pole of the
      mounting the target is allowed to be.  If the target is too
      close, the routine aims instead for a fictitious target further
      out, on the edge of the forbidden region.  A warning status is
      set when this ``pole avoidance'' action is taken.

      It is permissible to set {\tt rnogo} to zero, and to handle any pole
      problems in the TCS application itself.  Two strategies that
      might be considered as an alternative to the {\tt rnogo} approach are
      (i)~progressive scaling back of certain of the pointing
      coefficients so that close to the pole the mount becomes
      nominally perfect, and (ii)~substituting a fictitious target that
      makes the telescope loiter on the edge of the awkward region
      until the real target catches up.
\item If the mount is an altazimuth, the roll coordinate is $\pi-$azimuth
      and the pitch coordinate is elevation.  If the mount is an
      equatorial, roll is $-h$ and pitch is $\delta$.  For any
      accessible target, there are two solutions; depending on the type
      of mount, the two solutions correspond to above/below the pole,
      nearside/farside of the zenith, east/west of the pier, and so on.
\item Near the pole of the mounting, especially when the collimation
      error or nonperpendicularity are large, there may be no mount
      posture that images the target at the desired place.  In these
      cases, the status {\tt j}
      is set to the ``no solutions'' value, and the
      returned roll and pitch are set to safe values.

      The ``no solution'' status overrides the ``pole avoidance'' status
      (see Note~7).
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsTrack\_c}{Track \xyz\ target}
\label{tcsTrack_c}
\call{tcsTrack\_c ( xtar, ytar, ztar, \\
      \hspace*{6em} spm1, frame, sst, cst, spm2, rotl, rotap, ap, bp, \\
      \hspace*{6em} xim, yim, ia, ib, np,
                    xt, yt, zt, ga, gb, rnogo, \\
      \hspace*{6em} \&xa, \&ya, \&za, \&enca1, \&encb1,
                    \&enca2, \&encb2, \&j ) }
\action{The main telescope tracking routine:  in a ``virtual telescope'',
        calculate the encoder demands required to image a given target
        at a specified place in the focal plane.  The target is specified
        in Cartesian form.

        The routine also returns the {\sc Aim} vector,
        needed for the rotator predictions.}
\args{GIVEN}
{
\spec{xtar}{double}{target $x$-coordinate (Notes 1,2)} \\
\spec{ytar}{double}{target $y$-coordinate (Notes 1,2)} \\
\spec{ztar}{double}{target $z$-coordinate (Notes 1,2)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 4)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 3,4)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 4)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note 4)} \\
\spec{ap}{double}{predicted roll (Note 6)} \\
\spec{bp}{double}{predicted pitch (Note 6)} \\
\spec{xim}{double}{pointing origin $x$(in focal lengths)} \\
\spec{yim}{double}{pointing origin $y$(in focal lengths)} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 7)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 7)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 7)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{rnogo}{double}{radius of ``no go'' region (radians, Note 8)}
}
\args{RETURNED}
{
\spec{xa}{double*}{{\sc Aim} $x$-coordinate (Note 1)} \\
\spec{ya}{double*}{{\sc Aim} $y$-coordinate (Note 1)} \\
\spec{za}{double*}{{\sc Aim} $z$-coordinate (Note 1)} \\
\spec{enca1}{double*}{roll coordinate, first solution (Note 9)} \\
\spec{encb1}{double*}{pitch coordinate, first solution (Note 9)} \\
\spec{enca2}{double*}{roll coordinate, second solution (Note 9)} \\
\spec{encb2}{double*}{pitch coordinate, second solution (Note 9)} \\
\spec{}{int*}{\hspace{-1.8ex}
              \begin{tabular}[t]{lrl}
                 status: & $ +1 = $ & pole nogo =avoidance (Note 10) \\
                         & $  0 = $ & OK                      \\
                         & $ -1 = $ & no solutions (Note 10)   \\
              \end{tabular}
             }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      specified sky target at the specified pointing-origin are
      calculated.  The {\sc Aim} vector, an intermediate result, is also
      returned, so that it can be used in a subsequent call to the
      {\tt tcsRotator} function.
\item The target vector is right-handed, so special care must be taken
      if using \azel, which is a left-handed system.  The procedure in
      this case is to perform the standard spherical-to-Cartesian
      transformation and then to reverse the sign of the $x$-coordinate.
\item The arguments {\tt sst} and {\tt cst}
      are the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The predicted rotator angle {\tt rotap} is the orientation that the
      mechanical rotator (whether at a coud\'e or Nasmyth focus, or
      mounted on the OTA) is expected to reach at the time for which
      the prediction is being made.  Note that it is the predicted
      achieved position, not a demand position.
\item The arguments {\tt ap} and {\tt bp} are an estimate of the coordinates
      {\tt a} and {\tt b} which are being computed.
      The results are not very
      sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Near the pole of the mounting ({\it i.e.}~the zenith in the case of an
      altazimuth) a variety of problems arises.  These include
      confusion about which way round to go, rivalry between the mount
      and rotator, and cases for which there are no solutions (see also
      Note 10).  In any event, there are limits to what speeds and
      accelerations the mechanical drives can achieve.  The present
      routine provides one strategy for avoiding difficulties in this
      region.

      The argument {\tt rnogo} specifies how close to the pole of the
      mounting the target is allowed to be.  If the target is too
      close, the routine aims instead for a fictitious target further
      out, on the edge of the forbidden region.  A warning status is
      set when this ``pole avoidance'' action is taken.

      It is permissible to set {\tt rnogo} to zero, and to handle any pole
      problems in the TCS application itself.  Two strategies that
      might be considered as an alternative to the {\tt rnogo} approach are
      (i)~progressive scaling back of certain of the pointing
      coefficients so that close to the pole the mount becomes
      nominally perfect, and (ii)~substituting a fictitious target that
      makes the telescope loiter on the edge of the awkward region
      until the real target catches up.
\item If the mount is an altazimuth, the roll coordinate is $\pi-$azimuth
      and the pitch coordinate is elevation.  If the mount is an
      equatorial, roll is $-h$ and pitch is $\delta$.  For any
      accessible target, there are two solutions; depending on the type
      of mount, the two solutions correspond to above/below the pole,
      nearside/farside of the zenith, east/west of the pier, and so on.
\item Near the pole of the mounting, especially when the collimation
      error or nonperpendicularity are large, there may be no mount
      posture that images the target at the desired place.  In these
      cases, the status {\tt j}
      is set to the ``no solutions'' value, and the
      returned roll and pitch are set to safe values.

      The ``no solution'' status overrides the ``pole avoidance'' status
      (see Note~8).
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTenc}{Solve VT for Encoder Settings}
\label{tcsVTenc}
\call{tcsVTenc ( tara, tarb, spm1, frame, sst, cst, spm2, rotl, rotap, \\
 \hspace*{5em} ap, bp, xim, yim, ia, ib, np,
               xt, yt, zt, ga, gb, rnogo, \\
 \hspace*{5em} \&enca1, \&encb1, \&enca2, \&encb2, \&j ) }
\action{In a ``virtual telescope'', for the
        specified target and pointing-origin
        generate the mount encoder demands.}
\args{GIVEN}
{
\spec{tara}{double}{target ``roll'' coordinate (Note 1)} \\
\spec{tarb}{double}{target ``pitch'' coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 3)} \\
\spec{sst}{double}{sine of sidereal time (Notes 2,3)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note 4)} \\
\spec{ap}{double}{predicted roll (Note 5)} \\
\spec{bp}{double}{predicted pitch (Note 5)} \\
\spec{xim}{double}{pointing origin $x$} \\
\spec{yim}{double}{pointing origin $y$} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 6)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 6)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 6)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{rnogo}{double}{radius of ``no go'' region (radians, Note 7)} \\
}
\args{RETURNED}
{
\spec{enca1}{double*}{roll, first solution (Note 8)} \\
\spec{encb1}{double*}{pitch, first solution (Note 8)} \\
\spec{enca2}{double*}{roll, second solution (Note 8)} \\
\spec{encb2}{double*}{pitch, second solution (Note 8)} \\
\spec{j}{int*}{\hspace{-1.8ex}
               \begin{tabular}[t]{lrl}
                  status: & $ +1 = $ & pole avoidance (Note 9) \\
                          & $  0 = $ & OK                      \\
                          & $ -1 = $ & no solutions (Note 9)   \\
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      specified sky target at the specified pointing-origin are
      calculated.
\item The arguments {\tt sst} and {\tt cst} are
      the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The predicted rotator angle {\tt rotap} is the expected position of
      the mechanical rotator (whether at a coud\'e or Nasmyth focus,
      or mounted on the OTA) at the time for which the prediction is
      being made.
\item The arguments {\tt ap} and {\tt bp}
      are an estimate of the coordinates
      {\tt a} and {\tt b} which are being computed.  The
      results are not very
      sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Near the pole of the mounting ({\it i.e.}~the zenith in the case of an
      altazimuth) a variety of problems arises.  These include
      confusion about which way round to go, rivalry between the mount
      and rotator, and cases for which there are no solutions (see also
      Note 9).  In any event, there are limits to what speeds and
      accelerations the mechanical drives can achieve.  The present
      routine provides one strategy for avoiding difficulties in this
      region.

      The argument {\tt rnogo} specifies how close to the pole of the
      mounting the target is allowed to be.  If the target is too
      close, the routine aims instead for a fictitious target further
      out, on the edge of the forbidden region.  A warning status is
      set when this ``pole avoidance'' action is taken.

      It is permissible to set {\tt rnogo} to zero, and to handle any pole
      problems in the TCS application itself.  Two strategies that
      might be considered as an alternative to the {\tt rnogo} approach are
      (i)~progressive scaling back of certain of the pointing
      coefficients so that close to the pole the mount becomes
      nominally perfect, and (ii)~substituting a fictitious target that
      makes the telescope loiter on the edge of the awkward region
      until the real target catches up.
\item If the mount is an altazimuth, {\tt a} is $\pi-$azimuth
      and {\tt b} is
      elevation.  If the mount is an equatorial, ais $-h$ and {\tt b} is
      declination.
\item Near the pole of the mounting, especially when the collimation
      error or nonperpendicularity are large, there may be no mount
      posture that images the target at the desired place.  In these
      cases, the status {\tt j} is set to the ``no solutions'' value, and the
      returned roll and pitch are set to safe values.

      The ``no solution'' status overrides the ``pole avoidance'' status
      (see Note~7).
\item This routine is optimized for speed, and accordingly no
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTenc\_c}{Target xyz \& P.O.\ to Encoders}
\label{tcsVTenc_c}
\call{tcsVTenc\_c ( xtar, ytar, ztar, \\
      \hspace*{6em} spm1, frame, sst, cst, spm2, rotl, rotap, ap, bp, \\
      \hspace*{6em} xim, yim, ia, ib, np,
                    xt, yt, zt, ga, gb, rnogo, \\
      \hspace*{6em} \&enca1, \&encb1, \&enca2, \&encb2, \&j ) }
\action{In a ``virtual telescope'', for the
        specified target and pointing-origin
        generate the mount encoder demands.  The target is
        specified in Cartesian form.}
\args{GIVEN}
{
\spec{xtar}{double}{target $x$-coordinate (Notes 1,2)} \\
\spec{ytar}{double}{target $y$-coordinate (Notes 1,2)} \\
\spec{ztar}{double}{target $z$-coordinate (Notes 1,2)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 4)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 3,4)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 4)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rotap}{double}{predicted rotator mechanical angle (Note 5)} \\
\spec{ap}{double}{predicted roll (Note 6)} \\
\spec{bp}{double}{predicted pitch (Note 6)} \\
\spec{xim}{double}{pointing origin $x$} \\
\spec{yim}{double}{pointing origin $y$} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 7)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 7)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 7)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch} \\
\spec{rnogo}{double}{radius of ``no go'' region (radians, Note 8)} \\
}
\args{RETURNED}
{
\spec{enca1}{double*}{roll, first solution (Note 9)} \\
\spec{encb1}{double*}{pitch, first solution (Note 9)} \\
\spec{enca2}{double*}{roll, second solution (Note 9)} \\
\spec{encb2}{double*}{pitch, second solution (Note 9)} \\
\spec{j}{int*}{\hspace{-1.8ex}
               \begin{tabular}[t]{lrl}
                  status: & $ +1 = $ & pole avoidance (Note 10) \\
                          & $  0 = $ & OK                       \\
                          & $ -1 = $ & no solutions (Note 10)   \\
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder demands required to image the
      specified sky target at the specified pointing-origin are
      calculated.
\item The target vector is right-handed, so special care must be taken
      if using \azel, which is a left-handed system.  The procedure in
      this case is to perform the standard spherical-to-Cartesian
      transformation and then to reverse the sign of the $x$-coordinate.
\item The arguments {\tt sst} and {\tt cst} are
      the sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The predicted rotator angle {\tt rotap} is the expected position of
      the mechanical rotator (whether at a coud\'e or Nasmyth focus,
      or mounted on the OTA) at the time for which the prediction is
      being made.
\item The arguments {\tt ap} and {\tt bp}
      are an estimate of the coordinates
      {\tt a} and {\tt b} which are being computed.  The
      results are not very
      sensitive to the values used.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item Near the pole of the mounting ({\it i.e.}~the zenith in the case of an
      altazimuth) a variety of problems arises.  These include
      confusion about which way round to go, rivalry between the mount
      and rotator, and cases for which there are no solutions (see also
      Note~10).  In any event, there are limits to what speeds and
      accelerations the mechanical drives can achieve.  The present
      routine provides one strategy for avoiding difficulties in this
      region.

      The argument {\tt rnogo} specifies how close to the pole of the
      mounting the target is allowed to be.  If the target is too
      close, the routine aims instead for a fictitious target further
      out, on the edge of the forbidden region.  A warning status is
      set when this ``pole avoidance'' action is taken.

      It is permissible to set {\tt rnogo} to zero, and to handle any pole
      problems in the TCS application itself.  Two strategies that
      might be considered as an alternative to the {\tt rnogo} approach are
      (i)~progressive scaling back of certain of the pointing
      coefficients so that close to the pole the mount becomes
      nominally perfect, and (ii)~substituting a fictitious target that
      makes the telescope loiter on the edge of the awkward region
      until the real target catches up.
\item If the mount is an altazimuth, {\tt a} is $\pi-$azimuth
      and {\tt b} is
      elevation.  If the mount is an equatorial, ais $-h$ and {\tt b} is
      declination.
\item Near the pole of the mounting, especially when the collimation
      error or nonperpendicularity are large, there may be no mount
      posture that images the target at the desired place.  In these
      cases, the status {\tt j} is set to the ``no solutions'' value, and the
      returned roll and pitch are set to safe values.

      The ``no solution'' status overrides the ``pole avoidance'' status
      (see Note~8).
\item This routine is optimized for speed, and accordingly no
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTsky}{Solve VT for Target}
\label{tcsVTsky}
\call{tcsVTsky ( enca, encb, rotl, rma, xpo, ypo, \\
 \hspace*{5em} spm1\_i, frame, sst, cst, spm2\_i, \\
 \hspace*{5em} ia, ib, np, xt, yt, zt, ga, gb, \&tara, \&tarb ) }
\action{In a ``virtual telescope'', calculate the target coordinates that
        correspond to the specified mount encoder demands and pointing-
        origin.}
\args{GIVEN}
{
\spec{enca}{double}{mount ``roll'' encoder demand (Notes 1,2)} \\
\spec{encb}{double}{mount ``pitch'' encoder demand (Notes 1,2)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{xpo}{double}{pointing-origin $x$-coordinate (in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$-coordinate (in focal lengths)} \\
\spec{spm1\_i}{double[3][3]}{inverse SPM \#1 (Note 4)} \\
\spec{frame}{{\sc frametype}}{reference frame for the results (Note 4)} \\
\spec{sst}{double}{sine of local apparent sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of local apparent sidereal time (Notes 3,4)} \\
\spec{spm2\_i}{double[3][3]}{inverse SPM \#2 (Note 4)} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 5)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 5)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 5)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{tara}{double*}{target ``roll'' coordinate (Note 2)} \\
\spec{tarb}{double*}{target ``pitch'' coordinate (Note 2)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the sky coordinates are predicted, starting
      from the mount's encoder readings.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, {\tt enca} is $\pi-$azimuth, {\tt encb} is
      elevation, {\tt tara} is right
      ascension and {\tt tarb} is $\delta$.  If the mount is an
      equatorial, {\tt enca} is $-h$ and {\tt encb} is
      $\delta$.  If the chosen
      frame is topocentric \azel, {\tt enca} is azimuth
      ({\it n.b.}~not pi-azimuth) and {\tt encb} is elevation.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1\_i}, {\tt sst}, {\tt cst} and
      {\tt spm2\_i} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \>  geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> topocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2\_i} \> topocentric \azel\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item This routine is optimized for speed, and accordingly no validation
      of the arguments is performed.  It is the caller's responsibility
      to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTsky\_c}{Encoders \& P.O.~to Target xyz}
\label{tcsVTsky_c}
\call{tcsVTsky\_c ( enca, encb, rotl, rma, xpo, ypo, \\
     \hspace*{6.1em} spm1\_i, frame, sst, cst, spm2\_i, \\
     \hspace*{6.1em} ia, ib, np, xt, yt, zt, ga, gb,
                     \&xs, \&ys, \&zs )}
\action{In a ``virtual telescope'', calculate the target coordinates that
        correspond to the specified mount encoder demands and
        pointing-origin.  The result is in Cartesian coordinates.}
\args{GIVEN}
{
\spec{enca}{double}{mount ``roll'' encoder demand (Notes 1,2) } \\
\spec{encb}{double}{mount ``pitch'' encoder demand (Notes 1,2)} \\
\spec{rotl}{\sc rotloc}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{xpo}{double}{pointing-origin $x$ (in focal lengths)} \\
\spec{ypo}{double}{pointing-origin $y$ (in focal lengths)} \\
\spec{spm1\_i}{double[3][3]}{inverse SPM \#1 (Note 4)} \\
\spec{frame}{\sc frametype}{reference frame for the results (Note 4)} \\
\spec{sst}{double}{sine of local apparent sidereal time (Notes 4,5)} \\
\spec{cst}{double}{cosine of local apparent sidereal time (Notes 4,5)} \\
\spec{spm2\_i}{double[3][3]}{inverse SPM \#2 (Note 4)} \\
\spec{ia}{double}{roll zero point (radians) } \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note 6)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note 6)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note 6)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED} {
\spec{xs}{double*}{target x coordinate (Note 2)} \\
\spec{ys}{double*}{target y coordinate (Note 2)} \\
\spec{zs}{double*}{target z coordinate (Note 2)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the encoder values and the pointing-origin \xy\
      coordinates are known, and the target position is to be
      determined.  The result is in Cartesian coordinates.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, {\tt enca} is $\pi-$azimuth, {\tt encb}
      is elevation, and {\tt xs,ys,zs}
      correspond to \radec.  If the mount is an equatorial, {\tt enca}
      is $-h$ and {\tt encb} is $\delta$.  If the chosen frame is
      topocentric \azel, {\tt xs,ys,zs} correspond to \azel.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1\_i}, {\tt sst}, {\tt cst} and
      {\tt spm2\_i} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \>  geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1\_i} \>
                 mean \radec\ $\Leftarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> geocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Leftarrow$ \hadec \\
         \> {\tt spm2\_i} \> topocentric \hadec\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1\_i} \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2\_i} \> topocentric \azel\ $\Leftarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The arguments {\tt sst} and {\tt cst} are the sine and
      cosine of the local apparent sidereal time.  Neither is used if
      the target frame is topocentric \azel.
\item This routine is optimized for speed, and accordingly no validation
      of the arguments is performed.  It is the caller's responsibility
      to supply sensible values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTxe}{Solve VT for \xieta}
\label{tcsVTxe}
\call{tcsVTxe ( tara, tarb, spm1, frame, sst, cst, spm2, enca, encb, \\
\hspace*{4.5em} ia, ib, np, xt, yt, zt, ga, gb, \&xiim, \&etaim, \&j ) }
\action{In a ``virtual telescope'', given the
        position of a target ({\it e.g.}~a
        guide-star), and knowing the telescope encoder settings, determine
        the \xieta\ coordinates of the image in the non-rotating focal
        plane.}
\args{GIVEN}
{
\spec{tara}{double}{target ``roll'' coordinate (Note 1)} \\
\spec{tarb}{double}{target ``pitch'' coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 3)} \\
\spec{sst}{double}{sine of sidereal time (Notes 2,3)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)} \\
\spec{enca}{double}{encoder roll coordinate} \\
\spec{encb}{double}{encoder pitch coordinate} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~4)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~4)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~4)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{xiim }{double*}{image $x$-coordinate (Note~5)} \\
\spec{etaim}{double*}{image $y$-coordinate (Note~5)} \\
\spec{j}{int*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & star cannot be imaged
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the pointing origin is determined, starting
      from the sky target coordinates and the encoder settings.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The image coordinates returned,
      {\tt xiim} and {\tt etaim}, are in the
      non-rotating focal plane and are in units of one focal length.
      The companion function {\tt tcsVTxy} is similar but returns \xy\
      coordinates in the rotating focal plane.
\item A common application for this routine is controlling a tip/tilt
      subreflector.
\item This routine is optimized for speed, and accordingly only minimal
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible and safe values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTxe\_c}{Solve VT for \xieta, xyz target}
\label{tcsVTxe_c}
\call{tcsVTxe\_c ( xtar, ytar, ztar, \\
\hspace*{5.5em} spm1, frame, sst, cst, spm2, enca, encb, \\
\hspace*{5.5em} ia, ib, np, xt, yt, zt, ga, gb, \&xiim, \&etaim, \&j ) }
\action{In a ``virtual telescope'', given the
        position of a target ({\it e.g.}~a
        guide-star), and knowing the telescope encoder settings, determine
        the \xieta\ coordinates of the image in the non-rotating focal
        plane.  The target is specified in Cartesian form.}
\args{GIVEN}
{
\spec{xtar}{double}{target $x$-coordinate (Notes 1,2)} \\
\spec{ytar}{double}{target $y$-coordinate (Notes 1,2)} \\
\spec{ztar}{double}{target $z$-coordinate (Notes 1,2)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 4)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 3,4)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 4)} \\
\spec{enca}{double}{encoder roll coordinate} \\
\spec{encb}{double}{encoder pitch coordinate} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~5)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~5)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~5)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{xiim }{double*}{image $x$-coordinate (Note~6)} \\
\spec{etaim}{double*}{image $y$-coordinate (Note~6)} \\
\spec{j}{int*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & star cannot be imaged
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the pointing origin is determined, starting
      from the sky target coordinates and the encoder settings.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, {\tt enca} is $\pi-$azimuth, {\tt encb}
      is elevation, and {\tt xs,ys,zs}
      correspond to \radec.  If the mount is an equatorial, {\tt enca}
      is $-h$ and {\tt encb} is $\delta$.  If the chosen frame is
      topocentric \azel, {\tt xs,ys,zs} correspond to \azel.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The image coordinates returned,
      {\tt xiim} and {\tt etaim}, are in the
      non-rotating focal plane and are in units of one focal length.
      The companion function {\tt tcsVTxy} is similar but returns \xy\
      coordinates in the rotating focal plane.
\item A common application for this routine is controlling a tip/tilt
      subreflector.
\item This routine is optimized for speed, and accordingly only minimal
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible and safe values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTxy}{Solve VT for \xy}
\label{tcsVTxy}
\call{tcsVTxy ( tara, tarb, spm1, frame, sst, cst, spm2, rotl, rma, \\
\hspace*{4.5em} enca, encb, ia, ib, np, xt, yt, zt, ga, gb, \\
\hspace*{4.5em} \&xim, \&yim, \&j ) }
\action{In a ``virtual telescope'', given the
        position of a target ({\it e.g.}~a
        guide-star), and knowing the telescope encoder settings, determine
        the position of the image in the focal plane.}
\args{GIVEN}
{
\spec{tara}{double}{target ``roll'' coordinate (Note 1)} \\
\spec{tarb}{double}{target ``pitch'' coordinate (Note 1)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 3)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 3)} \\
\spec{sst}{double}{sine of sidereal time (Notes 2,3)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 2,3)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 3)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{enca}{double}{encoder roll coordinate } \\
\spec{encb}{double}{encoder pitch coordinate} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~4)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~4)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~4)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{xim}{double*}{image $x$-coordinate (Note~6)} \\
\spec{yim}{double*}{image $y$-coordinate (Note~6)} \\
\spec{j}{int*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & star cannot be imaged
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the pointing origin is determined, starting
      from the sky target coordinates and the encoder settings.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The image coordinates returned,
       {\tt xim} and {\tt yim}, are in units of one
       focal length and are in the rotating focal plane.  The companion
       function {\tt tcsVTxe} is similar but returns
       \xieta\ coordinates in the
       non-rotating focal plane.
\item A common application for this routine is autoguiding.  The target
      is the guide star, and the encoder settings are those demanded by
      the normal tracking flow.  The pointing-origin generated by the
      present routine is the expected position of the guide star image.
      The autoguider determines the instantaneous discrepancy between
      the expected and measured image positions and, after appropriate
      filtering, feeds back the errors as guiding corrections
      {\tt [ga,gb]}.
\item This routine is optimized for speed, and accordingly only minimal
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible and safe values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsVTxy\_c}{Solve VT for \xy, xyz target}
\label{tcsVTxy_c}
\call{tcsVTxy\_c ( xtar, ytar, ztar, \\
\hspace*{5.5em} spm1, frame, sst, cst, spm2, rotl, rma, \\
\hspace*{5.5em} enca, encb, ia, ib, np, xt, yt, zt, ga, gb, \\
\hspace*{5.5em} \&xim, \&yim, \&j ) }
\action{In a ``virtual telescope'', given the
        position of a target ({\it e.g.}~a
        guide-star), and knowing the telescope encoder settings, determine
        the position of the image in the focal plane.
        The target is specified in Cartesian form.}
\args{GIVEN}
{
\spec{xtar}{double}{target $x$-coordinate (Notes 1,2)} \\
\spec{ytar}{double}{target $y$-coordinate (Notes 1,2)} \\
\spec{ztar}{double}{target $z$-coordinate (Notes 1,2)} \\
\spec{spm1}{double[3][3]}{SPM \#1 (Note 4)} \\
\spec{frame}{{\sc frametype}}{reference frame for the target (Note 4)} \\
\spec{sst}{double}{sine of sidereal time (Notes 3,4)} \\
\spec{cst}{double}{cosine of sidereal time (Notes 3,4)} \\
\spec{spm2}{double[3][3]}{SPM \#2 (Note 4)} \\
\spec{rotl}{{\sc rotloc}}{rotator location} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{enca}{double}{encoder roll coordinate } \\
\spec{encb}{double}{encoder pitch coordinate} \\
\spec{ia}{double}{roll zero point (radians)} \\
\spec{ib}{double}{pitch zero point (radians)} \\
\spec{np}{double}{mount axes nonperpendicularity (radians)} \\
\spec{xt}{double}{telescope vector, $x$-component (Note~5)} \\
\spec{yt}{double}{telescope vector, $y$-component (Note~5)} \\
\spec{zt}{double}{telescope vector, $z$-component (Note~5)} \\
\spec{ga}{double}{guiding correction, collimation} \\
\spec{gb}{double}{guiding correction, pitch}
}
\args{RETURNED}
{
\spec{xim}{double*}{image $x$-coordinate (Note~6)} \\
\spec{yim}{double*}{image $y$-coordinate (Note~6)} \\
\spec{j}{int*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  status: & $  0 = $ & OK \\
                          & $ \neq 0 = $ & star cannot be imaged
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A ``virtual telescope'' is a group of transformations that link
      three sets of coordinates:
      \begin{itemize}
      \item the target (where in the sky the source is);
      \item the pointing-origin (where in the focal plane the image
            appears);
      \item the mount encoder readings (that cause the image of the
            target to fall in the specified place in the focal plane).
      \end{itemize}
      The transformations are specified by various time-dependent
      rotation matrices, pointing corrections, functions of rotator
      angle and so on---see Figure~1, earlier.

      Given any two of the three sets of coordinates
      (sky, pointing-origin, mount), the missing coordinates
      can be deduced.  There is
      only one mount, and hence all the virtual telescopes must share
      the same encoder demands, namely those generated by the main
      ``mount tracking'' virtual telescope.  The remaining virtual
      telescopes implement such features as autoguiding and tip/tilt
      secondary optics, either by deducing the image position for a
      given target, or deducing the sky coordinates that correspond to
      a given place in the focal plane.

      In the present case, the pointing origin is determined, starting
      from the sky target coordinates and the encoder settings.
\item If the mount is an altazimuth and the chosen frame is an
      \radec, {\tt enca} is $\pi-$azimuth, {\tt encb}
      is elevation, and {\tt xs,ys,zs}
      correspond to \radec.  If the mount is an equatorial, {\tt enca}
      is $-h$ and {\tt encb} is $\delta$.  If the chosen frame is
      topocentric \azel, {\tt xs,ys,zs} correspond to \azel.
\item The arguments {\tt sst} and {\tt cst} are the
      sine and cosine of the local
      apparent sidereal time.  Neither is used if the target frame is
      topocentric \azel.
\item The way {\tt frame}, {\tt spm1}, {\tt sst}, {\tt cst} and
      {\tt spm2} are used depends on the type of target coordinates:
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK4} \\
         \> {\tt target } \> Bxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \>  geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt FK5} \\
         \> {\tt target } \> Jxxxx \radec, current date \\
         \> {\tt spm1   } \>
                 mean \radec\ $\Rightarrow$ geocentric apparent \radec \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT} \\
         \> {\tt target } \> geocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> geocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt APPT\_TOPO} \\
         \> {\tt target } \> topocentric apparent \radec \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> \radec\ $\Rightarrow$ \hadec \\
         \> {\tt spm2   } \> topocentric \hadec\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}
      \begin{tabbing}
         xxx \= xxxxxxxxxx \= \kill
         \> {\tt frame  } \> {\tt AZEL\_TOPO} \\
         \> {\tt target } \> topocentric \azel\ (N thru E) \\
         \> {\tt spm1   } \> identity matrix \\
         \> {\tt sst,cst} \> not used \\
         \> {\tt spm2   } \> topocentric \azel\ $\Rightarrow$ {\sc Aim}
      \end{tabbing}

      ICRS $\approx$ FK5 J2000 to better than 25 mas.
\item The {\sc Telescope} vector [{\tt xt,yt,zt}] is in this frame:
      \begin{quote}
      $x$-axis:  at right angles to both the roll and pitch axes \\
      $y$-axis:  along the pitch axis \\
      $z$-axis:  at right angles to the other two axes
      \end{quote}
      In the absence of either collimation error or vertical deflection
      the {\sc Telescope} vector is [1,0,0].
\item The image coordinates returned,
       {\tt xim} and {\tt yim}, are in units of one
       focal length and are in the rotating focal plane.  The companion
       function {\tt tcsVTxe} is similar but returns
       \xieta\ coordinates in the
       non-rotating focal plane.
\item A common application for this routine is autoguiding.  The target
      is the guide star, and the encoder settings are those demanded by
      the normal tracking flow.  The pointing-origin generated by the
      present routine is the expected position of the guide star image.
      The autoguider determines the instantaneous discrepancy between
      the expected and measured image positions and, after appropriate
      filtering, feeds back the errors as guiding corrections
      {\tt [ga,gb]}.
\item This routine is optimized for speed, and accordingly only minimal
      validation of the arguments is performed.  It is the caller's
      responsibility to supply sensible and safe values.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsXe2xy}{\xieta\ to \xy}
\label{tcsXe2xy}
\call{tcsXe2xy ( xi, eta, rotl, rma, a, b, \&x, \&y ) }
\action{Rotate non-rotating focal-plane coordinates
        \xieta\ into \xy\ rotator coordinates.}
\args{GIVEN}
{
\spec{xi}{double}{focal-plane $\xi$ coordinate (Note~1)} \\
\spec{eta}{double}{focal-plane $\eta$ coordinate (Note~1)} \\
\spec{rotl}{{\sc rotloc}}{rotator location (Note~2)} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{a}{double}{mount roll encoder reading (Note~3) } \\
\spec{b}{double}{mount pitch encoder reading (Note~3)}
}
\args{RETURNED}
{
\spec{x}{double*}{$x$ (in focal lengths)} \\
\spec{y}{double*}{$y$ (in focal lengths)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The focal-plane coordinates \xieta\ are fixed to the OTA structure
      and differ from \xy\ only in orientation ({\it i.e.}~not scale).

      The \xy\ coordinates are fixed to the rotator and are in units of
      1~focal length.

      In cases such as Cassegrain,
      where the rotator is mounted on the OTA,
      {\tt xi}~= {\tt x} and {\tt eta} = {\tt y}
      for {\tt rma}$ = 180^\circ$.
\item If an invalid rotator-location code is presented, the OTA case
      (Cassegrain {\it etc.}) is assumed.
\item If the rotator location is OTA
      (Cassegrain {\it etc.}), the [roll,pitch] angles
      are not used.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsXy2xe}{\xy\ to \xieta}
\label{tcsXy2xe}
\call{tcsXy2xe ( x, y, rotl, rma, a, b, \&xi, \&eta ) }
\action{Rotate \xy\ rotator coordinates into non-rotating focal-plane
        coordinates \xieta.}
\args{GIVEN}
{
\spec{x}{double}{$x$ (in focal lengths)} \\
\spec{y}{double}{$y$ (in focal lengths)} \\
\spec{rotl}{{\sc rotloc}}{rotator location (Note~2)} \\
\spec{rma}{double}{rotator mechanical angle} \\
\spec{a}{double}{mount roll encoder reading (Note~3)} \\
\spec{b}{double}{mount pitch encoder reading (Note~3)}
}
\args{RETURNED}
{
\spec{xi}{double*}{focal-plane {\tt xi} coordinate} \\
\spec{eta}{double*}{focal-plane {\tt eta} coordinate}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The \xy\ coordinates are fixed to the rotator and are in units of
      1~focal length.

      The focal-plane coordinates \xieta\ are fixed to the OTA structure
      and differ from \xy\ only in orientation ({\it i.e.}~not scale).

      In cases such as Cassegrain,
      where the rotator is mounted on the OTA,
      {\tt xi} = {\tt x} and {\tt eta} = {\tt y}
      for {\tt rma}$ = 180^\circ$.
\item If an invalid rotator-location code is presented, the OTA case
      (Cassegrain {\it etc.}) is assumed.
\item If the rotator location is OTA (Cassegrain {\it etc.}),
      the [roll,pitch] angles are not used.
\item The present function can be used for transforming
      $(\Delta x, \Delta y)$ signals from a
      rotator-mounted autoguider into guiding corrections (called
      {\tt ga} and {\tt gb} in routines such as {\tt tcsTrack}).
\end{enumerate}
}
%-----------------------------------------------------------------------

\newpage
\fi

\subsection{TPOINT Functions}

This section gives details of all the functions used by TCSpk that
are common with the TPOINT pointing-analysis application.

Note that it is not compulsory to use TPOINT routines as part of a
TCSpk-based telescope control application.  As long as the basic
7-term pointing model can be provided by the application, TCSpk will
do the rest.  The classic method, as used in all non-TCSpk systems,
amounts to fixing five of the seven TCSpk coefficients at zero while all of
the pointing corrections are expressed as roll and pitch index
errors ({\it i.e.}~zero-point corrections), the latter generated
by inline code.  Providing the pointing errors are small, this
method will prove satisfactory, at least for equatorials.  However,
the geometrical rigor that TCSpk offers will be missing, and accurate
control of rotator angle in altazimuth systems will be compromised.
A TPOINT-independent TCS application may, instead, choose to supply
the basic geometrical terms, so that all seven terms in the basic
model are used, but to manipulate only the the two index
errors when allowing for the changing corrections as the
telescope moves around the sky.  This will deliver most of the
rigor of the full TPOINT/TCSpk combination.

There are, however, obvious advantages to using the TPOINT routines
in a TCSpk-based application and the TPOINT package as the
pointing-analysis and modeling tool.  Not only is there no need to write
any code, but the tautological match between analysis and operations
ensures accurate and glitch-free results all over the sky.

As for the TCSpk functions themselves, all TPOINT functions are
re-entrant and everything is passed through argument lists.

\ifx\vdoc\vshort
\abridged
\else

%-----------------------------------------------------------------------
\routine{tptLength}{Useful Length of String}
\label{tptLength}
\call{length = tptLength ( string )}
\action{Return length of a string, excluding any trailing whitespace.}
\args{GIVEN}
{
\spec{string}{char[]}{the string}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{length excluding trailing spaces}
}
\anote{The minimum length returned is 0.}
%-----------------------------------------------------------------------
\routine{tptMinit}{Initialize the Pointing Model}
\label{tptMinit}
\call{tptMinit ( maxtrm, ntroom, \\
  \hspace*{5em} model, \&nterml, \&ntermx, \&nterms, coeffn )}
\action{Initialize the pointing model.}
\args{GIVEN}
{
\spec{maxtrm}{int}{maximum number of terms in model} \\
\spec{ntroom}{int}{maximum number of terms allowed for}
}
\args{RETURNED}
{
\spec{model}{int[]}{term numbers for current model (0 = end)} \\
\spec{nterml}{int*}{number of local terms} \\
\spec{ntermx}{int*}{number of terms implemented explicitly} \\
\spec{}{}{\hfill (local+standard)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{coefficient names (local, standard, generic)}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $ 0 = $ & OK \\
                        & $ -1 = $ & insufficient room for all terms \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tptPtappl}{Apply Pointing Adjustment}
\label{tptPtappl}
\call{status = tptPtappl ( atype, asize, sinphi, cosphi, mount, ae2nm, \\
            \hspace*{10em} jbp, method, vc, pmodel )}
\action{Apply the effect of one term in the pointing model.}
\args{GIVEN}
{
\spec{atype}{int}{the form of the adjustment (Note~1)} \\
\spec{asize}{double}{the size of the adjustment (radians)} \\
\spec{sinphi}{double}{sine of telescope latitude (Note~2)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~2)} \\
\spec{mount}{int}{mount type (Note~3)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~3)} \\
\spec{jbp}{int}{``below pole'' flag (Note~4)} \\
\spec{method}{int}{1 = add correction, else = subtract correction} \\
\spec{vc}{double[3]}{current \mhadec\ vector (Note~5)} \\
\spec{pmodel}{double[7]}{basic pointing model (Note~6)}
}
\args{RETURNED}
{
\spec{vc}{double[3]}{updated} \\
\spec{pmodel}{double[7]}{updated}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The argument {\tt atype} is a character that selects in what form the
      adjustment asize is to be applied: \\
   \vspace{0.4ex}
   \begin{quote}
   \begin{tabular}{cl}
     {\tt atype} & {\tt what is adjusted} \\ [0.5ex]
     {\tt 'H'} & hour angle \\
     {\tt 'X'} & east-west collimation \\
     {\tt 'D'} & declination \\
     {\tt 'U'} & polar axis up/down \\
     {\tt 'L'} & polar axis left/right \\
     {\tt 'P'} & HA/Dec nonperpendicularity \\
     {\tt 'A'} & azimuth \\
     {\tt 'S'} & left-right collimation \\
     {\tt 'Z'} & zenith distance (sky) \\
     {\tt 'E'} & elevation (mount) \\
     {\tt 'N'} & azimuth axis north/south \\
     {\tt 'W'} & azimuth axis east/west \\
     {\tt 'V'} & Az/El nonperpendicularity \\
   \end{tabular}
   \end{quote}
   \vspace{1ex}
      For a generalized gimbal mount, ``azimuth'' and ``elevation''
      mean mount ``roll'' and ``pitch'' respectively.  Zenith distance
      always means with respect to the zenith, not with respect to
      the mount pole.
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
\item The {\tt jbp} flag specifies what state the mount is in:
      \begin{itemize}
      \item If {\tt jbp}\,=\,0, the mount is in the normal state
            where the mechanical declination or elevation is in the
            range $\pm90^\circ$.
      \item If {\tt jbp}\,=\,1, the mount is in the other state,
            where the mechanical
            declination or elevation is outside the range $\pm90^\circ$
            and the mechanical hour angle or azimuth is $180^\circ$
            away from the corresponding celestial value.  This state is
            variously called ``below the pole'', ``other side of the pier'',
            ``beyond the zenith'' {\it etc.}
      \end{itemize}
\item The {\tt vc} \mhadec\ vector is the direction to which the
      correction is being applied.
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
      This 7-term basic model thus combines the contributions from all
      the terms in the actual, operational, model.  The recipient, for
      example a telescope control system, need implement only this
      7-term model (once and for all, efficiently and with proper
      handling of awkward cases) in order to correct for all the terms
      in whatever operational model is in use at the time.  Note also
      that the present routine need be invoked only occasionally, to
      to keep track of the effects of the changing telescope position.
      Between updates, the 7-term model will be an adequate summary of
      the operational model for the current region of sky.
\item This routine includes no non-standard header files and is suitable for
      use in applications other than the TPOINT pointing-analysis
      application itself, for example a telescope control system.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptPterm}{Apply Term to Observation}
\label{tptPterm}
\call{status = tptPterm ( nterm, cval, auxil, jbp, vw, sinphi, cosphi, \\
                  \hspace*{9.5em} mount, ae2nm, \&nterml, \&ntermx, \&nterms, \\
                  \hspace*{9.5em} coeffn, coform, method, vc, pmodel )}
\action{Evaluate the effect of one term in the pointing model
        at one position.}
\args{GIVEN}
{
\spec{nterm}{int}{coefficient number (1\ldots, Note~1)} \\
\spec{cval}{double}{coefficient value (radians)} \\
\spec{auxil}{double[3]}{auxiliary readings if any} \\
\spec{jbp}{int}{``below pole'' flag} \\
\spec{vw}{double[3]}{working \mhadec\ vector for calculations} \\
\spec{sinphi}{double}{sine of telescope latitude (Note~2)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~2)} \\
\spec{mount}{int}{mount type (Note~3)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~3)} \\
\spec{nterml}{int*}{number of local terms} \\
\spec{ntermx}{int*}{number of terms implemented explicitly} \\
\spec{}{}{\hfill(local+standard)} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{}{}{\hfill (local+standard+generic)} \\
\spec{coeffn}{char[][9]}{coefficient names} \\
\spec{coform}{char[][9]}{tokenized form of generic term names} \\
\spec{method}{int}{1 = add correction, else = subtract correction} \\
\spec{vc}{double[3]}{current \mhadec\ vector (Note~4)} \\
\spec{pmodel}{double[7]}{basic pointing model (Note~5)}
}
\args{RETURNED}
{
\spec{vc}{double[3]}{updated} \\
\spec{pmodel}{double[7]}{updated}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK (Note~7)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item It is up to the caller to make sure that {\tt nterm} is within the
      range 1 through {\tt nterms}.  If it is not, no adjustment is made
      and an error status is returned.
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
\item The {\tt vc} \mhadec\ vector is the direction to which the
      correction is being applied.
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
      This 7-term basic model thus combines the contributions from all
      the terms in the actual, operational, model.  The recipient, for
      example a telescope control system, need implement only this
      7-term model (once and for all, efficiently and with proper
      handling of awkward cases) in order to correct for all the terms
      in whatever operational model is in use at the time.  Note also
      that the present routine need be invoked only occasionally, to
      to keep track of the effects of the changing telescope position.
      Between updates, the 7-term model will be an adequate summary of
      the operational model for the current region of sky.
\item The corrections are computed in the routines {\tt tptPterml}
      (locally implemented terms), {\tt tptPterms} (standard terms)
      and {\tt tptPtermg} (generic terms).  These routines, like the
      present one, avoid use of {\tt \#include}s, to facilitate their
      use in other contexts, for example as part of a telescope
      control system.
\item The function value returned is the status from
      {\tt tptPterml}, or
      {\tt tptPterms}, or
      {\tt tptPtermg}, whichever is called.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptPtermg}{Apply Generic Term}
\label{tptPtermg}
\call{status = tptPtermg ( cname, coform, cval, auxil, sinphi, cosphi, \\
            \hspace*{10em} mount, ae2nm, jbp, method, vw, vc, pmodel )}
\action{Compute the effect of one {\bf generic}
        term in the pointing model.}
\args{GIVEN}
{
\spec{cname}{char[]}{name of generic term (Note~1)} \\
\spec{coform}{char[]}{format of generic term (supplied by {\tt tptTerm})} \\
\spec{cval}{double}{coefficient value (radians)} \\
\spec{auxil}{double[3]}{auxiliary readings if any} \\
\spec{sinphi}{double}{sine of telescope latitude (Note~2)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~2)} \\
\spec{mount}{int}{mount type (Note~3)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~3)} \\
\spec{jbp}{int}{``below pole'' flag (Note~4)} \\
\spec{method}{int}{1 = add correction, else = subtract correction} \\
\spec{vw}{double[3]}{working \mhadec\ vector for calculations (Note~5)} \\
\spec{vc}{double[3]}{current \mhadec\ vector (Note~5)} \\
\spec{pmodel}{double[7]}{basic pointing model (Note~6)} \\
}
\args{RETURNED}
{
\spec{vc}{double[3]}{updated} \\
\spec{pmodel}{double[7]}{updated}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item It is up to the caller to make sure that the term name
      {\tt cname} is valid.  If it is not, no adjustment is made
      and an error status is returned.
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
\item The {\tt jbp} flag specifies what state the mount is in:
      \begin{itemize}
      \item If {\tt jbp}\,=\,0, the mount is in the normal state
            where the mechanical declination or elevation is in the
            range $\pm90^\circ$.
      \item If {\tt jbp}\,=\,1, the mount is in the other state,
            where the mechanical
            declination or elevation is outside the range $\pm90^\circ$
            and the mechanical hour angle or azimuth is $180^\circ$
            away from the corresponding celestial value.  This state is
            variously called ``below the pole'', ``other side of the pier'',
            ``beyond the zenith'' {\it etc.}
      \end{itemize}
\item The {\tt vw} \mhadec\ vector is the direction used to calculate the
      correction.
      The {\tt vc} \mhadec\ vector is the direction to which the correction
      is being applied.
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
      This 7-term basic model thus combines the contributions from all
      the terms in the actual, operational, model.  The recipient, for
      example a telescope control system, need implement only this
      7-term model (once and for all, efficiently and with proper
      handling of awkward cases) in order to correct for all the terms
      in whatever operational model is in use at the time.  Note also
      that the present routine need be invoked only occasionally, to
      to keep track of the effects of the changing telescope position.
      Between updates, the 7-term model will be an adequate summary of
      the operational model for the current region of sky.
\item The purpose of this routine is to compute the effect of
      one generic pointing term at the current position.

      To simplify the coding of the different terms, the routine makes
      a preliminary call to the {\tt tptPtpre} function in order to
      make the telescope position in four different systems:
      \begin{quote}
      \begin{tabular}{l}
      spherical HA/Dec \\
      Cartesian $-$HA/Dec \\
      spherical Az/El \\
      Cartesian Az/El \\
      \end{tabular}
      \end{quote}
      The correction for each term is implemented by making one (or at
      most two) calls to the tptPtappl function.
\item The following sign conventions are used:
      \begin{itemize}
      \item Azimuth: zero for due south, and $90^\circ$ for due east.
            (Beware!  This is not the surveyor's convention, and also
            differs from the convention TPOINT uses for all of its
            external interfaces.)
      \item Mount elevation: the horizon is elevation zero, and the
            zenith is elevation $90^\circ$.
      \item HA and EW corrections: positive when the corrected
            telescope position is west of the uncorrected position.
      \item Dec corrections: positive when the corrected telescope
            position is north of the uncorrected position.
      \item Azimuth and LR corrections: positive when the
            corrected telescope position is to the left of the
            uncorrected position as seen by someone standing at
            the telescope looking at the sky.
      \item Zenith distance corrections: positive when the corrected
            telescope position is below the uncorrected position.
      \item Elevation corrections: positive when the corrected
            telescope position is above the uncorrected position.
      \end{itemize}
      The terms are reversed in sign when adjusting star positions
      to fit telescope positions, so that the coefficients stay
      unchanged in sign whichever of the two options (star adjusted
      to fit telescope, or telescope adjusted to fit star) is
      being used.
\item This routine is designed to be usable in other applications,
      with or without local enhancements.  It is self-contained, with
      all information exchanged through the argument list;  no
      non-standard header files are included.
\item The effects of, respectively, {\bf standard}
      and {\bf locally implemented} terms are computed
      in the functions {\tt tptPterms} and {\tt tptPterml}.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptPterml}{Apply a Local Term}
\label{tptPterml}
\call{status = tptPterml ( nterm, cval, auxil, sinphi, cosphi, \\
            \hspace*{10em} mount, ae2nm, jbp, method, vw, vc, pmodel )}
\action{Compute the effect of one {\bf locally implemented}
        term in the pointing model.}
\args{GIVEN}
{
\spec{nterm}{int}{coefficient number within local set (Note~1)} \\
\spec{cval}{double}{coefficient value (radians)} \\
\spec{auxil}{double[3]}{auxiliary readings if any} \\
\spec{sinphi}{double}{sine of telescope latitude (Note~2)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~2)} \\
\spec{mount}{int}{mount type (Note~3)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~3)} \\
\spec{jbp}{int}{``below pole'' flag (Note~4)} \\
\spec{method}{int}{1 = add correction, else = subtract correction} \\
\spec{vw}{double[3]}{working \mhadec\ vector for calculations (Note~5)} \\
\spec{vc}{double[3]}{current \mhadec\ vector (Note~5)} \\
\spec{pmodel}{double[7]}{basic pointing model (Note~6)} \\
}
\args{RETURNED}
{
\spec{vc}{double[3]}{updated} \\
\spec{pmodel}{double[7]}{updated}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item Changes in the present routine must be coordinated with changes
      in the function {\tt tptTrmloc}.  The implementation of {\tt tptPterml}
      supplied with the TPOINT package is an example program which
      is never called (because the supplied {\tt tptTrmloc} doesn't
      define any term names).
      It is up to the caller to make sure that {\tt nterm} is within the
      correct range, {\it i.e.}\/ 1 to the number of local terms
      implemented.  If it is not, no adjustment is made
      and an error status is returned.
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
\item The {\tt jbp} flag specifies what state the mount is in:
      \begin{itemize}
      \item If {\tt jbp}\,=\,0, the mount is in the normal state
            where the mechanical declination or elevation is in the
            range $\pm90^\circ$.
      \item If {\tt jbp}\,=\,1, the mount is in the other state,
            where the mechanical
            declination or elevation is outside the range $\pm90^\circ$
            and the mechanical hour angle or azimuth is $180^\circ$
            away from the corresponding celestial value.  This state is
            variously called ``below the pole'', ``other side of the pier'',
            ``beyond the zenith'' {\it etc.}
      \end{itemize}
\item The {\tt vw} \mhadec\ vector is the direction used to calculate the
      correction.
      The {\tt vc} \mhadec\ vector is the direction to which the correction
      is being applied.
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
      This 7-term basic model thus combines the contributions from all
      the terms in the actual, operational, model.  The recipient, for
      example a telescope control system, need implement only this
      7-term model (once and for all, efficiently and with proper
      handling of awkward cases) in order to correct for all the terms
      in whatever operational model is in use at the time.  Note also
      that the present routine need be invoked only occasionally, to
      to keep track of the effects of the changing telescope position.
      Between updates, the 7-term model will be an adequate summary of
      the operational model for the current region of sky.
\item The purpose of this routine is to compute the effect of
      one local pointing term at the current position.

      To simplify the coding of the different terms, the routine makes
      a preliminary call to the {\tt tptPtpre} function in order to
      make the telescope position in four different systems:
      \begin{quote}
      \begin{tabular}{l}
      spherical HA/Dec \\
      Cartesian $-$HA/Dec \\
      spherical Az/El \\
      Cartesian Az/El \\
      \end{tabular}
      \end{quote}
      The correction for each term is implemented by making one (or at
      most two) calls to the tptPtappl function.
\item The following sign conventions are used:
      \begin{itemize}
      \item Azimuth: zero for due south, and $90^\circ$ for due east.
            (Beware!  This is not the surveyor's convention, and also
            differs from the convention TPOINT uses for all of its
            external interfaces.)
      \item Mount elevation: the horizon is elevation zero, and the
            zenith is elevation $90^\circ$.
      \item HA and EW corrections: positive when the corrected
            telescope position is west of the uncorrected position.
      \item Dec corrections: positive when the corrected telescope
            position is north of the uncorrected position.
      \item Azimuth and LR corrections: positive when the
            corrected telescope position is to the left of the
            uncorrected position as seen by someone standing at
            the telescope looking at the sky.
      \item Zenith distance corrections: positive when the corrected
            telescope position is below the uncorrected position.
      \item Elevation corrections: positive when the corrected
            telescope position is above the uncorrected position.
      \end{itemize}
      The terms are reversed in sign when adjusting star positions
      to fit telescope positions, so that the coefficients stay
      unchanged in sign whichever of the two options (star adjusted
      to fit telescope, or telescope adjusted to fit star) is
      being used.
\item This routine is analogous to the {\tt tptPterms} routine, but is
      intended for the implementation of local terms.  It has an
      identical argument list, through which everything passes, and
      includes no non-standard header files.
\item The effects of, respectively, {\bf standard} and {\bf generic}
      terms are computed in the functions {\tt tptPterms} and
      {\tt tptPtermg}.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptPterms}{Apply a Standard Term}
\label{tptPterms}
\call{status = tptPterms ( nterm, cval, auxil, sinphi, cosphi, \\
            \hspace*{10em} mount, ae2nm, jbp, method, vw, vc, pmodel )}
\action{Compute the effect of one {\bf standard}
        term in the pointing model.}
\args{GIVEN}
{
\spec{nterm}{int}{coefficient number (within standard set: Note~1)} \\
\spec{cval}{double}{coefficient value (radians)} \\
\spec{auxil}{double[3]}{auxiliary readings if any} \\
\spec{sinphi}{double}{sine of telescope latitude (Note~2)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~2)} \\
\spec{mount}{int}{mount type (Note~3)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~3)} \\
\spec{jbp}{int}{``below pole'' flag (Note~4)} \\
\spec{method}{int}{1 = add correction, else = subtract correction} \\
\spec{vw}{double[3]}{working \mhadec\ vector for calculations (Note~5)} \\
\spec{vc}{double[3]}{current \mhadec\ vector (Note~5)} \\
\spec{pmodel}{double[7]}{basic pointing model (Note~6)} \\
}
\args{RETURNED}
{
\spec{vc}{double[3]}{updated} \\
\spec{pmodel}{double[7]}{updated}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item Changes in the present routine must be coordinated with changes
      in the function {\tt tptTrmstd}.
      It is up to the caller to make sure that {\tt nterm} is within the
      allowed range, {\it i.e.}\/ 1 to the number of standard terms
      implemented.  If it is not, no adjustment is made and an error
      status is returned.
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
\item The {\tt jbp} flag specifies what state the mount is in:
      \begin{itemize}
      \item If {\tt jbp}\,=\,0, the mount is in the normal state
            where the mechanical declination or elevation is in the
            range $\pm90^\circ$.
      \item If {\tt jbp}\,=\,1, the mount is in the other state,
            where the mechanical
            declination or elevation is outside the range $\pm90^\circ$
            and the mechanical hour angle or azimuth is $180^\circ$
            away from the corresponding celestial value.  This state is
            variously called ``below the pole'', ``other side of the pier'',
            ``beyond the zenith'' {\it etc.}
      \end{itemize}
\item The {\tt vw} \mhadec\ vector is the direction used to calculate the
      correction.
      The {\tt vc} \mhadec\ vector is the direction to which the correction
      is being applied.
\item The array {\tt pmodel} is a list of seven pointing coefficients
      which comprise a basic pointing model:
      \begin{quote}
      \begin{tabular}{cccc}
      & & \multicolumn{2}{c}{\it term name} \\
      {\it element} & {\it meaning} & {\it equatorial} & {\it other} \\[1ex]
      {\tt [0,1]} & index errors & $-$IH,$+$ID & $+$IA,$+$IE \\
      {\tt [2]} & vertical error & $+$FLOP & $+$FLOP \\
      {\tt [3]} & collimation error & $-$CH & $+$CA \\
      {\tt [4]} & nonperpendicularity & $-$NP & $+$NPAE \\
      {\tt [5,6]} & misalignment & $+$MA,$+$ME & $+$AW,$+$AN \\
      \end{tabular}
      \end{quote}
      This 7-term basic model thus combines the contributions from all
      the terms in the actual, operational, model.  The recipient, for
      example a telescope control system, need implement only this
      7-term model (once and for all, efficiently and with proper
      handling of awkward cases) in order to correct for all the terms
      in whatever operational model is in use at the time.  Note also
      that the present routine need be invoked only occasionally, to
      to keep track of the effects of the changing telescope position.
      Between updates, the 7-term model will be an adequate summary of
      the operational model for the current region of sky.
\item The purpose of this routine is to compute the effect of
      one local pointing term at the current position.

      To simplify the coding of the different terms, the routine makes
      a preliminary call to the {\tt tptPtpre} function in order to
      make the telescope position in four different systems:
      \begin{quote}
      \begin{tabular}{l}
      spherical HA/Dec \\
      Cartesian $-$HA/Dec \\
      spherical Az/El \\
      Cartesian Az/El \\
      \end{tabular}
      \end{quote}
      The correction for each term is implemented by making one (or at
      most two) calls to the tptPtappl function.
\item The following sign conventions are used:
      \begin{itemize}
      \item Azimuth: zero for due south, and $90^\circ$ for due east.
            (Beware!  This is not the surveyor's convention, and also
            differs from the convention TPOINT uses for all of its
            external interfaces.)
      \item Mount elevation: the horizon is elevation zero, and the
            zenith is elevation $90^\circ$.
      \item HA and EW corrections: positive when the corrected
            telescope position is west of the uncorrected position.
      \item Dec corrections: positive when the corrected telescope
            position is north of the uncorrected position.
      \item Azimuth and LR corrections: positive when the
            corrected telescope position is to the left of the
            uncorrected position as seen by someone standing at
            the telescope looking at the sky.
      \item Zenith distance corrections: positive when the corrected
            telescope position is below the uncorrected position.
      \item Elevation corrections: positive when the corrected
            telescope position is above the uncorrected position.
      \end{itemize}
      The terms are reversed in sign when adjusting star positions
      to fit telescope positions, so that the coefficients stay
      unchanged in sign whichever of the two options (star adjusted
      to fit telescope, or telescope adjusted to fit star) is
      being used.
\item This routine is designed to be usable in other applications,
      with or without local enhancements.  It is self-contained, with
      all information exchanged through the argument list;  no
      non-standard header files are included.
\item The effects of, respectively, {\bf locally implemented}
      and {\bf generic}
      terms are computed in the functions {\tt tptPterml} and
      {\tt tptPtermg}.
\item The present routine serves as a template for the {\tt tptPterml}
      routine, used for implementing locally-defined pointing terms.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptPtpre}{Prepare to Evaluate Term}
\label{tptPtpre}
\call{status = tptPtpre ( sinphi, cosphi, mount, ae2nm, jbp, vw, \\
                  \hspace*{9.5em} xa, ya, za, az, el, zd,
                                  xe, ye, ze, ha, dec )}
\action{As a preliminary to evaluating a pointing term, transform the
        working vector into various useful forms.}
\args{GIVEN}
{
\spec{a}{double[3][3]}{A}
}
\args{GIVEN}
{
\spec{sinphi}{double}{sine of telescope latitude (Note~1)} \\
\spec{cosphi}{double}{cosine of telescope latitude (Note~1)} \\
\spec{mount}{int}{mount type (Note~2)} \\
\spec{ae2nm}{double[3][3]}{Az/El to nominal mount matrix (Note~2)} \\
\spec{jbp}{int}{``below pole'' flag (Note~3)} \\
\spec{vw}{double[3]}{\mhadec\ vector for calculations (Note~4)}
}
\args{RETURNED}
{
\spec{xa}{double*}{\azel\ direction cosine $x$} \\
\spec{ya}{double*}{\azel\ direction cosine $y$} \\
\spec{za}{double*}{\azel\ direction cosine $z$} \\
\spec{az}{double*}{mount azimuth (radians, S\,=\,0, E\,=\,90; Note~2)} \\
\spec{el}{double*}{mount elevation (radians; Note~2)} \\
\spec{zd}{double*}{zenith distance (radians)} \\
\spec{xe}{double*}{\mhadec\ direction cosine $x$} \\
\spec{ye}{double*}{\mhadec\ direction cosine $y$} \\
\spec{ze}{double*}{\mhadec\ direction cosine $z$} \\
\spec{ha}{double*}{hour angle (radians)} \\
\spec{dec}{double*}{declination (radians)}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The functions of latitude, {\tt sinphi} and {\tt cosphi}, are used as
      supplied, without checks for range and consistency.
\item The {\tt mount} argument specifies the type of mount:
      \begin{itemize}
      \item If {\tt mount}\,=\,1, the mount is an equatorial and the
            basic model is $-$IH, ID, FLOP, TF, $-$CH, $-$NP, MA, ME.
      \item If {\tt mount}\,=\,2, the mount is an altazimuth and the
            basic model is IA, IE, FLOP, TF, CA, NPAE, AW, AN.
      \item If {\tt mount}\,=\,3, the mount is a generalized gimbal
            and the basic model is
            IA, IE, FLOP, TF, CA, NPAE, AW, AN.  In this case, all
            the terms except FLOP are in the mount's nominal frame,
            as given by the matrix {\tt ae2nm}.
      \end{itemize}
      For a generalized gimbal mount, the arguments {\tt az} and {\tt el}
      receive the mount ``roll'' and ``pitch'' rather than the true
      azimuth and elevation.  The {\tt zd} argument is always the true
      zenith distance.
\item The {\tt jbp} flag specifies what state the mount is in:
      \begin{itemize}
      \item If {\tt jbp}\,=\,0, the mount is in the normal state
            where the mechanical declination or elevation is in the
            range $\pm90^\circ$.
      \item If {\tt jbp}\,=\,1, the mount is in the other state,
            where the mechanical
            declination or elevation is outside the range $\pm90^\circ$
            and the mechanical hour angle or azimuth is $180^\circ$
            away from the corresponding celestial value.  This state is
            variously called ``below the pole'', ``other side of the pier'',
            ``beyond the zenith'' {\it etc.}  In this case,
            the spherical coordinates are
            suitably transformed to represent the ``mechanical'' coordinates,
            the declination or elevation being outside the range $\pm \pi /2$
            in such cases.
      \end{itemize}
\item The {\tt vw} \mhadec\ vector is the direction used to calculate the
      correction.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptScomp}{Compare Strings}
\label{tptScomp}
\call{diff = tptScomp ( string1, string2 )}
\action{Compare two strings, ignoring trailing whitespace.}
\args{GIVEN}
{
\spec{string1}{char[]}{first string} \\
\spec{string2}{char[]}{second string}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\parbox[t]{23em}{$0=$ strings are the same, \\
                              \hspace*{2em}apart from any trailing whitespace}}
}
%-----------------------------------------------------------------------
\routine{tptTerm}{Translate Term Name to Number}
\label{tptTerm}
\call{number = tptTerm ( name, ntroom, \&nterms, coeffn, coform )}
\action{Translate a term name into the corresponding term number.  If
        the term is a generic one that has not previously been referred
        to, it is added to the current repertoire ready for if and when
        it is needed.}
\args{GIVEN}
{
\spec{name}{char[]}{name of term} \\
\spec{ntroom}{int}{maximum number of terms allowed for} \\
\spec{nterms}{int*}{number of terms available currently} \\
\spec{coeffn}{char[][9]}{coefficient names (local, standard, generic)}
}
\args{RETURNED}
{
\spec{nterms}{int*}{updated} \\
\spec{coeffn}{char[][9]}{updated} \\
\spec{coform}{char[]}{format of generic term added to {\tt coeffn}}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{\hspace{-1.8ex}
             \begin{tabular}[t]{lrl}
                status: & $ -1 = $ & unrecognized term \\
                        & $  0 = $ & no room for new generic term \\
                        & $ >0 = $ & term number (1\ldots ) \\
             \end{tabular}
            }
}
%-----------------------------------------------------------------------
\routine{tptTrmgen}{Check for Generic Term Name}
\label{tptTrmgen}
\call{format = tptTrmgen ( name )}
\action{Check a generic term name for validity and return a pointer
        to a string which identifies the format.}
\args{GIVEN}
{
\spec{name}{char[]}{name of term}
}
\args{RETURNED \rm (function value)}
{
\spec{}{char*}{\hspace{-2ex}
               \begin{tabular}[t]{lrl}
                  format: & NULL = & not a valid generic term name \\
                          & else = & pointer to format string \\
               \end{tabular}
              }
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item There are three types of generic term, called P, H and A respectively:
      \begin{itemize}
      \item P terms (polynomials) apply adjustments
            to a ``result'' coordinate
            which are proportional to the product
            of two ``input'' coordinates
            each raised to an integer power greater
            than or equal to zero.
      \item H terms (harmonics) apply adjustments
            to a ``result'' coordinate
            which are proportional to the product
            of sines or cosines of two
            ``input'' coordinates.
      \item A terms (auxiliaries) apply adjustments
            to a ``result'' coordinate
            which are proportional to an auxiliary reading.
      \end{itemize}
      A valid generic term name is one of the following:
      \begin{quote}
      {\tt \begin{tabular}{l}
           Prc[i[c[i]]] \\
           Hrfc[i][fc[i]] \\
           Hrfci[i[i]] \\
           Hrfcfcii \\
           Hrfciifc \\
           Anr \\
           \end{tabular}}
      \end{quote}
      where:
      \begin{quote}
        {\tt P} = the character {\tt 'P'} \\
        {\tt H} = the character {\tt 'H'} \\
        {\tt A} = the character {\tt 'A'} \\
        {\tt r} = a single-letter code specifying the ``result'' coordinate:
        \begin{quote}
        \begin{tabular}{cl}
          {\tt H} & result is in hour angle \\
          {\tt X} & result is east-west on the sky \\
          {\tt D} & result is in declination \\
          {\tt U} & result moves polar axis up/down \\
          {\tt L} & result moves polar axis left/right \\
          {\tt P} & result changes HA/Dec nonperpendicularity \\
          {\tt A} & result is in azimuth \\
          {\tt S} & result is left-right on the sky \\
          {\tt Z} & result is in zenith distance (sky) \\
          {\tt E} & result is in elevation (mount) \\
          {\tt N} & result moves azimuth axis north/south \\
          {\tt W} & result moves azimuth axis east/west \\
          {\tt V} & result changes Az/El nonperpendicularity \\
        \end{tabular}
        \end{quote}
        {\tt c} = a single-letter code specifying an ``input'' coordinate:
        \begin{quote}
        \begin{tabular}{cl}
          {\tt H} & hour angle \\
          {\tt D} & declination \\
          {\tt A} & azimuth \\
          {\tt Z} & zenith distance \\
          {\tt Q} & parallactic angle \\
        \end{tabular}
        \end{quote}
        {\tt i} = a decimal digit 0--9 \\
        {\tt f} = function: {\tt 'S'} for sine or {\tt 'C'} for cosine \\
        {\tt n} = a decimal digit 1--3
      \end{quote}
      A missing {\tt i}, {\tt ci} or {\tt fci} defaults to unity.

      Examples of valid generic term names:
        \begin{quote}
        \begin{tabular}{ll}
        {\tt PDH} & = HA adjustment to Dec \\
        {\tt PZZ2} & = ZD2 adjustment to ZD \\
        {\tt PXH3D2} & = (HA3)*(DEC2) adjustment east-west \\
        {\tt HHSH} & = sin(HA) adjustment to HA \\
        {\tt HACA12} & = cos(12*AZ) adjustment to Az \\
        {\tt HZSA3} & = sin(3*AZ) adjustment to ZD \\
        {\tt HDSH2CD7} & = sin(2*HA)*cos(7*DEC) adjustment to Dec \\
        {\tt A1E} & = auxiliary reading \#1 adjustment to mount elevation
        \end{tabular}
        \end{quote}
\newpage
\item The format string pointed to by this function
      can be any of the following:
      \begin{quote}
        {\tt \begin{tabular}{l}
             "PRCICI" \\
             "PRCIC" \\
             "PRCI" \\
             "PRC" \\
             "HRFCIFCI" \\
             "HRFCIFC" \\
             "HRFCFCI" \\
             "HRFCFC" \\
             "HRFCIII" \\
             "HRFCII" \\
             "HRFCI" \\
             "HRFC" \\
             "HRFCIIFC" \\
             "HRFCFCII" \\
             "ANR"      \\
             \end{tabular}}
      \end{quote}
      These are used by the {\tt tptTerm} routine to reduce the amount
      of string parsing required during intensive processing.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptTrmloc}{Register Term Names, Local}
\label{tptTrmloc}
\call{tptTrmloc ( \&navail, coeffn )}
\action{Insert into the coefficient name table the names of any
        {\bf locally implemented} pointing terms.}

\args{GIVEN}
{
\spec{navail}{int*}{number of vacant elements in {\tt coeffn} array} \\
\spec{coeffn}{char[][8]}{term table (coefficient names)}
}
\args{RETURNED}
{
\spec{navail}{int*}{updated, $< 0$ if not enough room} \\
\spec{coeffn}{char[][8]}{updated}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item After calling this routine, {\tt navail} can have the following values:

      \begin{tabular}{rl}
      $>0 =$ & number of vacant elements left in the {\tt coeffn} array \\
      $ 0 =$ & all terms were added, exactly filling the {\tt coeffn} array \\
      $<0 =$ & {\tt coeffn} array filled up before all terms could be added \\
      \end{tabular}
\item The supplied routine should be edited to meet local requirements.
\item Any {\bf standard} terms are added in the {\tt tptTrmstd} routine.
\item The terms are defined geometrically in the {\tt tptPterml} routine.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tptTrmstd}{Register Term Names, Standard}
\label{tptTrmstd}
\call{tptTrmstd ( \&navail, coeffn )}
\action{Insert into the coefficient name table the names of the
        {\bf standard} pointing terms.}

\args{GIVEN}
{
\spec{navail}{int*}{number of vacant elements in {\tt coeffn} array} \\
\spec{coeffn}{char[][8]}{term table (coefficient names)}
}
\args{RETURNED}
{
\spec{navail}{int*}{updated, $< 0$ if not enough room} \\
\spec{coeffn}{char[][8]}{updated}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item After calling this routine, {\tt navail} can have the following values:

      \begin{tabular}{rl}
      $>0 =$ & number of vacant elements left in the {\tt coeffn} array \\
      $ 0 =$ & all terms were added, exactly filling the {\tt coeffn} array \\
      $<0 =$ & {\tt coeffn} array filled up before all terms could be added \\
      \end{tabular}
\item Any {\bf locally implemented} terms are added in the
      {\tt tptTrmloc} routine.
\item The terms are defined geometrically in the {\tt tptPterms} routine.
\end{enumerate}
}
%-----------------------------------------------------------------------

\newpage
\fi

\subsection{Miscellaneous TCSpk Functions}

A handful of the supplied C functions are not part of the TCSpk core,
though they may be used in, or adapted for use in, a TCS application.

This category includes:
\begin{itemize}
\item a fairly comprehensive FAST routine, demonstrated
      by the {\tt tcs\_demo} program,
\item the optional ``special refraction'' routine,
      demonstrated in the {\tt tcs\_dsa} program, and
\item a ``stub'' function used by all the demonstration programs
      as a substitute for a time service.
      \end{itemize}

%-----------------------------------------------------------------------
\routine{tcsFast}{Example FAST Routine}
\label{tcsFast}
\call{tcsFast ( mode, isol, tai, Rotl, Rmat, Rma, Rmav, T0, St0, \\
\hspace*{10.7ex} Ia, Ib, Np, Xt, Yt, Zt, Ga, Gb, Rnogo, \\
\hspace*{10.7ex} M\_tar\_t0, M\_tar\_p0, M\_tar\_dt, Fl, \\
\hspace*{10.7ex} M\_por\_p, Sia, Cia, Pai, Jf, \\
\hspace*{10.7ex} M\_cosys, M\_spm1, M\_spm2,
                 R\_cosys, R\_spm1\_i, R\_spm2\_i, \\
\hspace*{10.7ex} \&roll, \&pitch, \&rota ) }
\action{Example FAST routine.  In every TCS there will be code like
        this, triggered at perhaps 20~Hz, that generates the tracking
        demands for the mount (and rotator, if any).}
\args{GIVEN}
{
\specsubhead{Control} \\
\spec{mode}{int}{action(s) required (Note~1)} \\
\spec{isol}{int}{TRUE selects ``below pole'' solution} \\
\spec{tai}{double}{time-stamp (TAI MJD = JD$-$2400000.5)} \\
\specsubhead{Rotator (\rm Note~2)} \\
\spec{Rotl}{ROTLOC}{focal station} \\
\spec{Rmat}{double}{time-stamp for {\t Rma} and {\tt Rmav}} \\
\spec{Rma}{double}{achieved rotator angle at time {\tt Rmat}} \\
\spec{Rmav}{double}{achieved rotator velocity at time {\tt Rmat}} \\
\specsubhead{Time (\rm Note~3)} \\
\spec{T0 }{double}{time-stamp for LAST and TT} \\
\spec{St0}{double}{LAST at time {\tt T0}} \\
\specsubhead{Model (\rm Note~4)} \\
\spec{Ia}{double}{roll zero-point} \\
\spec{Ib}{double}{pitch zero-point} \\
\spec{Np}{double}{mount axes nonperpendicularity} \\
\spec{Xt}{double}{telescope vector, $x$-coordinate} \\
\spec{Yt}{double}{telescope vector, $y$-coordinate} \\
\spec{Zt}{double}{telescope vector, $z$-coordinate} \\
\spec{Ga}{double}{guiding correction, collimation} \\
\spec{Gb}{double}{guiding correction, pitch} \\
\spec{Rnogo}{double}{mount pole avoidance radius} \\
\specsubhead{Target (\rm Note~5)} \\
\spec{M\_tar\_t0}{double}{target reference time} \\
\spec{M\_tar\_p0}{double[2]}{target coordinates at reference time} \\
\spec{M\_tar\_dt}{double[2]}{target differential rates}
}
\blank
{
\specsubhead{Pointing Origin (\rm Note~6)} \\
\spec{Fl}{double}{focal length} \\
\spec{M\_por\_p}{double[2]}{pointing-origin} \\
\specsubhead{Field Orientation (\rm Note~7)} \\
\spec{Sia}{double}{sine of instrument alignment angle} \\
\spec{Cia}{double}{cosine of instrument alignment angle} \\
\spec{Pai}{double}{instrument position-angle} \\
\spec{Jf}{int}{optimization: 0=slit, else=field} \\
\specsubhead{Transformation (Note 8)} \\
\spec{M\_cosys}{{\sc Frametype}}{frame for mount control} \\
\spec{M\_spm1}{double[3][3]}{mount SPM \#1} \\
\spec{M\_spm2}{double[3][3]}{mount SPM \#2} \\
\spec{R\_cosys}{{\sc Frametype}}{frame for rotator control} \\
\spec{R\_spm1\_i}{double[3][3]}{rotator inverse SPM \#1} \\
\spec{R\_spm2\_i}{double[3][3]}{rotator inverse SPM \#2}
}
\args{RETURNED \rm (Notes~9,10)}
{
\spec{roll}{double*}{mount roll (righthanded, ``south''-zero)} \\
\spec{pitch}{double*}{mount pitch} \\
\spec{rota}{double*}{rotator angle}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item The {\tt mode} argument defines which of the repertoire of
      actions are to be performed during this invocation.  Each action
      has a bit to flag that it is to be performed:
      \begin{center}
      \begin{tabular}{|c|r|l|} \hline
      {\it bit} & {\it decimal} & {\it action} \\ \hline \hline
      0000000 &  0 & calculate new mount and rotator coordinates \\
      0000001 &  1 & update the rotator achieved position/velocity \\
      0000010 &  2 & update the sidereal time parameters \\
      0000100 &  4 & update the pointing model coefficients \\
      0001000 &  8 & update the target position \\
      0010000 & 16 & update the pointing origin \\
      0100000 & 32 & update the field orientation \\
      1000000 & 64 & update the transformation matrices \\ \hline
      \end{tabular}
      \end{center}
      {\it n.b.}~Bits above 1111111 (decimal 127) are ignored.

      Examples:
      \begin{center}
      \begin{tabular}{|c|l|} \hline
      {\tt mode} & {\it action} \\ \hline \hline
        0 & calculate new mount and rotator coordinates \\
        2 & store new ST parameters in the context \\
        8 & supply new \radec \\
       64 & update the transformation \\
       72 & new target and transformation \\
      127 & update the whole context \\ \hline
      \end{tabular}
      \end{center}

      The ``calculate new coordinates'' action is intended to be
      invoked at a regular frequency of no less than 5~Hz, preferably
      10~Hz and ideally 20~Hz.  The higher the frequency, the more
      immediate the response to guiding and offsetting demands.

      The {\tt tai} argument is accessed only if {\tt mode}=0.
\item The rotator readings, the source of which is highly dependent
      on the particular TCS implementation, enable the pointing
      calculation to estimate  the orientation for the time to which
      its predictions apply.  The information is needed in order
      to calculate where to point the mount so that the star remains
      in position even when the rotator is moving.

      If there is no rotator, these parts of the context, once
      initialized, need not be touched again.

      The focal station has to be identified in order to apply the
      appropriate field rotation.  If there is no rotator, OTA, the
      simplest case, should be specified.
\item The time parameters enable fast computation of the local apparent
      sidereal time and the Terrestrial Time by the pointing kernel.
      The parameters must be supplied by the host application.  Once
      every five minutes is more than often enough.
\item The pointing coefficients will change slowly, as other pointing
      terms introduce small adjustments to the basic ones.  An update
      once every few seconds is frequent enough.
\item The target (where in the sky we want to look) will need to be
      updated whenever a new object is selected, for example.  If the
      new target is distant from the old one, or in a different frame,
      the transformations and pointing model will also need updating.
      It is important that the target and transformation updates be
      done all in one call ({\tt mode}=72) to ensure consistency.
\item The pointing-origin (where in the focal plane we want the image
      of the target to be) will need to be updated whenever a
      ``beamswitch'' (movement of the image in the focal plane without
      the target coordinates or the pointing model changing) is
      requested.  For most types of observation, however, it will be
      calibrated at the beginning of the session and left alone.

      The pointing-origin coordinates are in the same units as the
      focal length.
\item The field orientation (how the instrument is oriented with
      respect to the rotator and the sky respectively) will need to be
      updated whenever the image orientation is to be adjusted.  In
      most cases this will be established at the beginning of the
      session and left alone.

      The field orientation is specified in the following way:
      \begin{itemize}
      \item The user has chosen some direction on the instrument that is
            convenient to work with.  This is called the Instrument
            Principal Direction (IPD).  A typical choice of IPD would be
            the pixel $+y$ direction on a CCD.
      \item Through either mechanical preparation or calibration, the user
            has provided the orientation of the IPD with respect to the $+y$
            axis of the instrument rotator.  This angle is called the
            Instrument Alignment Angle (IAA), and it is supplied to the
            present routine in the form of the sine and cosine.
      \item The user then specifies what position-angle on the sky the IPD
            is to assume.  This called the Instrument Position-Angle (IPA)
            and is supplied to the present routine directly.
      \item Two slightly different field rotation compromises are
            available, suitable for instruments with a slit and a
            2D field respectively.  ``Slit-optimized'' means that
            two stars on the line through the pointing origin
            specified by the IPD remain on that line, though their
            separation may change due to differential refraction.
            ``Field-optimized'' produces
            a rotator angle that does
            not favor the IPD itself but minimizes field rotation
            overall.  The TCS might allow this choice
            to be made dynamically, to suit the current instrument,
            and an appropriate {\tt Jf} argument passed to this routine.
            In default, use {\tt Jf=1}.
      \end{itemize}
      The rotator demand that the present routine generates is called
      the Rotator Mechanical Angle (RMA).  It achieves the requested
      IPA at the pointing-origin and in the specified frame.
\item The transformations will be updated every few seconds by the
      MEDIUM process running in the host, and summarize the pointing
      across the patch of sky at which the telescope is being aimed.
      Included in these transformations are any pointing-model
      adjustments which affect the roll axis misalignment,
      complementing the other model terms (see the previous note).
\item The mount and rotator demands are timetagged and should be
      regarded as samples of a trajectory rather than simply the
      position for ``now''.  The servo controller software would use two
      or more such samples to interpolate or extrapolate the required
      position for the current time.

      Regarding the servo controller software, note the following:
      \begin{itemize}
      \item Although all components of the system need reasonably accurate
            time, only the servo controller itself needs the exact time.
      \item It is important that the earliest of the samples being used
            for the interpolation lies {\it before}\/ the time for which the
            trajectory calculation is being carried out.  If this condition
            is not met, so that both (or all) of the samples lie in the
            future, any step in the demand will for a while be extrapolated
            backwards, producing a spurious initial jump in the wrong
            direction.  Measures must be taken avoid this condition.  The
            most complete method is to retain all of the samples, no matter
            how far into the future they extend, until they are no longer
            required.  A cruder approach is to continue to use the same
            ``earliest'' sample until a replacement arrives that predates the
            current time, simply discarding any potential replacements that
            are for later than the current time.
      \end{itemize}
      See also Section~\ref{glitch}, p\pageref{glitch}.
\item The mount ``roll'' coordinate is $-h$ for an equatorial mount and
      $\pi-$azimuth for an altazimuth mount.  It is in the range
      $\pm\pi$.  Where
      the mechanical range is greater than $360^\circ$, for example where
      there is a cable wrap, selection of the correct range must take
      place outside the present routine.

      {\bf It is the host application's responsibility not to
           enable the calculation of mount coordinates until
           all of the context has been initialized.}
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{dsaRefsub}{Example Refraction Function (radio)}
\label{dsaRefsub}
\call{dsaRefsub ( mode, refa, refb, hm, tlat, \\
 \hspace*{13.2ex} temp, press, humid, tlr, wavel, \\
 \hspace*{13.2ex} xin, yin, zin, \&xout, \&yout, \&zout ) }
\action{Special radio refraction function for the
        {\tt tcs\_dsa} demonstrator application.  For
        radio wavelengths, it overrides the results from the default
        refraction calculations, which are optimized for speed and which
        do not cater for extremely low elevations.}
\args{GIVEN}
{
\spec{mode}{int}{0 = observed to topocentric, else {\it vice versa}} \\
\spec{refa}{double}{refraction constant A ($\tan$)} \\
\spec{refb}{double}{refraction constant B ($\tan^3$)} \\
\spec{hm}{double}{antenna height above sea level (meters)} \\
\spec{tlat}{double}{antenna latitude (true)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (hPa=mB)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{xin}{double}{input vector: $x$-coordinate} \\
\spec{yin}{double}{input vector: $y$-coordinate} \\
\spec{zin}{double}{input vector: $z$-coordinate}
}
\args{RETURNED}
{
\spec{xout}{double*}{output vector: $x$-coordinate} \\
\spec{yout}{double*}{output vector: $y$-coordinate} \\
\spec{zout}{double*}{output vector: $z$-coordinate}
}
\notes{
\begin{enumerate}
\item For the present function to be called, it must be ``declared''
      when the TCSpk context is set up and/or specified in the calls
      to {\tt tcsMedium} that ultimately cause the pointing to be
      calculated.
\item There is no error status.  The function is called in the
      {\tt tcsPtran} and {\tt tcsPtrani} routines, which run in
      real time and are not equipped to deal with errors.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsRefsub}{Example Refraction Function}
\label{tcsRefsub}
\call{tcsRefsub ( mode, refa, refb, hm, tlat, \\
 \hspace*{13.2ex} temp, press, humid, tlr, wavel, \\
 \hspace*{13.2ex} xin, yin, zin, \&xout, \&yout, \&zout ) }
\action{Special refraction function that is slower but more accurate
        than the default
        refraction calculations, which are optimized for speed and which
        do not cater for extremely low elevations.}
\args{GIVEN}
{
\spec{mode}{int}{0 = observed to topocentric, else {\it vice versa}} \\
\spec{refa}{double}{refraction constant A ($\tan$)} \\
\spec{refb}{double}{refraction constant B ($\tan^3$)} \\
\spec{hm}{double}{telescope height above sea level (meters)} \\
\spec{tlat}{double}{telescope latitude (true)} \\
\spec{temp}{double}{ambient temperature (K)} \\
\spec{press}{double}{pressure (hPa=mB)} \\
\spec{humid}{double}{relative humidity (0-1)} \\
\spec{tlr}{double}{tropospheric lapse rate (K per meter)} \\
\spec{wavel}{double}{wavelength (micrometers)} \\
\spec{xin}{double}{input vector: $x$-coordinate} \\
\spec{yin}{double}{input vector: $y$-coordinate} \\
\spec{zin}{double}{input vector: $z$-coordinate}
}
\args{RETURNED}
{
\spec{xout}{double*}{output vector: $x$-coordinate} \\
\spec{yout}{double*}{output vector: $y$-coordinate} \\
\spec{zout}{double*}{output vector: $z$-coordinate}
}
\notes{
\begin{enumerate}
\item For the present function to be called, it must be ``declared''
      when the TCSpk context is set up and/or specified in the calls
      to {\tt tcsMedium} that ultimately cause the pointing to be
      calculated.
\item There is no error status.  The function is called in the
      {\tt tcsPtran} and {\tt tcsPtrani} routines, which run in
      real time and are not equipped to deal with errors.
\end{enumerate}
}
%-----------------------------------------------------------------------
\routine{tcsTime}{Time Service Emulator}
\label{tcsTime}
\call{status = tcsTime ( \&tai ) }
\action{Read the current time.}
\args{RETURNED \rm (argument)}
{
\spec{tai}{double*}{TAI Modified Julian Date (JD$-$2400000.5)}
}
\args{RETURNED \rm (function value)}
{
\spec{}{int}{status: $0 =$ OK}
}
\notes{
\begin{enumerate}
\setlength{\parskip}{\medskipamount}
\item A fixed result is returned, corresponding to
      1994~July~27, 15:26:29 TAI precisely.  Obviously, the chosen
      date and time is easily changed and the TCS developer may
      well want to do this for test purposes.  ({\it n.b.}~See
      also Note~3.)
\item The function is called only by the demonstration programs,
      not by the TCSpk callable subroutines.  A real TCS application
      may even not require a {\tt tcsTime} function: the mechanism used
      to generate the time inputs to the TCSpk calls is entirely
      a matter for the application.
\item Note that the test date is many years in the past, and that
      the UT1$-$UTC and TAI$-$UTC values used in the demonstration
      programs apply to this date.  An operational
      TCS needs the latest values and the means of updating
      them once every few days (at least), not the numbers used in
      the demonstration programs.  (Similar remarks apply to
      the site coordinates, meteorological inputs {\it etc.}, but
      these are less likely to be overlooked.)
\item Zero status (= OK) is always returned.
\end{enumerate}
}

\newpage
\subsection{Demonstration Programs}
\label{demos}

Included in the TCSpk package is a set of demonstration programs.  Three
of these ({\tt tcs\_demo}, {\tt tcs\_dsa} and {\tt tcs\_equ}) are
fairly complete TCS simulators that could easily form the nucleus of
a real application (and indeed have done so).  The remainder demonstrate
particular TCSpk features.

The demonstration programs are useful both in their original form and as
starting-points for modified or enhanced versions.  For example it would
be a good plan for a TCS developer to begin by preparing a version of the
{\tt tcs\_demo} program set up for the telescope or antenna of interest;
this can then act as a benchmark for the new TCS as it takes shape.

All of the demonstration programs are more or less directly related to
{\tt tcs\_demo} which, as the ``master'' demonstration,
it is described in most detail (there is a complete code
walkthrough).
In some instances, such as
{\tt tcs\_dsa} and {\tt tcs\_equ},
the {\tt tcs\_demo} code is simplified to suit a
telescope or antenna that lacks some of the features included in
{\tt tcs\_demo}, such as an instrument rotator.  In some of
those instances extra
features, not found in {\tt tcs\_demo} are added.  In a
few cases the {\tt tcs\_demo} code is merely
a convenient starting point for a specialized test of some kind.

All the demonstrations assume two-thread operation.  However, it should
be borne in mind that TCSpk can also be run single-thread, providing
the potential delays to the FAST processing caused by the more
onerous MEDIUM and SLOW processing can be managed properly.  (See also
\ref{threads}, p\pageref{threads}.)

The demonstrations also use the approach where {\tt tcsMedium} is
called explicitly whenever there has been a context change, and
assume that the function will be executed at regular intervals
in addition.  A real TCS may choose to work in a radically
different way: see Section~\ref{scheduling}, p\pageref{scheduling}, and
Section~\ref{SPMs}, p\pageref{SPMs}.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_demo} demonstrator: telescope with rotator}
\label{tcs_demo}

The {\tt tcs\_demo} program is the most comprehensive of the various
demonstrations that are provided and is the best starting-point for
learning about TCSpk.  As supplied, it is configured to drive an
equatorial mount but includes provision for the altazimuth and
generalized gimbal cases as well.  It includes control of an
instrument rotator, and uses a freestanding FAST routine that
maintains its own copy of the context.

The demonstration consists of initializing the data context,
establishing the SLOW and MEDIUM updates, communicating context
changes to the FAST routine, then displaying the mount and
rotator demands and finally performing coordinate transformations
that show the consistency of the different calculations.

The C code should be studied by any prospective TCS
developer and may well provide a useful starting-point for writing the
TCS application itself.  Because of its importance, we will describe
it in detail, in the form of a code walkthrough.

The {\tt tcs\_demo} source code begins:
\begin{quote}
\begin{small}
\begin{verbatim}
#include <stdio.h>
#include <slalib.h>
#include "tcs.h"
#include "tcsmac.h"
int main ( )
\end{verbatim}\end{small}
\end{quote}
A macro is provided to allow the mount type
for the demonstration to be selected:
\begin{quote}
\begin{small}
\begin{verbatim}
#define MOUNT EQUAT      /* Mount type for this demonstration */
\end{verbatim}\end{small}
\end{quote}
The three options are ``ALTAZ'' for altazimuth, ``EQUAT'' for
equatorial and ``GIMBAL'' for the generalized gimbal.
Similarly, the instrument locator location can be changed by editing
the {\tt RLOCN} macro:
\begin{quote}
\begin{small}
\begin{verbatim}
#define RLOCN OTA        /* Instrument rotator location */
\end{verbatim}\end{small}
\end{quote}
There are five options: {\tt OTA} for Cassegran, Newtonian, prime focus,
bent Cass {\it etc.}, {\tt NASMYTH\_L} and {\tt NASMYTH\_R} for the
two Nasmyth foci and {\tt COUDE\_L} and {\tt COUDE\_R} for the
coud\'{e} foci fed through the two Nasmyth paths.  Note
that in a real TCS application, this would be a variable rather
than a macro, allowing changes from one focal station to another without
recompilation.

If the {\tt MOUNT} macro was set to {\tt GIMBAL}, it is necessary to
define the orientation of the mount by specifying the three
Euler angles that rotate from \azel\ to mount coordinates:
\begin{quote}
\begin{small}
\begin{verbatim}
#define GIM1Z 0.0        /* 1st rotation, about z-axis */
#define GIM2Y 0.0        /* 2nd rotation, about y-axis */
#define GIM3X 0.0        /* 3rd rotation, about x-axis */
\end{verbatim}\end{small}
\end{quote}
The local variables are defined, beginning with
the standard context:
\begin{quote}
\begin{small}
\begin{verbatim}
{
#include "tcsctx.h"

   int i, i4[4], j;
   char s;
   double tai, aia, ra, dec, t, st, sst, cst, xim, yim,
          a1, b1, a2, b2, a, b;
\end{verbatim}\end{small}
\end{quote}
We are ready to initialize the context, providing all the
information that is needed before the
system enters its real-time mode.  For the sake of the demonstration,
the values are specified in-line;  an operational TCS would of course
initialize everything by reading the current settings from
a configuration file.

We first specify
the site location: longitude (east positive),
geodetic latitude and height above mean sea level.
\begin{quote}
\begin{small}
\begin{verbatim}
tlongm = -155.471667*D2R;
tlatm = 19.826667*D2R;
hm = 4145.0;
\end{verbatim}\end{small}
\end{quote}
We specify the telescope focal length,
in this case the telescope is an 8m f/16 and we choose
millimeters as the units:
\begin{quote}
\begin{small}
\begin{verbatim}
fl = 128000.0;
\end{verbatim}\end{small}
\end{quote}
Note that any convenient units can be used:  the value is
used only to establish the scaling factor between
the desired units for focal-plane \xy\ and the focal length.

Next, the radius of the zone of avoidance around the pole of
the mounting is specified.  TCSpk will track around, not through,
this zone.
\begin{quote}
\begin{small}
\begin{verbatim}
rnogo = 0.25*D2R;
\end{verbatim}\end{small}
\end{quote}
Next, the current time parameters are set:
\begin{quote}
\begin{small}
\begin{verbatim}
delut = 0.746/86400.0;
delat = 29.0/86400.0;
ttmtai = 32.184/86400.0;
\end{verbatim}\end{small}
\end{quote}
The first one, UT1$-$UTC, changes continuously and should be obtained
from IERS bulletins.  The second, TAI$-$UTC, changes by 1.0 each time
there is a leap second.  The third, TT$-$TAI, is fixed.

On exceptionally accurate telescopes, it may be worth providing the
polar motion:
\begin{quote}
\begin{small}
\begin{verbatim}
xpmr = 0.25*AS2R;
ypmr = 0.4*AS2R;
\end{verbatim}\end{small}
\end{quote}
Like the time parameters, the polar motion can be obtained from
IERS bulletins.

An initial set of meteorological parameters is required:
\begin{quote}
\begin{small}
\begin{verbatim}
temp = 275.0;
press = 605.0;
humid = 0.8;
tlr = 0.0065;
wavelr = 0.5;
\end{verbatim}\end{small}
\end{quote}
The mount type and rotator location are specified:
\begin{quote}
\begin{small}
\begin{verbatim}
mount = MOUNT;
rotl = RLOCN;
\end{verbatim}\end{small}
\end{quote}
The system needs to know whether the mount is in the normal or
``beyond the pole'' attitude, and what roll and pitch angles
to start with:
\begin{quote}
\begin{small}
\begin{verbatim}
jbp = 0;
roll = 0.0;
pitch = 1.0;
\end{verbatim}\end{small}
\end{quote}
The initial working coordinate systems for the mount and rotator
are specified, including the color:
\begin{quote}
\begin{small}
\begin{verbatim}
m_cosys = FK5;
m_eqx = 2000.0;
m_wavel = 1.0;
r_cosys = m_cosys;
r_eqx = m_eqx;
r_wavel = m_wavel;
\end{verbatim}\end{small}
\end{quote}
At this stage, we are ready to initialize the pointing model.  Two ways
of doing this are demonstrated.  For the equatorial case, the model is
read from a file, {\tt specimen.mod} (see p\pageref{specimendotmod}):
\begin{quote}
\begin{small}
\begin{verbatim}
if ( mount == EQUAT ) {
   if ( tcsIntpm ( "specimen.mod", MAXTRM, NTROOM, model,
                   &nterml, &ntermx, &nterms,
                   coeffn, coform, coeffv ) ) return -1;
\end{verbatim}\end{small}
\end{quote}
For the other cases, the model is initialized by explicit calls:
\begin{quote}
\begin{small}
\begin{verbatim}
} else {
   if ( tptMinit ( MAXTRM, NTROOM, model,
                   &nterml, &ntermx, &nterms, coeffn ) ) return -1;
   if ( tcsAddtrm ( MAXTRM, NTROOM, "IA", 25.0*AS2R,
      &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
         :
   if ( tcsAddtrm ( MAXTRM, NTROOM, "AN", -12.0*AS2R,
      &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
}
\end{verbatim}\end{small}
\end{quote}
The file method is preferable in most cases.

In most telescope and antenna control systems there is provision
for making small changes to the pointing model during use, in
particular following start-of-night calibration procedures.  In
the case of an altazimuth mount, the usual candidates for
adjustment are the ``collimation'' terms IE and CA, but it is
not unknown for the azimuth zero point IA also to be included, and
occasionally the tilt terms AN and AW.  The corresponding terms for
an equatorial are ID, CH, IH, ME and MA.  The revised
coefficient value can be supplied via a call to {\tt tcsSterm},
like this:
\begin{quote}
\begin{small}
\begin{verbatim}
   if ( tcsSterm ( "AW", -5.0*AS2R,
                   MAXTRM, model, coeffn, coeffv ) ) return -1;
\end{verbatim}\end{small}
\end{quote}
The name of each term in the model and its coefficient value
can be recalled by means of the {\tt tcsIterm} function,
used here to list the whole model:
\begin{quote}
\begin{small}
\begin{verbatim}
   printf ( "\nPointing model:\n\n" );
   for ( i = 1; ! tcsIterm ( i,
                             MAXTRM, model, coeffn, coeffv,
                             sterm, &vterm ); i++ ) {
      printf ( "%3d    %-8s%+10.2f\n", i, sterm, vterm/AS2R );
   }
\end{verbatim}\end{small}
\end{quote}
The guiding adjustments are usually initialized to zero (and this can be
left to the C language's default initialization);  however, for this
demonstration we set one of them to a non-zero value:
\begin{quote}
\begin{small}
\begin{verbatim}
ga = 0.0*AS2R;
gb = 22.0*AS2R;
\end{verbatim}\end{small}
\end{quote}
At this stage we can perform the secondary initialization, where
the supplied data are digested into the required internal form.  Note
that only a subset of the above information is involved in this process.
\begin{quote}
\begin{small}
\begin{verbatim}
if ( tcsInit2 ( tlongm, tlatm, xpmr, ypmr, hm,
                mount, GIM1Z, GIM2Y, GIM3X, ae2nm,
                &tlong, &tlat, &uau, &vau, &ukm, &vkm, &diurab ) ) {
   printf ( "\nSecondary initialization has failed.\n" );
   return -1;
}
\end{verbatim}\end{small}
\end{quote}
A real TCS application will have provision for reading the
instrument rotator angle, from which its time-stamped position and
velocity, needed by TCSpk, can be obtained.  In the present
demonstration this is simulated:
\begin{quote}
\begin{small}
\begin{verbatim}
rma = 30.0*D2R;   /* Rotator angle (n.b. achieved, NOT demanded) */
rmav = 0.0;       /* Velocity (achieved). */
rmat = 0.0;       /* Time-stamp. */
\end{verbatim}\end{small}
\end{quote}
From now on, the SLOW routine must be run from time to time
({\it e.g.}~once a minute) to update the things that are slowly changing
and target-independent.  Because the SLOW routine is comparatively
CPU-intensive, most TCS implementations will choose to run it in a
different thread and at a lower priority than the FAST routine (or
even in a different processor).  However, it can and should be run
in the same thread as the MEDIUM routine (see later), which will
ensure that the context never becomes internally inconsistent.
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsTime ( &tai );
tcsSlow ( tai, hm, delut, delat, ttmtai,
          temp, press, humid, tlr, wavelr, tlong, tlat,
          &t0, &st0, &tt0, &ttj, amprms, &refa, &refb );
\end{verbatim}\end{small}
\end{quote}
From now on, the MEDIUM routine must be run from time to time
({\it e.g.}~every 5 seconds) in the background.  It updates the pointing
model and also recalculates the ``Sky-Patch Matrices''.  The SPMs are
$3\times3$ matrices which summarize the astrometric transformation for the
current location in the sky, enabling rapid and concise
transformations within the high-frequency part of the pointing
algorithm.  The MEDIUM routine must also be run immediately as part
of setting up a new target (see later), in such a way that it is
impossible for the FAST routine ever to see inconsistent target and
SPMs.
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsTime ( &tai );
(void) tcsMedium ( tai, MAXTRM, model, coeffv, nterml, ntermx, nterms,
                   coeffn, coform, mount, ae2nm, roll, pitch, jbp, aux,
                   m_cosys, m_eqx, m_wavel, r_cosys, r_eqx, r_wavel,
                   m_tar_p,
                   t0, st0, ttj, temp, press, humid, tlr, wavelr,
                   refa, refb, rfun, hm, tlat, diurab, amprms,
                   &ia, &ib, &np, &xt, &yt, &zt, ae2mt,
                   m_spm1, m_spm1_i, m_spm2, m_spm2_i,
                   r_spm1, r_spm1_i, r_spm2, r_spm2_i );
\end{verbatim}\end{small}
\end{quote}
The FAST routine needs to be informed about everything initialized
so far so that it can update its private copy of the context:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsFast ( ALL, jbp, tai,
          rotl, rmat, rma, rmav,
          t0, st0,
          ia, ib, np, xt, yt, zt, ga, gb, rnogo,
          m_tar_t0, m_tar_op0, m_tar_dt,
          fl, m_por_p,
          sia, cia, pai,
          m_cosys, m_spm1, m_spm2, r_cosys, r_spm1_i, r_spm2_i,
          &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
The demonstration now simulates the arrival of a new
field-orientation, as if from the user interface.
The TCS
would obtain the Instrument Alignment Angle (IAA), the
Instrument Position Angle (IPA), the reference frame in which
IPA is expressed ({\tt r\_cosys}),
the frame's equinox ({\tt r\_eqx}) and the
wavelength for rotator tracking ({\tt r\_wavel}) from the user in a
variety of ways, and would then set up the following context
variables:
\begin{quote}
\begin{tabular}{lll}
{\tt r\_cosys} & {{\tt FRAMETYPE}} & {rotator frame} \\
{\tt r\_eqx} & {\tt double} & {rotator equinox} \\
{\tt r\_wavel} & {\tt double} & {wavelength} \\
{\tt pai} & {\tt double} & {IPA} \\
{\tt sia,cia} & {double} & {sine and cosine of IAA} \\
{\tt jf} & {\tt int} & {optimization: 0\,=\,slit, else\,=\,field} \\
\end{tabular}
\end{quote}
The demonstration simulates this using hardwired constants:
\begin{quote}
\begin{small}
\begin{verbatim}
aia = 0.0;              /* IAA */
pai = 0.0;              /* IPA */
sia = sin ( aia );      /* sin(IAA) */
cia = cos ( aia );      /* cos(IAA) */
jf = 1;                 /* field-optimized */
\end{verbatim}\end{small}
\end{quote}
As always, we now need to tell the MEDIUM and FAST routines:
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsMedium ( tai, MAXTRM, model, coeffv, nterml, ntermx, nterms,
                      :
                   r_spm1, r_spm1_i, r_spm2, r_spm2_i );
       tcsFast ( PA, jbp, tai,
                      :
                 &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
The arrival of a new pointing-origin, as if from the user interface,
requires similar action.  In this case, the following
context variables are involved:
\begin{quote}
\begin{tabular}{lll}
{\tt m\_por\_p0} & {\tt double[npo][2]} & {pointing-origin \xy} \\
{\tt m\_por\_ob} & {\tt double[npo][3][2]} & {offsets from base} \\
\end{tabular}
\end{quote}
The units are as for the focal length.  Using hardwired
variables for demonstration purposes:
\begin{quote}
\begin{small}
\begin{verbatim}
npo = 1;
m_por_p0[npo][0] = 180.0;
m_por_p0[npo][1] = -150.0;
m_por_ob[npo][0][0] = -1.0;
m_por_ob[npo][0][1] = -2.0;
\end{verbatim}\end{small}
\end{quote}
Note that this demonstration maintains
several pointing-origins ({\tt NPOS} in number), selectable by
means of the index {\tt npo}.  It is up to the application to select the
one that is required.  For example, {\tt npo=1} could be the center of the
acquisition camera and {\tt npo=2} could be the entrance aperture of the
instrument.

Certain calibration procedures require that the pointing-origin be
reset to [0,0], the rotator axis.  A good plan is to reserve
pointing-origin \#0 for the rotator axis and to fix all the values
at zero.

It is the net pointing-origin that is passed to the FAST routine
in this demonstration.  This assumes that the main application
provides the offsets-from-base facility.  An alternative is to
place the facility in the FAST routine itself.

The context variables having been updated, the offsets from
base must be incorporated and finally the FAST routine must be
informed:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsPorup ( m_por_p0[npo], m_por_ob[npo], m_por_p );
tcsFast ( PO, jbp, tai,
             :
          &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
The most basic reason to change the context is of course to specify
a new target and thereby effect a slew from one place in the sky
to another.  The user-interface facilities may be quite elaborate,
involving not just character-based data entry, but selection from
star catalogs, observing lists, clickable star maps,
orbital elements and so on.  Conversions from the original
coordinate system to the tracking frame ({\it e.g.}~B1950 to J2000)
are assumed to take place in the user interface.  Note in particular
that proper motion is not handled by TCSpk but is similarly a
user-interface issue.

Whatever the data-entry approach, the following context variables result:
\begin{quote}
\begin{tabular}{lll}
{\tt m\_cosys} & {\tt FRAMETYPE} & {mount frame} \\
{\tt m\_eqx} & {\tt double} & {mount equinox} \\
{\tt m\_wavel} & {\tt double} & {wavelength} \\
{\tt m\_tar\_p0} & {\tt double[2]} & {\radec\ or \azel} \\
{\tt m\_tar\_dt} & {\tt double[2]} & {differential rates} \\
{\tt m\_tar\_t0} & {\tt double} & {reference time} \\
{\tt m\_tar\_ob} & {\tt double[3][2]} & {offsets from base} \\
\end{tabular}
\end{quote}
It is the net target that is passed to the FAST routine in this
demonstration.  This assumes that the main application provides
the offsets-from-base facility.  An alternative is to place the
facility in the FAST routine itself.

The example is an FK4
position for equinox B1974 plus offsets from base.  (A more
typical case would be an ICRS position and no offsets from base.)
\begin{quote}
\begin{small}
\begin{verbatim}
m\_cosys = FK4;
m\_eqx = 1975.0;
m\_wavel = 0.5;
r\_cosys = m\_cosys;
r\_eqx = m\_eqx;
m\_tar\_p0 [ 0 ] = 0.3654719453676126;
m\_tar\_p0 [ 1 ] = 0.3316125578789226;
m\_tar\_dt [ 0 ] = 0.0;
m\_tar\_dt [ 1 ] = 0.0;
m\_tar\_t0 = 0.0;
m\_tar\_ob [ 0 ] [ 0 ] = 15.0*AS2R;
m\_tar\_ob [ 0 ] [ 1 ] = 60.0*AS2R;
\end{verbatim}\end{small}
\end{quote}
Having set up the above variables, it is necessary to calculate
the current coordinates by incorporating differential tracking
and offsets from base, and then to inform first the
MEDIUM routine and then the FAST routine:
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsTime ( &tai );
tcsTargup ( tai, m_tar_t0, m_tar_p0, m_tar_dt, m_tar_ob,
            m_tar_op0, m_tar_p );
(void) tcsMedium ( tai, MAXTRM, model, coeffv, nterml, ntermx, nterms,
                      :
                   r_spm1, r_spm1_i, r_spm2, r_spm2_i );
tcsFast ( TARGET + TRANSFORM + MODEL, jbp, tai,
             :
          &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
Just before calling the FAST routine, the target position
is reported (code omitted for brevity):
\begin{quote}
\begin{small}
\begin{verbatim}
RA = 01 23 45.6000  Dec = +19 00 00.000  <- test star
    +00 00 01.0000        +00 01 00.000  <- offset
\end{verbatim}\end{small}
\end{quote}
From now on, the pointing-origin and the various offsets from base
can be changed at will.  Each time this happens appropriate steps
must be taken to communicate the new information to the FAST routine.

Whenever a completely new target is supplied, one that may involve
a change of reference frame or a position in the sky outside the
valid range of the current SPMs, the new target and new SPMs must
be communicated to the FAST routine as an atomic unit.

The pointing corrections have, up to now, been calculated for a
safe but arbitrary assumed telescope position.  As soon as the
FAST routine runs, which it will do as a consequence of being
invoked at some regular interval such as 50~ms, an accurate
demanded position will be available.  The call to FAST, below,
simulates this effect.  In reality, the pointing corrections
will simply be slightly inaccurate for a few seconds as the
system starts up.

The following code makes sure everything is
completely up to date and completes the setting-up process:
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsTime ( &tai );
tcsFast ( 0, jbp, tai,
             :
          &roll, &pitch, &rota );
tcsTargup ( tai, m_tar_t0, m_tar_p0, m_tar_dt, m_tar_ob,
            m_tar_op0, m_tar_p );
(void) tcsMedium ( tai, MAXTRM, model, coeffv, nterml, ntermx, nterms,
                      :
                   r_spm1, r_spm1_i, r_spm2, r_spm2_i );
tcsFast ( TRANSFORM + MODEL, jbp, tai,
             :
          &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
Next, the demonstration runs the FAST routine a few times.

The FAST routine would normally be triggered by a timer interrupt,
at a regular rate of 5-20~Hz.  This may happen in a different
processor.  It is assumed here that the appropriate mechanisms are
in place (a)~to implement the above ``update'' calls to {\tt tcsFast} and
(b)~to retrieve information from the mount controller as required.
\begin{quote}
\begin{small}
\begin{verbatim}
(void) tcsTime ( &tai );
for ( i = -20; i < 3; i++ ) {
   t = tai + ( ( (double) i ) * 0.05 ) / 86400.0;
   tcsFast ( 0, jbp, t,
                :
             &roll, &pitch, &rota );
\end{verbatim}\end{small}
\end{quote}
Note:  it may be appropriate at this point to tell the FAST
routine that the rotator has moved (always assuming the
telescope is equipped with a rotator).  When to do so depends
on whether the rotator is being driven and the current speed
at which it is moving.  The FAST routine linearly extrapolates
the achieved rotator position, and frequent updates of the
context may well be unnecessary.  The present demonstration
has a fixed rotator.

For the final three calls, the mount demands are reported (code omitted
for brevity):
\begin{quote}
\begin{small}
\begin{verbatim}
timestamp       =        49560.6433912037  MJD(TAI)
HA demand       =           -0.1318842718  degrees
Dec demand      =          +19.0448032674  degrees
rotator demand  =          180.0096182585  degrees

timestamp       =        49560.6433917824  MJD(TAI)
HA demand       =           -0.1316754012  degrees
Dec demand      =          +19.0448032730  degrees
rotator demand  =          180.0096182566  degrees

timestamp       =        49560.6433923611  MJD(TAI)
HA demand       =           -0.1314665280  degrees
Dec demand      =          +19.0448032786  degrees
rotator demand  =          180.0096182549  degrees
\end{verbatim}\end{small}
\end{quote}
The report format depends on which mount type has been chosen.  The
above result is for the default {\tt \#define MOUNT EQUAT} initialization.
If {\tt \#define MOUNT ALTAZ} is used instead, the report becomes:
\begin{quote}
\begin{small}
\begin{verbatim}
timestamp       =        49560.6433912037  MJD(TAI)
Az demand       =          167.1923741262  degrees
El demand       =           89.1827343613  degrees
rotator demand  =          183.8940635688  degrees

timestamp       =        49560.6433917824  MJD(TAI)
Az demand       =          167.2079491555  degrees
El demand       =           89.1827606749  degrees
rotator demand  =          183.8764030003  degrees

timestamp       =        49560.6433923611  MJD(TAI)
Az demand       =          167.2235259140  degrees
El demand       =           89.1827869350  degrees
rotator demand  =          183.8587417147  degrees
\end{verbatim}\end{small}
\end{quote}
Preparations are then made for the remaining demonstrations, which require
the sidereal time and the pointing-origin in units of 1~focal length:
\begin{quote}
\begin{small}
\begin{verbatim}
st = st0 + ( t - t0 ) * STRPD;
sst = sin ( st );
cst = cos ( st );
xim = m_por_p[0] / fl;
yim = m_por_p[1] / fl,
\end{verbatim}\end{small}
\end{quote}
The sky-to-encoders transformation is demonstrated next:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsVTenc ( m_tar_p[0], m_tar_p[1],
           m_spm1, m_cosys, sst, cst, m_spm2,
           rotl, rma, roll, pitch, xim, yim,
           ia, ib, np, xt, yt, zt, ga, gb, rnogo,
           &a1, &b1, &a2, &b2, &j );
\end{verbatim}\end{small}
\end{quote}
In this demonstration only the first solution ({\tt a1,b1})
is used and status is ignored.  The code for the report is omitted.
The results should agree with the final readings
from the previous test:
\begin{quote}
\begin{small}
\begin{verbatim}
Sky-to-encoders:
   HA demand    =           -0.1314665290  degrees
   Dec demand   =          +19.0448032718  degrees
\end{verbatim}\end{small}
\end{quote}
Next, we reverse the process by performing the
encoders-to-sky transformation:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsVTsky ( a, b, rotl, rma, xim, yim,
           m_spm1_i, m_cosys, sst, cst, m_spm2_i,
           ia, ib, np, xt, yt, zt, ga, gb,
           &ra, &dec );
\end{verbatim}\end{small}
\end{quote}
The report (code omitted) provides
evidence of the rigor of the TCSpk transformations:
\begin{quote}
\begin{small}
\begin{verbatim}
Encoders-to-sky:
   RA = 01 23 46.6000     Dec = +19 01 00.000
\end{verbatim}\end{small}
\end{quote}
The next demonstration is an
image-to-sky transformation.  The pointing-origin itself
is used so that we know what \radec\ to expect:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsVTsky ( a, b, rotl, rma, xim, yim,
           m_spm1_i, m_cosys, sst, cst, m_spm2_i,
           ia, ib, np, xt, yt, zt, ga, gb,
           &ra, &dec );
\end{verbatim}\end{small}
\end{quote}
The following report is produced (code omitted):
\begin{quote}
\begin{small}
\begin{verbatim}
Image-to-sky:
   x  =  +179.000000 mm   y   =  -152.000000 mm
   RA = 01 23 46.6000     Dec = +19 01 00.000
\end{verbatim}\end{small}
\end{quote}
Next, a sky-to-image transformation is performed.  A
contrived round-figure \radec\ is used. (Report code
omitted.)
\begin{quote}
\begin{small}
\begin{verbatim}
ra = 0.3665191431;
dec = 0.3316125579;
   :
tcsVTxy ( ra, dec,
          m_spm1, m_cosys, sst, cst, m_spm2,
          rotl, rma, a, b,
          ia, ib, np, xt, yt, zt, ga, gb,
          &xim, &yim, &j );
   :
\end{verbatim}\end{small}
\end{quote}
The report is as follows:
\begin{quote}
\begin{small}
\begin{verbatim}
Sky-to-image:
   RA = 01 24 00.0000     Dec = +19 00 00.000
   x  =   +58.265201 mm   y   =  -178.627370 mm
\end{verbatim}\end{small}
\end{quote}
The inverse, image-to-sky, transformation is then carried out:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsVTsky ( a, b, rotl, rma, xim, yim,
           m_spm1_i, m_cosys, sst, cst, m_spm2_i,
           ia, ib, np, xt, yt, zt, ga, gb,
           &ra, &dec );
\end{verbatim}\end{small}
\end{quote}
producing the following report (code omitted):
\begin{quote}
\begin{small}
\begin{verbatim}
Image-to-sky:
   x  =   +58.265201 mm   y   =  -178.627370 mm
   RA = 01 24 00.0000     Dec = +19 00 00.000
\end{verbatim}\end{small}
\end{quote}
The {\tt tcs\_demo} demonstration terminates here.
An operational system would
execute continuously, with {\tt tcsSlow} being executed once every minute or
so, {\tt tcsMedium} running every few seconds and also to conclude a change
of target, and {\tt tcsFast} (which will be looked at
next) running at maybe 20~Hz.

The {\tt tcsFast} routine (see p\pageref{tcsFast})
is part of the {\tt tcs\_demo} program but
potentially could be used in an operational TCS exactly as it is.
The first part (most of the code in fact) simply maintains a copy of the
data context.  For efficiency,
the updates are in groups, so that only the section of
context of interest need be updated.  The main interest lies in the
code that is invoked at a fixed freqency (of say 20~Hz).  This begins
by calculating the local apparent sidereal time and functions:
\begin{quote}
\begin{small}
\begin{verbatim}
dt = tai - t0;
st = st0 + dt * SPIN;
sst = sin ( st );
cst = cos ( st );
\end{verbatim}\end{small}
\end{quote}
Next, extrapolations of the roll, pitch and
rotator demands are made\ldots
\begin{quote}
\begin{small}
\begin{verbatim}
rotax = rma + ( tai - rmat ) * rmav;
dtlast = tai - tlast;
adpx = adp + dtlast * adv;
bdpx = bdp + dtlast * bdv;
rdpx = rdp + dtlast * rdv;
\end{verbatim}\end{small}
\end{quote}
any differential tracking is applied\ldots
\begin{quote}
\begin{small}
\begin{verbatim}
dtdt = tai - m_tar_t0;
for ( i = 0; i < 2; i++ ) {
   tar[i] = m_tar_p0[i] + dtdt * m_tar_dt[i];
}
\end{verbatim}\end{small}
\end{quote}
the pointing-origin is converted into units of 1~focal length\ldots
\begin{quote}
\begin{small}
\begin{verbatim}
xr = m_por_p[0] / fl;
yr = m_por_p[1] / fl;
\end{verbatim}\end{small}
\end{quote}
and we are ready to calculate the mount roll and pitch demands:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsTrack ( tar[0], tar[1],
           m_spm1, m_cosys, sst, cst, m_spm2,
           rotl, rotax, adpx, bdpx, xr, yr,
           ia, ib, np, xt, yt, zt, ga, gb, rnogo,
           &xa, &ya, &za,
           &ad1, &bd1, &ad2, &bd2, &j );
\end{verbatim}\end{small}
\end{quote}
In this implementation, status is ignored.
If pole-avoidance is flagged this would need to be communicated
to the user-interface and any data-acquisition facilities.
Only a serious
inconsistency in the rest of the system could cause an error
status, and rather than allowing the application to die
it is probably better to carry on regardless and hope that the
condition cures itself.  (However, it may be prudent
to continue using the previous demands.)

The data context item {\tt isol} allows us
to select the appropriate solution (above/below pole {\it etc.}):
\begin{quote}
\begin{small}
\begin{verbatim}
ad = isol ? ad2 : ad1;
bd = isol ? bd2 : bd1;
\end{verbatim}\end{small}
\end{quote}
The rotator demand is then predicted:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsRotator ( xa, ya, za, rotl, rdpx, isol, ad, bd, xr, yr,
             ia, ib, np, xt, yt, zt, ga, gb,
             sia, cia, r_spm1_i, r_cosys, sst, cst, r_spm2_i, pai,
             &rd, &j );
\end{verbatim}\end{small}
\end{quote}
Again, status is ignored in this implementation.

All that remains is to save the latest velocities (if credible),
the most recent time-stamp and choice of solution, and to save and
return the latest demands:
\begin{quote}
\begin{small}
\begin{verbatim}
if ( dtlast != 0.0 && isol == islast ) {
   adv = ( ad - adp ) / dtlast;
   if ( fabs ( adv ) >= PI ) adv -= adv < 0.0 ? PI2 : - PI2;
   bdv = ( bd - bdp ) / dtlast;
   rdv = ( rd - rdp ) / dtlast;
   if ( fabs ( rdv ) >= PI ) rdv -= rdv < 0.0 ? PI2 : - PI2;
}
tlast = tai;
islast = isol;
*roll = adp = ad;
*pitch = bdp = bd;
*rota = rdp = rd;
\end{verbatim}\end{small}
\end{quote}

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_dsa} demonstrator: radio antenna with scanning}
\label{tcs_dsa}

The {\tt tcs\_dsa} progam demonstrates the
TCSpk pointing kernel in a manner oriented towards a
deep-space antenna application.  Compared with {\tt tcs\_demo}, which
has just been described, the following simplifications have been made:
\begin{itemize}
\item The demonstration is altazimuth only.  The equatorial
      and generalized gimbal cases are not supported.
\item There is no instrument rotator (and no field-orientation support).
\item Support for off-axis pointing-origins is absent.  (The
      pointing-origin concept is, however, used, to implement
      scanning.)
\item Polar motion corrections, typically around 0.1~mdeg,
      are neglected.
\end{itemize}
There are two additional features, not found in {\tt tcs\_demo}:
\begin{itemize}
\item Scanning (used for peaking-up on a calibration source) is
      implemented.
\item A special refraction routine is declared.
\end{itemize}
The {\tt tcs\_dsa} data context is defined in a special header file
called dsactx.h
In place of the freestanding {\tt tcsFast} function that {\tt tcs\_demo}
calls, {\tt tcs\_dsa} has an internal function called {\tt tcsFast\_dsa}.
As well as maintaining a local copy of the data context and generating
the mount tracking demands, {\tt tcsFast\_dsa} performs the scan
maneuvers, which have to be properly locked to real time.

The demonstrations include two sorts of scan (two cycles of
line scanning and an indefinite circular scan)
and control in topocentric \azel\ mode (as might be required
if a front-end controller was generating pointing directions to
a spacecraft but required the insertion of refraction
and pointing-model corrections).

The scanning feature that is implemented in {\tt tcsFast\_dsa} is
driven by the following parameters.  The names are those used in the
{\tt dsactx.h} header file.

{\bf Scan Unit} ({\tt s\_unit})
\begin{quote}
     The pointing-origin feature of TCSpk is in the
     {\tt tcs\_dsa} demonstrator used for scanning rather than
     to control image position in the focal plane.  Because of
     this, the ``focal length'' serves as the scan unit in radians.
     A value of 1.0 means the scan unit is
     radians;  a value of about 0.01745 means the scan unit is
     degrees;  other values would allow the scan to be specified
     in terms of beamwidths; and so on.  To first order, an offset
     of 1.0 will move the antenna {\tt s\_unit} radians on the sky.
\end{quote}
     {\bf List of \xy\ Offsets} ({\tt spath[NSPMAX][2]}), and
     {\bf Size of List} ({\tt nsp})
\begin{quote}
     The scan pattern is defined as a series of \xy\ offsets,
     where $x$ is left-right and $y$ is up-down along great circles
     in the tracking frame.  The offsets are floats in a unit of
     choice (for example degrees; see {\tt s\_unit}) measured
     in the tangent plane.
     It is assumed that the trajectory is linear between the
     \xy\ offsets.
\end{quote}
{\bf Time per Cycle} ({\tt s\_period})
\begin{quote}
     The period of the scan is defined by the number of
     seconds required to cycle through all the \xy\ positions.
     Often, the period will be the length of the \xy\ list
     multiplied by the interval between successive mount
     trajectory calculations ({\it e.g.}~0.1~s).
\end{quote}
{\bf Number of Cycles} ({\tt nsc})
\begin{quote}
     Scans can be one or more cycles long, or can continue
     indefinitely.
\end{quote}
{\bf Scan Reference Time} ({\tt s\_epoch})
\begin{quote}
     The scan reference time is the TAI MJD at which
     the first offset position is demanded.
\end{quote}
{\bf Scan Status/Command} ({\tt jscan})
\begin{quote}
     Scan actions are controlled by sending a status flag.
     Internally, the status changes as the scan progresses, though
     this is not visible to the application.  The following actions
     are available:
     \begin{itemize}
     \item Disengage scanning activity, returning to the un-offset
           position.
     \item Begin scanning at the specified reference time.  If
           the reference time is in the past, scanning begins
           immediately at the offset that would have been reached
           has the scan started at the reference time.
     \item Begin scanning immediately, starting from the phase
           corresponding to the current time with respect to the
           reference time.
     \item Halt the scan at its present offset.  ({\it n.b.}~There is no
           provision for resumption from the current offset;  phase
           is always determined by the current and reference times.
           Should such an effect be desired, it could be achieved
           by sending a revised reference time.)

           To scan indefinitely, specify a number of cycles less than
           one.

           To finish scanning at the end of the current cycle, send a
           revised number of cycles.
     \end{itemize}
     The possible scan state values are
     \begin{quote}
     \begin{tabular}{ll}
        {\tt SCAN\_OFF   } & no scanning activity \\
        {\tt SCAN\_ARMED } & begin at start time \\
        {\tt SCAN\_ACTIVE} & scanning \\
        {\tt SCAN\_PAUSE } & halted \\
     \end{tabular}
     \end{quote}
\end{quote}
No detailed code walkthrough will be presented
for {\tt tcs\_dsa}, as for the most part
the code is essentially the same as for {\tt tcs\_demo} and is in any
case self-explanatory.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_equ} demonstrator: equatorial without rotator}
\label{tcs_equ}

The {\tt tcs\_equ} program is another version of {\tt tcs\_demo},
considerably simplified but still capable of
meeting the requirements of a sophisticated amateur
telescopes.  Compared with {\tt tcs\_demo}, it has
the following differences:
\begin{itemize}
\item Equatorial only.
\item Tracks only in J2000 \radec.
\item No instrument rotator.
\item Single pointing-origin.
\end{itemize}
It uses the standard context layout defined in {\tt tcsctx.h} and
has its own internal FAST routine called {\tt tcsFast\_e}.  As
for {\tt tcs\_demo}, the
file defining the pointing model is {\tt specimen.mod}.

The report produced by {\tt tcs\_equ} is an extended version of the
one from {\tt tcs\_demo}.  First the test star \radec\ is logged,
along with the offsets from base:
\begin{quote}
\begin{small}
\begin{verbatim}
RA = 01 23 45.6000  Dec = +19 00 00.000  <- test star
    +00 00 01.0000        +00 01 00.000  <- offset
\end{verbatim}\end{small}
\end{quote}
Then the tracking is demonstrated.  Both mount attitude
solutions will be presented;  this is the primary one:
\begin{quote}
\begin{small}
\begin{verbatim}
PRIMARY SOLUTION:

timestamp       =        49560.6433912037  MJD(TAI)
HA demand       =          +50.4854757060  degrees
Dec demand      =          +19.0296700916  degrees

timestamp       =        49560.6433917824  MJD(TAI)
HA demand       =          +50.4856845390  degrees
Dec demand      =          +19.0296701255  degrees

timestamp       =        49560.6433923611  MJD(TAI)
HA demand       =          +50.4858933747  degrees
Dec demand      =          +19.0296701594  degrees
\end{verbatim}\end{small}
\end{quote}
The sky-to-encoders transformation is then demonstrated, agreeing
with the final tracking sample, above:
\begin{quote}
\begin{small}
\begin{verbatim}
Sky-to-encoders:
   HA demand    =          +50.4858933747  degrees
   Dec demand   =          +19.0296701594  degrees
\end{verbatim}\end{small}
\end{quote}
At this point there is an important additional step compared
with {\tt tcs\_demo}.  First, a set of sky-patch matrices is
generated, but for the theoretical case of a perfectly
oriented mount and no refraction.
This is accomplished by calling the
{\tt tcsTartran} function, specifying zero for the refraction
coefficients and the pressure, and by using the matrix {\tt ae2nm}
(\azel\ to {\it nominal}\/ mount) instead of the matrix {\tt ae2mt}
(\azel\ to {\it actual}\/ mount):
\begin{quote}
\begin{small}
\begin{verbatim}
tcsTartran ( ttj, amprms, ae2nm, hm, tlat, diurab, 0.0, 0.0,
             temp, 0.0, humid, tlr, wavelr, rfun,
             sst, cst, m_cosys, m_eqx, m_tar_p,
             spm1_z, spm1_z_i,
             spm2_z, spm2_z_i );
\end{verbatim}\end{small}
\end{quote}
These special SPMs are then used to repeat the encoder predictions,
but this time for a mount without pointing errors:
\begin{quote}
\begin{small}
\begin{verbatim}
tcsVTenc ( m_tar_p[0], m_tar_p[1],
           spm1_z, m_cosys, sst, cst, spm2_z,
           OTA, 0.0, 0.0, 0.0, 0.0, 0.0,
           0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0,
           &a1, &b1, &a2, &b2, &j );
\end{verbatim}\end{small}
\end{quote}
The ``uncorrected'' predictions are then subtracted from the
real predictions to reveal the total corections for refraction
and pointing errors:
\begin{quote}
\begin{small}
   \begin{verbatim}

   HA correction  =        -19.516337      arcsec
   Dec correction =       +147.139000      arcsec
\end{verbatim}\end{small}
\end{quote}
As for {\tt tcs\_demo}, various transformations are then
carried out to demonstrate the rigor that TCSpk achieves:
\begin{quote}
\begin{small}
\begin{verbatim}
Encoders-to-sky:
   RA = 01 23 46.6000     Dec = +19 01 00.000

Sky-to-image:
   RA = 01 24 00.0000     Dec = +18 54 00.000
   x  =    -5.072391 mm   y   =   +11.193106 mm

Image-to-sky:
   x  =    -5.072391 mm   y   =   +11.193106 mm
   RA = 01 24 00.0000     Dec = +18 54 00.000
\end{verbatim}\end{small}
\end{quote}
The entire process is then repeated, but for the other
solution, corresponding for example to a German Equatorial Mount
being flipped across the polar axis:
\begin{quote}
\begin{small}
\begin{verbatim}
SECONDARY SOLUTION:

timestamp       =        49560.6433912037  MJD(TAI)
HA demand       =         -129.5741410162  degrees
Dec demand      =         +161.0283610350  degrees

timestamp       =        49560.6433917824  MJD(TAI)
HA demand       =         -129.5739321831  degrees
Dec demand      =         +161.0283610011  degrees

timestamp       =        49560.6433923611  MJD(TAI)
HA demand       =         -129.5737233475  degrees
Dec demand      =         +161.0283609672  degrees

HA drift        =          +4.622 arcsec per sec
Dec drift       =          -0.147 arcsec per sec

Sky-to-encoders:
   HA demand    =         -129.5737233475  degrees
   Dec demand   =         +161.0283609672  degrees

   HA correction  =       -234.136537      arcsec
   Dec correction =        +61.773056      arcsec

Encoders-to-sky:
   RA = 01 23 46.6000     Dec = +19 01 00.000

Sky-to-image:
   RA = 01 24 00.0000     Dec = +18 54 00.000
   x  =    +5.069420 mm   y   =   -11.194452 mm

Image-to-sky:
   x  =    +5.069420 mm   y   =   -11.194452 mm
   RA = 01 24 00.0000     Dec = +18 54 00.000
\end{verbatim}\end{small}
\end{quote}
Note that the pointing corrections are completely different,
and yet the same accurate results are obtained.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_pa} demonstrator: rotator angle}
\label{tcs_pa}

The objective of the {\tt tcs\_pa} demonstration program
is to demonstrate the reliability of the
instrument rotator predictions, known to be a weak aspect of almost
all TCS applications that are not based on TCSpk.

The mount is altazimuth, and the instrument rotator is placed at the
Nasmyth-left position (not the easiest case).
The focal length, in mm, is for an 8m f/16
telescope.
\begin{quote}
\begin{small}
      \begin{verbatim}
      :
#define MOUNT ALTAZ      /* Mount type for this demonstration */
#define RLOCN NASMYTH_L  /* Instrument rotator location */
      :
   fl = 128000.0;
\end{verbatim}\end{small}
\end{quote}
The Instrument Alignment Angle (the orientation in \xy\ of the
chosen Instrument Principal Direction) is set to $10^\circ$ and
the Instrument Position Angle (the P.A.~on the sky that we
want the instrument Principal Direction to be aligned to) is
set to $45^\circ$:
\begin{quote}
\begin{small}
\begin{verbatim}
aia = 10.0*D2R;         /* IAA */
pai = 45.0*D2R;         /* IPA */
\end{verbatim}\end{small}
\end{quote}
To make this a difficult case, the pointing-origin is set well off-axis
(about 243~mm, more than 6~arcminutes):
\begin{quote}
\begin{small}
\begin{verbatim}
npo = 1;
m_por_p0[npo][0] = 180.0;
m_por_p0[npo][1] = -150.0;
\end{verbatim}\end{small}
\end{quote}
The rest of the context is set to suitable values.  The
star that is chosen is at a zenith distance of only
\degree{3}{6}, which when combined with the highly
off-axis pointing-origin makes rotator control a challenge.

The FAST routine is run a few times and the rotator angle is each
time set to the predicted value, giving a smoothly changing
result as the telescope tracks the star.  The
final step is to determine the resulting field orientation,
at the pointing-origin, and to see if it matches the demanded $45^\circ$.

The first step is to note the current time, compute the sidereal
time, and scale the position-angle \xy\ into natural units:
\begin{quote}
\begin{small}
\begin{verbatim}
t = rmat;
st = st0 + ( t - t0 ) * STRPD;
sst = sin ( st );
cst = cos ( st );
xim = m_por_p[0] / fl;
yim = m_por_p[1] / fl;
\end{verbatim}\end{small}
\end{quote}
We then obtain the \radec\ of two test points, lying along the Instrument
Principal Direction a tiny distance (20~mas) either side of
the pointing-origin:
\begin{quote}
\begin{small}
\begin{verbatim}
w = 1e-7;
wx = w * sia;
wy = w * cia;
tcsVTsky ( roll, pitch, rotl, rma, xim - wx, yim - wy,
           m_spm1_i, m_cosys, sst, cst, m_spm2_i,
           ia, ib, np, xt, yt, zt, ga, gb,
           &ra, &dec );
tcsVTsky ( roll, pitch, rotl, rma, xim + wx, yim + wy,
           m_spm1_i, m_cosys, sst, cst, m_spm2_i,
           ia, ib, np, xt, yt, zt, ga, gb,
           &ra2, &dec2 );
\end{verbatim}\end{small}
\end{quote}
The relative position angle is obtained from a call to the SLALIB/C
function {\tt slaDbear}:
\begin{quote}
\begin{small}
\begin{verbatim}
printf ( "\nThe Instrument Principal Direction"
         " is at position-angle %+13.9f deg\n\n",
         slaDbear( ra, dec, ra2, dec2 ) / D2R );
\end{verbatim}\end{small}
\end{quote}
giving the following output:
\begin{quote}
\begin{small}
\begin{small}
\begin{verbatim}
The Instrument Principal Direction is at position-angle +45.000003649 deg
\end{verbatim}\end{small}
\end{small}
\end{quote}
The error is just a few microdegrees.  Note that this is not simply a
``round figure'' answer resulting from some tautology
in the test; the rotator demand itself is continuously changing, and
at the sample time is just passing \degree{35}{221364329}, conspicuously
{\it not}\/ a round figure.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_test} demonstrator: standard test}
\label{tcs_test}

Little need be said about {\tt tcs\_test}.  Again based on
{\tt tcs\_demo}, it executes the MEDIUM and FAST pointing routines
repeatedly at a fixed absolute time until a stable result is
achieved (100 iterations are used in fact).  The roll, pitch and
rotator demands are reported, plus the results of an
``upstream'' ({\it i.e.}~encoders-to-sky) transformation.

The results can then be used to verify the correctness
of a TCS pointing kernel (whether TCS-based or not) and are a useful
confirmation that TCSpk has built correctly on a given platform.

The default configuration is an altazimuth mount with the
instrument rotator at coud\'e right.

The report looks like this:
\begin{quote}
\begin{small}
\begin{verbatim}
RA = 03 23 45.6000  Dec = +19 00 00.000  <- test star
    +00 00 01.0000        +00 01 00.000  <- offset

timestamp       =        49560.6433912037 MJD (TAI)
Roll demand     = 1.6325638388777 (  93.5390177534 degrees )
Pitch demand    = 1.0776555419404 (  61.7451143221 degrees )
Rotator demand  = 1.8866916726733 ( 108.0994700867 degrees )

RA = 03 23 46.6000  Dec = +19 01 00.000  <- from upstream calculation
\end{verbatim}\end{small}
\end{quote}
{\it n.b.}~The results are expressed to a large number of decimal places,
and changes from time to time and from platform to platform are to be
expected.  The results are in any case sensitive to such things as
nutation and refraction models,
so linking against a new release of the SLALIB/C
positional-astronomy library
(see Section~\ref{slalib}, p\pageref{slalib})
might be expected to cause comparatively large changes, at the level
of milliarcseconds.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_tpt} demonstrator: generate dummy TPOINT data}
\label{tcs_tpt}

The {\tt tcs\_tpt} program generates a file that the TPOINT
pointing-analysis package can analyze, verifying that the telescope
demands correspond to the TPOINT model.

By default, {\tt tcs\_tpt} is configured for an altazimuth mount
with the instrument rotator mounted on the OTA (for example
at Cassegrain):
\begin{quote}
\begin{small}
\begin{verbatim}
#define MOUNT ALTAZ      /* Mount type */
#define RLOCN OTA        /* Instrument rotator location */
\end{verbatim}\end{small}
\end{quote}
The program uses a list of
fictitious stars distributed evenly all over the celestial
sphere at $10^\circ$ spacing, 411 in number:
\begin{quote}
\begin{small}
\begin{verbatim}
double stars[][2] = { { 0.2023839951, -1.4602692127 },
                      { 4.7540435791, -1.4920477867 },
                      { 3.3970603943, -1.4061105251 },
                         :
                      { 2.8616786003,  1.4297649860 },
                      { 0.5994768143,  1.4295963049 },
                      { 4.7056641579,  1.4949979782 } };
int nstars = sizeof(stars)/(2*sizeof(double));
\end{verbatim}\end{small}
\end{quote}
(The list is potentially a useful starting-point for all sorts of tests and
demonstrations.  The even spacing was achieved by an ``electrostatic''
algorithm that allowed all the points to move under the influence of
mutual repulsion until a stable configuration was achieved.  The resulting
pattern gives equal weighting around the sky and naturally
leads to plots against different coordinates that are themselves
evenly populated.  This may be contrasted with the not
uncommon practice of conducting pointing tests using stars on an
\radec\ or \azel\ grid.  Such a pattern produces a bias towards the
pole or zenith, where the stars are closest on the sky, and ugly plots
where the stars lie in clumps.)

For the default altazimuth/OTA configuration, the pointing model
is initialized using the standard six geometrical terms plus
tube flexure, with coefficient values that are whole numbers
of arcseconds:
\begin{quote}
\begin{small}
\begin{verbatim}
if ( tptMinit ( MAXTRM, NTROOM, model,
                &nterml, &ntermx, &nterms, coeffn ) ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "IA", 25.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "IE", 15.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "TF", 10.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "CA", -110.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "NPAE", 8.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "AW", -5.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
if ( tcsAddtrm ( MAXTRM, NTROOM, "AN", -12.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
\end{verbatim}\end{small}
\end{quote}
The program takes each star in turn and computes the encoder readings
that would be demanded to point at each one, for the circumstances
of the simulation.  Using SLALIB/C calls, it also predicts the
``observed'' position, the true \azel\ of the incoming light\ldots
\begin{quote}
\begin{small}
\begin{verbatim}
slaMap ( m_tar_p0[0], m_tar_p0[1], 0.0, 0.0, 0.0, 0.0,
         2000.0, tai + ttmtai,
         &rap, &dap );
slaAop ( rap, dap, tai - delat, delut, tlongm, tlatm, hm, xpmr, ypmr,
         temp, press, humid, wavelr, tlr,
         &topaz, &topzd, &w, &w, &w );
\end{verbatim}\end{small}
\end{quote}
\ldots and writes out the star and telescope \azel s in a
format suitable for TPOINT analysis:
\begin{quote}
\begin{small}
\begin{verbatim}
printf ( "%+16.9f %+16.9f %+16.9f %+16.9f\n",
                                   slaDranrm ( topaz ) / D2R,
                                   ( D90 - topzd ) / D2R,
                                   slaDranrm ( PI - roll ) / D2R,
                                   pitch / D2R );
\end{verbatim}\end{small}
\end{quote}
The resulting file looks like this:
\begin{quote}
\begin{small}
\begin{verbatim}
Output from TCS_TPT
: ALLSKY
: ALTAZ
+20 00 00
   +77.740252210    -67.189041687    +77.671550329    -67.191504218
   +91.876531173    -74.147382641    +91.775378967    -74.149325965
  +121.532700547    -70.569109507   +121.447508470    -70.569451511
      :
  +250.162750870    +69.843915266   +250.096898109    +69.840548980
  +296.522445594    +73.457910599   +296.437517899    +73.451826947
  +274.280389940    +65.338542168   +274.225959780    +65.333915593
END
\end{verbatim}\end{small}
\end{quote}
When analyzed with TPOINT, the file produces the following result:
\begin{quote}
\begin{small}
\begin{verbatim}
       coeff       change     value    sigma

  1     IA         +0.000    +25.00    0.000
  2     IE         +0.000    +15.00    0.000
  3     TF         +0.000    +10.00    0.000
  4     CA         -0.000   -110.00    0.000
  5     NPAE       -0.000     +8.00    0.000
  6     AW         +0.000     -5.00    0.000
  7     AN         +0.000    -12.00    0.000

Sky RMS =   0.00
Popn SD =   0.00
\end{verbatim}\end{small}
\end{quote}
Note that the model that was used in the simulation has been
accurately recovered.

%-----------------------------------------------------------------------

\newpage
\subsubsection{The {\tt tcs\_zt} demonstrator: track near zenith}
\label{tcs_zt}

The {\tt tcs\_zt} program simulates an altazimuth mount tracking
a star through the zenith region.  It writes a file of \xy\
coordinates representing the mount's locus,
and demonstrates the {\tt rnogo} zenith-avoidance strategy.

The program is configured for an altazimuth mount
with the instrument rotator mounted on the OTA (for example
at Cassegrain):
\begin{quote}
\begin{small}
\begin{verbatim}
#define MOUNT ALTAZ      /* Mount type for this demonstration */
#define RLOCN OTA        /* Instrument rotator location */
\end{verbatim}\end{small}
\end{quote}
A zenith avoidance region of \degree{0}{25} is specified:
\begin{quote}
\begin{small}
\begin{verbatim}
rnogo = 0.25*D2R;
\end{verbatim}\end{small}
\end{quote}
The pointing model is as for the previous demonstration, {\tt tcs\_tpt},
and features a sizeable collimation error that will cause large
azimuth adjustments near the zenith and corresponding gyrations
of the instrument rotator:
\begin{quote}
\begin{small}
\begin{verbatim}
if ( tcsAddtrm ( MAXTRM, NTROOM, "CA", -110.0*AS2R,
   &nterms, coeffn, coform, model, coeffv ) <= 0 ) return -1;
\end{verbatim}\end{small}
\end{quote}
The prospects for tracking close to the zenith are made even more
unfavourable by the pointing-origin, which is about 5.5~arcminutes
off axis:
\begin{quote}
\begin{small}
\begin{verbatim}
npo = 1;
m_por_p0[npo][0] = 200.0;
m_por_p0[npo][1] = 50.0;
\end{verbatim}\end{small}
\end{quote}
The target star's J2000 declination differs from the telescope
latitude by 100~arcseconds and ensures a tracking passing close to
the zenith (the apparent place of the star turns out to be
\hms{21}{06}{31}{8}~\dms{+19}{50}{08}, passing within 68~arcseconds
of the zenith):
\begin{quote}
\begin{small}
\begin{verbatim}
m_cosys = FK5;
m_eqx = 2000.0;
m_wavel = 0.5;
r_cosys = m_cosys;
r_eqx = m_eqx;
m_tar_p0 [ 0 ] = st0;
m_tar_p0 [ 1 ] = tlatm + 100.0*AS2R;
\end{verbatim}\end{small}
\end{quote}
The simulation consists of a track lasting 400~s:
\begin{quote}
\begin{small}
\begin{verbatim}
for ( i = -2000; i < 2000; i++ ) {
   t = tai + ( ( (double) i ) * 0.05 ) / 86400.0;
\end{verbatim}\end{small}
\end{quote}
The \azel\ demands are expressed in degrees using a tangent-plane
projection:
\begin{quote}
\begin{small}
\begin{verbatim}
slaDs2tp ( roll, pitch, 0.0, D90, &x, &y, &j );
printf ( " %+20.16f %+20.16f\n", x/D2R, y/D2R );
\end{verbatim}\end{small}
\end{quote}
The resulting file looks like this:
\begin{quote}
\begin{small}
\begin{verbatim}
-0.5 -0.5
-0.5 +0.5
+0.5 -0.5
+0.5 +0.5
  +0.2673377589026584  +0.1062785766136377
  +0.2671169816757967  +0.1062639006229959
  +0.2668961792770926  +0.1062492008707478
     :
  -0.4105181820056077  -0.1056972929358451
  -0.4107269575583785  -0.1057019769351110
  -0.4109357228496880  -0.1057066546581591
\end{verbatim}\end{small}
\end{quote}
(The initial ``0.5'' numbers mark the corners of a $1^\circ$
square and are provided to defeat auto-scaling when plotting.)

If plotted, the locus can
be seen to follow a circle of radius \degree{0}{25}
around the zenith, in accordance with the {\tt rnogo} setting.
The spacing
of the dots is an indication of the speed, which is not constant.
However, there is no supposition that the mount will actually follow the
demands, nor are there any benefits to doing so.  The importance of
the zenith avoidance strategy lies in preventing
erratic behaviour of the
rotator and guide probes, which could waste time and leave things in
the wrong wrap state.

Note also that the locus in and out of the region
does not line up.  This is because the plot shows mount behaviour, and
in the presence of a large collimation error and (especially) a
pointing-origin that is well off-axis the mount coordinates will
not follow the star.

%-----------------------------------------------------------------------

\newpage
\subsection{Miscellaneous Files}
This final category consists of the remaining TCSpk files that do not
fit into the previous categories.

\subsubsection{The {\tt dsa.mod} example pointing-model file}
\label{dsadotmod}

The {\tt dsa.mod} file is a sample TPOINT model file used by the
{\tt tcs\_dsa} demonstration program.  Its contents are as follows:
\begin{quote}
\begin{small}
\begin{verbatim}
No observations
T    0   0.0000    0.000   0.0000
  IA        +85.0000
  IE       -100.0000
  TF        +10.0000
  CA        -70.0000
  NPAE       +8.0000
  NRX       -25.0000
  NRY       +15.0000
  CRX       +28.0000
  CRY       +22.0000
  AN         -5.0000
  AW        -12.0000
END
\end{verbatim}\end{small}
\end{quote}
The model is the standard set of geometrical terms (plus Hooke's-law
flexure) for a beam-waveguide antenna with feed horns fixed to the
building.

\subsubsection{The {\tt dsactx.h} file}
\label{dsactxdoth}

This is a header file used by the {\tt tcs\_dsa} demonstrator
application.  Like the file {\tt tcsctx.h}, it defines a data context,
in this case for a deep-space tracking antenna.  It differs from
{\tt tcsctx.h} in that certain unwanted features (such as pointing-origins
and the instrument rotator) are omitted and an additional feature
(provision for scanning) is added.  For further details, see the
section on the {\tt tcs\_dsa} program on p\pageref{tcs_dsa}.

\subsubsection{The Unix make file}
\label{makefile}

The Unix make file for TCSpk creates the subroutine library,
{\tt libtcs.a}, builds several demonstration executables and
text-file documentation for the C routines,
{\tt manual.txt}.  It is designed for Linux/gcc but
can easily be adapted for other platforms or run in an
appropriate way by overriding the defaults for the
various compiler flags {\it etc.}

Early in the makefile is a short section designed to allow
tailoring for in-house use.  As well as the compiler flags
already mentioned, there are symbols pointing to the
places where header files and object libraries are kept.

It should however be noted that most
TCS developers will find it convenient and natural to dispense with
the supplied makefile and incorporate TCSpk into local procedures.

\subsubsection{The {\tt manual} script}
\label{manual}

The Unix make file executes a {\tt perl} script called {\tt manual}
that builds a manual by extracting the program preambles (which
are formatted in a standard way to make this possible).  The
preambles are very detailed and could readily form the basis of
a set of Unix {\tt man} pages if local standards required this
to be done.

\subsubsection{The {\tt refsub.c},
                   {\tt refsub1.c} and
                   {\tt refsub2.c} files}
\label{refsub}

The {\tt refsub1.c} and {\tt refsub2.c} files are examples of
the optional ``special refraction function'':  they contain the C code
for functions called {\tt tcsRefsub} and {\tt dsaRefsub}, respectively.
The file {\tt refsub.c} is simply a copy of {\tt refsub2.c}.

Use of an optional special refraction function may be declared
in the call to {\tt medium.c}.  The nominated function will
override the results from the default
refraction calculations, which are optimized for speed and which
do not cater for extremely low elevations.  This can be important
for spacecraft tracking, where to observe low down may be
an operational imperative.  The feature is less likely to be needed on an
optical/IR telescope, because the poor seeing conditions at low
elevations inhibit such use.

The first example
{\tt refsub1.c}, is for either optical or radio, and calls the function
{\tt slaRefro} from the
SLALIB/C positional-astronomy library.  This uses
a ray-tracing approach, which is accurate
at low elevations but computationally very expensive.  The second,
{\tt refsub2.c}, is for radio only and
uses a specially developed empirical routine.

See p\pageref{dsaRefsub} and p\pageref{tcsRefsub} for the
specifications of the example refraction routines.

\subsubsection{The {\tt specimen.mod} example pointing-model file}
\label{specimendotmod}

The {\tt specimen.mod} file is a sample TPOINT model file used by the
{\tt tcs\_demo} demonstration program.  Its contents are as follows:
\begin{quote}
\begin{small}
\begin{verbatim}
No observations
T    0   0.0000    0.000   0.0000
  IH        +85.0000
  ID       -100.0000
  TF        +10.0000
  CH       -110.0000
  NP         +8.0000
  MA         -5.0000
  ME        -12.0000
END
\end{verbatim}\end{small}
\end{quote}
The model is the standard set of geometrical terms (plus Hooke's-law
flexure) for an equatorial telescope.  Note that the {\tt tcs\_demo}
program can be configured for all three types of TCSpk
mount---equatorial, altazimuth, generalized gimbal---and that
the {\tt specimen.mod} file is used only for the equatorial case.
For the other two cases, {\tt tcs\_demo} demonstrates the alternative
technique using inline code.

\ifx\vdoc\vfull
\newpage
\fi
\subsection{The SLALIB/C Subsystem}
\label{slalib}

All of TCSpk's positional astronomy calculations, and a number
of more general facilities, are provided by the SLALIB/C library.
This is a self-contained and independent subsystem which is
documented elsewhere.  All of SLALIB/C's functions are available
for use within TCSpk-based applications.

Like TCSpk (and TPOINT), all of the SLALIB/C functions are
re-entrant, and there are no global data issues (nor any input/output or
other system dependencies).

\ifx\vdoc\vfull
\vfill
\newpage
\fi
\section{THE TCSpk FILES: INDEX}

\ifx\vdoc\vshort
\abridged
\else

\vfill
\begin{center}
\begin{tabular}{lrclr}
{\tt addtrm.c    } & \pageref{tcsAddtrm}  & & {\tt rotator.c   } & \pageref{tcsRotator}  \\
{\tt aim2enc.c   } & \pageref{tcsAim2enc} & & {\tt scomp.c     } & \pageref{tptScomp}    \\
{\tt aim2s\_c.c  } & \pageref{tcsAim2s_c} & & {\tt sky2aim.c   } & \pageref{tcsSky2aim}  \\
{\tt aim2xe.c    } & \pageref{tcsAim2xe}  & & {\tt sky2a\_c.c  } & \pageref{tcsSky2a_c}  \\
{\tt aimtrk.c    } & \pageref{tcsAimtrk}  & & {\tt slow.c      } & \pageref{tcsSlow}     \\
{\tt astup.c     } & \pageref{tcsAstup}   & & {\tt specimen.mod} & \pageref{specimendotmod} \\
{\tt bs.c        } & \pageref{tcsBs}      & & {\tt spm.c       } & \pageref{tcsSpm}      \\
{\tt casspa.c    } & \pageref{tcsCasspa}  & & {\tt sterm.c     } & \pageref{tcsSterm}    \\
{\tt dsa.mod     } & \pageref{dsadotmod}  & & {\tt targup.c    } & \pageref{tcsTargup}   \\
{\tt dsactx.h    } & \pageref{dsactxdoth} & & {\tt tartr\_c.c  } & \pageref{tcsTartr_c}  \\
{\tt enc2aim.c   } & \pageref{tcsEnc2aim} & & {\tt tartran.c   } & \pageref{tcsTartran}  \\
{\tt fast.c      } & \pageref{tcsFast}    & & {\tt tcs.h       } & \pageref{tcsdoth}     \\
{\tt g2po.c      } & \pageref{tcsG2po}    & & {\tt tcsctx.h    } & \pageref{tcsctxdoth}  \\
{\tt g2tar.c     } & \pageref{tcsG2tar}   & & {\tt tcsmac.h    } & \pageref{tcsmacdoth}  \\
{\tt init2.c     } & \pageref{tcsInit2}   & & {\tt tcs\_demo.c } & \pageref{tcs_demo}    \\
{\tt intpm.c     } & \pageref{tcsIntpm}   & & {\tt tcs\_dsa.c  } & \pageref{tcs_dsa}     \\
{\tt iterm.c     } & \pageref{tcsIterm}   & & {\tt tcs\_equ.c  } & \pageref{tcs_equ}     \\
{\tt length.c    } & \pageref{tptLength}  & & {\tt tcs\_pa.c   } & \pageref{tcs_pa}      \\
{\tt makefile    } & \pageref{makefile}   & & {\tt tcs\_test.c } & \pageref{tcs_test}    \\
{\tt manual      } & \pageref{manual}     & & {\tt tcs\_tpt.c  } & \pageref{tcs_tpt}     \\
{\tt medium.c    } & \pageref{tcsMedium}  & & {\tt tcs\_zt.c   } & \pageref{tcs_zt}      \\
{\tt minit.c     } & \pageref{tptMinit}   & & {\tt term.c      } & \pageref{tptTerm}     \\
{\tt pmt.c       } & \pageref{tcsPmt}     & & {\tt time.c      } & \pageref{tcsTime}     \\
{\tt porup.c     } & \pageref{tcsPorup}   & & {\tt track.c     } & \pageref{tcsTrack}    \\
{\tt posture.c   } & \pageref{tcsPosture} & & {\tt track\_c.c  } & \pageref{tcsTrack_c}  \\
{\tt probev.c    } & \pageref{tcsProbev}  & & {\tt trmgen.c    } & \pageref{tptTrmgen}   \\
{\tt ptappl.c    } & \pageref{tptPtappl}  & & {\tt trmloc.c    } & \pageref{tptTrmloc}   \\
{\tt pterm.c     } & \pageref{tptPterm}   & & {\tt trmstd.c    } & \pageref{tptTrmstd}   \\
{\tt ptermg.c    } & \pageref{tptPtermg}  & & {\tt vtenc.c     } & \pageref{tcsVTenc}    \\
{\tt pterml.c    } & \pageref{tptPterml}  & & {\tt vtenc\_c.c  } & \pageref{tcsVTenc_c}  \\
{\tt pterms.c    } & \pageref{tptPterms}  & & {\tt vtsky.c     } & \pageref{tcsVTsky}    \\
{\tt ptpre.c     } & \pageref{tptPtpre}   & & {\tt vtsky\_c.c  } & \pageref{tcsVTsky_c}  \\
{\tt ptran.c     } & \pageref{tcsPtran}   & & {\tt vtxe.c      } & \pageref{tcsVTxe}     \\
{\tt ptrani.c    } & \pageref{tcsPtrani}  & & {\tt vtxe\_c.c   } & \pageref{tcsVTxe_c}   \\
{\tt pup.c       } & \pageref{tcsPup}     & & {\tt vtxy.c      } & \pageref{tcsVTxy}     \\
{\tt refsub.c    } & \pageref{refsub}     & & {\tt vtxy\_c.c   } & \pageref{tcsVTxy_c}   \\
{\tt refsub1.c   } & \pageref{tcsRefsub}  & & {\tt xe2xy.c     } & \pageref{tcsXe2xy}    \\
{\tt refsub2.c   } & \pageref{dsaRefsub}  & & {\tt xy2xe.c     } & \pageref{tcsXy2xe}    \\
~~~~~~~~~~~~~~   &  ~~~~~~~~~~~~~~~~  & ~~~~~~~~~~~~~~~~~  & ~~~~~~~~~~~~~~   &  ~~~~~~~~~~~~~~~~ \\
\end{tabular}
\end{center}
\vfill
\fi

\end{document}

*  Generate the LaTeX source for TCSpk manual Figure 1.

      IMPLICIT NONE

*  Overall control of shifts and scales
      REAL XZ,XS,YZ,YS
      PARAMETER (XZ=5.0,XS=1.0,YZ=-10.0,YS=0.95)

      REAL WIDTH, HW, HEIGHT, HH, XSPINE, HT, HHT, TP, HTP, YP, CL,
     :     BL, XL, XR, HB, HHB, HW09L, HW15L, HW19L, HW01, HW03,
     :     HW05, HW07, HW09, HW11, HW13, HW15, HW17, HW19, HW21,
     :     HW23, HW25, HW28, HW32, HW35, HW03R, HW05R, HW09R,
     :     HW11R, HW15R, HW17R, HW19R, HW23R, HW25R, HW28R,
     :     HW32R, YC01, YC02B, YC02T, YC03, YC04B, YC04T, YC05,
     :     YC06B, YC06T, YC07, YC08B, YC08T, YC09, YC10B, YC10T,
     :     YC11, YC12B, YC12T, YC13, YC14B, YC14T, YC15, YC16B,
     :     YC16T, YC17, YC18B, YC18T, YC19, YC20B, YC20T, YC21,
     :     YC22B, YC22T, YC23, YC24B, YC24T, YC25, YC26B, YC26T,
     :     YC27, YC28, YC29, YC30B, YC30T, YC31, YC32, YC33,
     :     YC34B, YC34T, YC35

*  Backslash character
      CHARACTER BS

*  Inline functions applying shifts and scales
      REAL C,W,H,X,Y
      W(C)=XS*C
      H(C)=YS*C
      X(C)=XZ+W(C)
      Y(C)=YZ+H(C)

      DATA BS /'\\'/




*  Generate LaTeX preamble.
      CALL PRE


*  ------------------
*  Overall dimensions
*  ------------------

      WIDTH = W(160.0)
      HW = WIDTH/2.0
      HEIGHT = H(190.0)
      HH = HEIGHT/2.0

!      CALL BOX(HW,HH,WIDTH,HEIGHT,' ')

*  -----------------
*  Length increments
*  -----------------

*  Spine
      XSPINE = HW

*  Text height
      HT = H(4.5)
      HHT = HT/2.0

*  Text pitch
      TP = HT+H(0.5)
      HTP = TP/2.0

*  Basic Y pitch, e.g. distance between successive captions
      YP = H(9.5)

*  Length of line between successive captions
      CL = YP-TP

*  Length of line between box and caption
      BL = CL

*  Left column
      XL = XSPINE-W(45.0)

*  Right column
      XR = XSPINE+W(45.0)

*  Box height
      HB = H(8.5)
      HHB = HB/2.0

*  --------------------------------
*  Box and string half-widths: left
*  --------------------------------

*  x,y
      HW09L = W(8.0)

*  B
      HW15L = W(6.0)

*  A
      HW19L = W(6.0)

*  ---------------------------------
*  Box and string half-widths: spine
*  ---------------------------------

*  [0,0,1]
      HW01 = W(9.0)

*  OTA/pitch non-perpendicularity
      HW03 = W(30.0)

*  vertical deflection
      HW05 = W(17.0)

*  TELESCOPE
      HW07 = W(26.0)

*  [xi,eta]
      HW09 = W(6.5)

*  guiding
      HW11 = W(8.0)

*  BORESIGHT
      HW13 = W(27.0)

*  pitch
      HW15 = W(6.5)

*  roll/pitch nonperpendicularity
      HW17 = W(29.0)

*  roll
      HW19 = W(5.0)

*  AIM
      HW21 = W(19.0)

*  mount orientation
      HW23 = W(18.0)

*  refraction
      HW25 = W(10.0)

*  between Earth rotation and [h,d]->[a,e]
      HW28 = W(14.0)

*  aberration
      HW32 = W(16.0)

*  TARGET
      HW35 = W(19.0)

*  ---------------------------------
*  Box and string half-widths: right
*  ---------------------------------

*  CA
      HW03R = W(3.5)

*  VD
      HW05R = HW03R

*  rotator angle
      HW09R = W(12.5)

*  GA,GB
      HW11R = W(6.0)

*  IB
      HW15R = HW03R

*  NP
      HW17R = HW03R

*  IA
      HW19R = HW03R

*  AW,AN
      HW23R = W(6.5)

*  weather, color
      HW25R = W(13.0)

*  site location, UT1
      HW28R = W(16.0)

*  TT
      HW32R = W(4.0)

*  ------------------
*  Positions of items
*  ------------------

*  01  [1,0,0]
      YC01 = H(10.0)

*  02  line
      YC02B = YC01+HHB
      YC02T = YC02B+BL

*  03  OTA/pitch non-perpendicularity
      YC03 = YC02T+HHT

*  04  line
      YC04B = YC03+HHT
      YC04T = YC04B+CL

*  05  vertical deflection
      YC05 = YC04T+HHT

*  06  line
      YC06B = YC05+HHT
      YC06T = YC06B+BL

*  07  TELESCOPE
      YC07 = YC06T+HHB

*  08  line
      YC08B = YC07+HHB
      YC08T = YC08B+BL

*  09  xi,eta
      YC09 = YC08T+HHT

*  10  line
      YC10B = YC09+HHT
      YC10T = YC10B+BL

*  11  guiding
      YC11 = YC10T+HHT

*  12  line
      YC12B = YC11+HHT
      YC12T = YC12B+BL

*  13  BORESIGHT
      YC13 = YC12T+HHB

*  14  line
      YC14B = YC13+HHB
      YC14T = YC14B+BL

*  15  pitch
      YC15 = YC14T+HHT

*  16  line
      YC16B = YC15+HHT
      YC16T = YC16B+BL

*  17  roll/pitch non-perpendicularity
      YC17 = YC16T+HHT

*  18  line
      YC18B = YC17+HHT
      YC18T = YC18B+BL

*  19  roll
      YC19 = YC18T+HHT

*  20  line
      YC20B = YC19+HHT
      YC20T = YC20B+BL

*  21  AIM
      YC21 = YC20T+HHB

*  22  line
      YC22B = YC21+HHB
      YC22T = YC22B+BL

*  23  mount orientation
      YC23 = YC22T+HHT

*  24  line
      YC24B = YC23+HHT
      YC24T = YC24B+BL

*  25  refraction
      YC25 = YC24T+HHT

*  26  line
      YC26B = YC25+HHT
      YC26T = YC26B+BL

*  27  [h,d]->[a,e]
      YC27 = YC26T+HHT

*  28  site location, UT1
      YC28 = YC27+HHT

*  29  Earth rotation
      YC29 = YC27+TP

*  30  line
      YC30B = YC29+HHT
      YC30T = YC30B+BL

*  31  precession-nutation
      YC31 = YC30T+HHT

*  32  aberration
      YC32 = YC31+TP

*  33  light deflection
      YC33 = YC32+TP

*  34  line
      YC34B = YC33+HHT
      YC34T = YC34B+BL

*  35  TARGET
      YC35 = YC34T+HHB

*  ----------------------
*  Generate LaTeX diagram
*  ----------------------

*  Spine

      CALL OBOX(XSPINE,YC01,HW01*2.0,HB,'[1,0,0]')
*
      CALL LINE(XSPINE,YC02B,XSPINE,YC02T)
      CALL STRING(XSPINE,YC03,
     :            '{' // BS // 'it OTA/pitch non-perpendicularity}')
      CALL LINE(XSPINE,YC04B,XSPINE,YC04T)
      CALL STRING(XSPINE,YC05,
     :            '{' // BS // 'it vertical deflection}')
      CALL ARROW(XSPINE,YC06B,XSPINE,YC06T)
*
      CALL OBOX(XSPINE,YC07,HW07*2.0,HB,'TELESCOPE [$x_T,y_T,z_T$]')
*
      CALL LINE(XSPINE,YC08B,XSPINE,YC08T)
      CALL STRING(XSPINE,YC09,'{'//BS//'it [$'//BS//'xi,'//BS//'eta$]}')
      CALL LINE(XSPINE,YC10B,XSPINE,YC10T)
      CALL STRING(XSPINE,YC11,'{'//BS//'it guiding}')
      CALL LINE(XSPINE,YC12B,XSPINE,YC12T)
*
      CALL OBOX(XSPINE,YC13,HW13*2.0,HB,'BORESIGHT [$x_B,y_B,z_B$]')
*
      CALL LINE(XSPINE,YC14B,XSPINE,YC14T)
      CALL STRING(XSPINE,YC15,'{'//BS//'it pitch}')
      CALL LINE(XSPINE,YC16B,XSPINE,YC16T)
      CALL STRING(XSPINE,YC17,
     :                   '{'//BS//'it roll/pitch non-perpendicularity}')
      CALL LINE(XSPINE,YC18B,XSPINE,YC18T)
      CALL STRING(XSPINE,YC19,'{'//BS//'it roll}')
      CALL LINE(XSPINE,YC20B,XSPINE,YC20T)
*
      CALL OBOX(XSPINE,YC21,HW21*2.0,HB,'AIM [$x_A,y_A,z_A$]')
*
      CALL ARROW(XSPINE,YC22T,XSPINE,YC22B)
      CALL STRING(XSPINE,YC23,'{'//BS//'it mount orientation}')
      CALL LINE(XSPINE,YC24B,XSPINE,YC24T)
      CALL STRING(XSPINE,YC25,'{'//BS//'it refraction}')
      CALL LINE(XSPINE,YC26B,XSPINE,YC26T)
      CALL STRING(XSPINE,YC27,
     :  '{'//BS//'it [$h,'//BS//'delta$]$'//BS//'rightarrow$[$az,el$]}')
      CALL STRING(XSPINE,YC29,'{'//BS//'it Earth rotation}')
      CALL LINE(XSPINE,YC30B,XSPINE,YC30T)
      CALL STRING(XSPINE,YC31,'{'//BS//'it precession-nutation}')
      CALL STRING(XSPINE,YC32,'{'//BS//'it aberration}')
      CALL STRING(XSPINE,YC33,'{'//BS//'it light deflection}')
      CALL ARROW(XSPINE,YC34B,XSPINE,YC34T)
*
      CALL OBOX(XSPINE,YC35,HW35*2.0,HB,
     :            'TARGET [$'//BS//'alpha,'//BS//'delta$]')

*  Left

      CALL OBOX(XL,YC09,HW09L*2.0,HB,'$x,y$')
      CALL ARROWD(XL+HW09L,YC09,XSPINE-HW09,YC09)

      CALL OBOX(XL,YC15,HW15L*2.0,HB,'$B$')
      CALL ARROWD(XL+HW15L,YC15,XSPINE-HW15,YC15)

      CALL OBOX(XL,YC19,HW19L*2.0,HB,'$A$')
      CALL ARROWD(XL+HW19L,YC19,XSPINE-HW19,YC19)

*  Right

      CALL STRING(XR,YC03,'{'//BS//'scriptsize'//BS//'sf CA}')
      CALL ARROW(XR-HW03R,YC03,XSPINE+HW03,YC03)

      CALL STRING(XR,YC05,'{'//BS//'scriptsize'//BS//'sf VD}')
      CALL ARROW(XR-HW05R,YC05,XSPINE+HW05,YC05)

      CALL STRING(XR,YC09,'{'//BS//'small rotator angle}')
      CALL ARROW(XR-HW09R,YC09,XSPINE+HW09,YC09)

      CALL STRING(XR,YC11,'{'//BS//'scriptsize'//BS//'sf GA,GB}')
      CALL ARROW(XR-HW11R,YC11,XSPINE+HW11,YC11)

      CALL STRING(XR,YC15,'{'//BS//'scriptsize'//BS//'sf IB}')
      CALL ARROW(XR-HW15R,YC15,XSPINE+HW15,YC15)

      CALL STRING(XR,YC17,'{'//BS//'scriptsize'//BS//'sf NP}')
      CALL ARROW(XR-HW17R,YC17,XSPINE+HW17,YC17)

      CALL STRING(XR,YC19,'{'//BS//'scriptsize'//BS//'sf IA}')
      CALL ARROW(XR-HW19R,YC19,XSPINE+HW19,YC19)

      CALL STRING(XR,YC23,'{'//BS//'scriptsize'//BS//'sf AW,AN}')
      CALL ARROW(XR-HW23R,YC23,XSPINE+HW23,YC23)

      CALL STRING(XR,YC25,'{'//BS//'small weather, color}')
      CALL ARROW(XR-HW25R,YC25,XSPINE+HW25,YC25)

      CALL STRING(XR,YC28,'{'//BS//'small site location, UT1}')
      CALL ARROW(XR-HW28R,YC28,XSPINE+HW28,YC28)

      CALL STRING(XR,YC32,'{'//BS//'small TT}')
      CALL ARROW(XR-HW32R,YC32,XSPINE+HW32,YC32)


*  Generate LaTeX postamble.
      CALL POST

      END


      SUBROUTINE STRING(X,Y,S)

*  String S at coordinates X,Y.

      IMPLICIT NONE
      REAL X,Y
      CHARACTER*(*) S
      CHARACTER BS
      DATA BS /'\\'/
      WRITE (*,'(1X,A,''put('',F7.2,'','',F7.2,'')'//
     : '{'',A,''makebox(0,0){'',A,''}}'')')
     : BS,X,Y,BS,S
      END


      SUBROUTINE BOX(X,Y,W,H,S)

*  Rectangular box centred on X,Y dimensions W,H containing string S.

      IMPLICIT NONE
      REAL X,Y,W,H
      CHARACTER*(*) S
      CHARACTER BS
      DATA BS /'\\'/
      WRITE (*,'(1X,A,''put('',F7.2,'','',F7.2,'')'//
     : '{'',A,''framebox('',F7.2,'','',F7.2,''){'',A,''}}'')')
     : BS,X-W/2.0,Y-H/2.0,BS,W,H,S
      END


      SUBROUTINE OBOX(X,Y,W,H,S)

*  Rounded box centred on X,Y dimensions W,H containing string S.

      IMPLICIT NONE
      REAL X,Y,W,H
      CHARACTER*(*) S
      CHARACTER BS
      DATA BS /'\\'/
      WRITE (*,'(1X,A,''put('',F7.2,'','',F7.2,'')'//
     : '{'',A,''oval('',F7.2,'','',F7.2,'')}'')')
     : BS,X,Y,BS,W,H
      CALL STRING(X,Y,S)
      END


      SUBROUTINE ARROW(X1,Y1,X2,Y2)

*  Arrow from X1,Y1 to X2,Y2.

      IMPLICIT NONE
      REAL X1,Y1,X2,Y2
      CALL LV('vector',X1,Y1,X2,Y2)
      END


      SUBROUTINE ARROWD(X1,Y1,X2,Y2)

*  Double-headed arrow between X1,Y1 and X2,Y2.

      IMPLICIT NONE
      REAL X1,Y1,X2,Y2
      CALL ARROW(X1,Y1,X2,Y2)
      CALL ARROW(X2,Y2,X1,Y1)
      END


      SUBROUTINE LINE(X1,Y1,X2,Y2)

*  Line from X1,Y1 to X2,Y2.

      IMPLICIT NONE
      REAL X1,Y1,X2,Y2
      CALL LV('line',X1,Y1,X2,Y2)
      END


      SUBROUTINE DLINE(X1,Y1,X2,Y2,D)

*  Dotted line from X1,Y1 to X2,Y2 pitch D.

      IMPLICIT NONE
      REAL X1,Y1,X2,Y2,D
      REAL XA,XB,YA,YB,DA,XL,YL,RN,DX,DY,RI,RIP
      INTEGER N,I
      IF (X2.GE.X1) THEN
         XA=X1
         XB=X2
      ELSE
         XA=X2
         XB=X1
      END IF
      IF (Y2.GE.Y1) THEN
         YA=Y1
         YB=Y2
      ELSE
         YA=Y2
         YB=Y1
      END IF
      IF (D.NE.0.0) THEN
         DA=ABS(D)
      ELSE
         DA=0.5
      END IF
      XL=XB-XA
      YL=YB-YA
      N=MAX(1,NINT(SQRT(XL*XL+YL*YL)/DA))
      IF (MOD(N,2).EQ.0) N=N+1
      RN=REAL(N)
      DX=XL/RN
      DY=YL/RN
      DO I=0,N,2
         RI=REAL(I)
         RIP=REAL(I+1)
         CALL LINE(XA+DX*RI,YA+DY*RI,XA+DX*RIP,YA+DY*RIP)
      END DO
      END


      SUBROUTINE LV(S,X1,Y1,X2,Y2)

*  Line of type S from X1,Y1 to X2,Y2.

      IMPLICIT NONE
      CHARACTER*(*) S
      REAL X1,Y1,X2,Y2
      REAL DX,DY,D,T
      INTEGER IX,IY,I
      CHARACTER BS
      DATA BS /'\\'/
      DX=X2-X1
      DY=Y2-Y1
      D=MAX(ABS(DX),ABS(DY))
      IF (D.NE.0.0) THEN
         T=ATAN2(Y2-Y1,X2-X1)
         IX=NINT(6.0*COS(T))
         IY=NINT(6.0*SIN(T))
         DO I=6,2,-1
            IF (MOD(IX,I).EQ.0.AND.MOD(IY,I).EQ.0) THEN
               IX=IX/I
               IY=IY/I
            END IF
         END DO
         WRITE (*,'(1X,A,''put('',F7.2,'','',F7.2,''){'',2A,'//
     : '''('',I2,'','',I2,''){'',F7.2,''}}'')')
     : BS,X1,Y1,BS,S,IX,IY,D
      END IF
      END


      SUBROUTINE CIRCLE(X,Y,R)

*  Circle of radius R centred on X,Y.

      IMPLICIT NONE
      REAL X,Y,R
      CHARACTER BS
      DATA BS /'\\'/
      WRITE (*,'(1X,'//
     :   'A,''put('',F7.2,'','',F7.2,''){'',A,''circle{'',F7.2,''}}'')')
     : BS,X,Y,BS,R*2.0
      END


      SUBROUTINE BLOB(X,Y,R)

*  Blob of radius R centred on X,Y.

      IMPLICIT NONE
      REAL X,Y,R
      CHARACTER BS
      DATA BS /'\\'/
      WRITE (*,'(1X,//
     :   A,''put('',F7.2,'','',F7.2,''){'',A,''circle*{'',F7.2,''}}'')')
     : BS,X,Y,BS,R*2.0
      END


      SUBROUTINE PRE

*  Preamble to make output a self-contained LaTeX file.

      IMPLICIT NONE

      WRITE (*,'(1X,A)') '\documentclass[12pt,fleqn,twoside]{article}'
      WRITE (*,'(1X,A)') '\setlength{\unitlength}{1mm}'
      WRITE (*,'(1X,A)') '\setlength{\topmargin}{-15mm}'
      WRITE (*,'(1X,A)') '\setlength{\textwidth}{155mm}'
      WRITE (*,'(1X,A)') '\setlength{\textheight}{250mm}'
      WRITE (*,'(1X,A)') '\setlength{\oddsidemargin}{0mm}'
      WRITE (*,'(1X,A)') '\setlength{\evensidemargin}{0mm}'
      WRITE (*,'(1X,A)') '\setlength{\parindent}{0em}'
      WRITE (*,'(1X,A)') '\setlength{\parskip}{1.5ex}'
      WRITE (*,'(1X,A)') '\pagestyle{empty}'
      WRITE (*,'(1X,A)') '\begin{document}'
      WRITE (*,'(1X,A)') '\begin{center}'
      WRITE (*,'(1X,A)') '\vspace*{\fill}'
      WRITE (*,'(1X,A)') '\thicklines'
      WRITE (*,'(1X,A/)') '\begin{picture}(160,90)(0,0)'
      END



      SUBROUTINE POST

*  Preamble to make output a self-contained LaTeX file.

      IMPLICIT NONE

      WRITE (*,'(/1X,A)') '\end{picture}'
      WRITE (*,'(1X,A)') '\vspace*{\fill}'
      WRITE (*,'(1X,A)') '\end{center}'
      WRITE (*,'(1X,A)') '\end{document}'
      END



!!! not used !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      SUBROUTINE LITERAL(S)
      IMPLICIT NONE
      CHARACTER*(*) S
      WRITE (*,'(1X,A)') S
      END


      SUBROUTINE DBOX(X,Y,W,H,S)

*  Dotted rectangular box centred on X,Y dimensions W,H containing
*  string S.

      IMPLICIT NONE
      REAL X,Y,W,H
      CHARACTER*(*) S
      REAL D,XL,XR,YB,YT
      XL=X-W/2.0
      XR=X+W/2.0
      YB=Y-H/2.0
      YT=Y+H/2.0
      D=0.3
      CALL DLINE(XL,YB,XL,YT,D)
      CALL DLINE(XL,YT,XR,YT,D)
      CALL DLINE(XR,YT,XR,YB,D)
      CALL DLINE(XR,YB,XL,YB,D)
      CALL STRING(X,Y,S)
      END

      SUBROUTINE MASK (N,I4,I5,I6,I7,I8,I9,I10,I11,I12)
      IMPLICIT NONE
      INTEGER N,I4,I5,I6,I7,I8,I9,I10,I11,I12
      CHARACTER*5 COLOUR
      CHARACTER BS
      DATA BS /'\\'/
      IF (N.EQ.I4.OR.
     :    N.EQ.I5.OR.
     :    N.EQ.I6.OR.
     :    N.EQ.I7.OR.
     :    N.EQ.I8.OR.
     :    N.EQ.I9.OR.
     :    N.EQ.I10.OR.
     :    N.EQ.I11.OR.
     :    N.EQ.I12) THEN
         COLOUR='black'
      ELSE
         COLOUR='light'
      END IF
      WRITE (*,'(1X,A)') BS//'color{'//COLOUR//'}'
      END

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

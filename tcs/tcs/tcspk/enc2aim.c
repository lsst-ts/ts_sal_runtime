#include "tcs.h"

void tcsEnc2aim ( double enca, double encb,
                  double xb, double yb, double zb,
                  double ia, double ib, double np,
                  double *xa, double *ya, double *za )

/*
**  - - - - - - - - - - -
**   t c s E n c 2 a i m
**  - - - - - - - - - - -
**
**  In a "virtual telescope", calculate the AIM vector that corresponds
**  to the specified encoder readings and BORESIGHT vector.
**
**  Given:
**     enca     double        mount "roll" encoder demand (Note 2)
**     encb     double        mount "pitch" encoder demand (Note 2)
**     xb       double        BORESIGHT x-coordinate
**     yb       double        BORESIGHT y-coordinate
**     zb       double        BORESIGHT z-coordinate
**     ia       double        roll zero point (radians)
**     ib       double        pitch zero point (radians)
**     np       double        mount axes nonperpendicularity (radians)
**
**  Returned:
**     xa       double*       AIM x-coordinate
**     ya       double*       AIM y-coordinate
**     za       double*       AIM z-coordinate
**
**  Called:  tcsPosture
**
**  Notes:
**
**  1  A "virtual telescope" is a group of transformations that link
**     three sets of coordinates:
**
**       (i)  the target (where in the sky the source is);
**
**      (ii)  the pointing-origin (where in the focal plane the image
**            appears);
**
**     (iii)  the mount encoder readings (that cause the image of the
**            target to fall in the specified place in the focal plane).
**
**     The transformations are specified by various time-dependent
**     rotation matrices, pointing corrections, functions of rotator
**     angle and so on.  They form a chain:
**
**
**                [ TARGET ]             -> target [a,b]
**                     |
**        astronomical transformations   <- time, site
**                     |
**                 refraction            <- weather
**                     |
**              mount orientation        <- ae2mt
**                     |
**                  [ AIM ]
**                     ^
**                   roll                <- encoder a, and ia
**                     ^
**            roll/pitch nonperp         <- np
**                     ^
**                   pitch               <- encoder b, and ib
**                     ^
**               [ BORESIGHT ]
**                     |
**                  guiding              <- ga, gb
**                     |
**               pointing origin         <- [x,y] and rotator angle
**                     |
**               [ TELESCOPE ]
**                     |
**                   flop                <- vertical deflection terms
**                     |
**             tel/pitch nonperp         <- collimation terms
**                     |
**                 [ 1,0,0 ]
**
**
**     Given any two of the three sets of coordinates (sky, pointing-
**     origin, mount), the missing coordinates can be deduced.  There is
**     only one mount, and hence all the virtual telescopes must share
**     the same encoder demands, namely those generated by the main
**     "mount tracking" virtual telescope.  The remaining virtual
**     telescopes implement such features as autoguiding and tip/tilt
**     secondary optics, either by deducing the image position for a
**     given target, or deducing the sky coordinates that correspond to
**     a given place in the focal plane.
**
**     In the present case, the AIM vector that corresponds to the given
**     BORESIGHT vector and the encoder readings is calculated, as shown
**     by the arrows.
**
**  2  If the mount is an altazimuth, enca is pi-azimuth and encb is
**     elevation.  If the mount is an equatorial, enca is -HA and encb
**     is declination.
**
**  3  This routine is optimized for speed, and accordingly no validation
**     of the arguments is performed.  It is the caller's responsibility
**     to supply sensible values.
**
**  Last revision:   20 February 2002
**
**  Copyright P.T.Wallace.  All rights reserved.
*/

{
   double a, b, p[3][3];



/* Incorporate the index errors. */
   a = enca + ia;
   b = encb + ib;

/* Obtain the posture matrix:  rotates b(y) then np(x) then -a(z). */
   tcsPosture ( a, b, np, p );

/* Rotate frame of BORESIGHT, giving AIM. */
   *xa = p[0][0] * xb + p[0][1] * yb + p[0][2] * zb;
   *ya = p[1][0] * xb + p[1][1] * yb + p[1][2] * zb;
   *za = p[2][0] * xb + p[2][1] * yb + p[2][2] * zb;

}

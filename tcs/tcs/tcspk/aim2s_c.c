#include "tcs.h"
#include "tcsmac.h"

void tcsAim2s_c ( double xa, double ya, double za,
                  double spm1_i[3][3],
                  FRAMETYPE frame, double sst, double cst,
                  double spm2_i[3][3],
                  double *xtar, double *ytar, double *ztar )

/*
**  - - - - - - - - - - -
**   t c s A i m 2 s _ c
**  - - - - - - - - - - -
**
**  In a "virtual telescope", use the two inverse sky-patch matrices and
**  an intermediate rotation to transform the AIM vector into the target
**  position in Cartesian form.
**
**  Given:
**     xa          double         AIM x-coordinate (Note 1)
**     ya          double         AIM y-coordinate (Note 1)
**     za          double         AIM z-coordinate (Note 1)
**     spm1_i      double[3][3]   inverse SPM #1 (Note 3)
**     frame       FRAMETYPE      tracking frame ID (Note 3)
**     sst         double         sine of LAST (Notes 2,3)
**     cst         double         cosine of LAST (Notes 2,3)
**     spm2_i      double[3][3]   inverse SPM #2 (Note 3)
**
**  Returned:
**     xtar        double*        target x-coordinate
**     ytar        double*        target y-coordinate
**     ztar        double*        target z-coordinate
**
**  Defined in tcsmac.h:
**     FRAMETYPE   enum           frame types
**     AZEL_TOPO   FRAMETYPE      topocentric Az/El
**
**  Notes:
**
**  1  A "virtual telescope" is a group of transformations that link
**     three sets of coordinates:
**
**       (i)  the target (where in the sky the source is);
**
**      (ii)  the pointing-origin (where in the focal plane the image
**            appears);
**
**     (iii)  the mount encoder readings (that cause the image of the
**            target to fall in the specified place in the focal plane).
**
**     The transformations are specified by various time-dependent
**     rotation matrices, pointing corrections, functions of rotator
**     angle and so on.  They form a chain:
**
**
**                [ TARGET ]             -> target [a,b]
**                     ^
**        astronomical transformations   <- time, site
**                     ^
**                 refraction            <- weather
**                     ^
**              mount orientation        <- ae2mt
**                     ^
**                  [ AIM ]
**                     |
**                   roll                <- encoder a, and ia
**                     |
**            roll/pitch nonperp         <- np
**                     |
**                   pitch               <- encoder b, and ib
**                     |
**               [ BORESIGHT ]
**                     |
**                  guiding              <- ga, gb
**                     |
**               pointing origin         <- [x,y] and rotator angle
**                     |
**               [ TELESCOPE ]
**                     |
**                   flop                <- vertical deflection terms
**                     |
**             tel/pitch nonperp         <- collimation terms
**                     |
**                 [ 1,0,0 ]
**
**
**     Given any two of the three sets of coordinates (sky, pointing-
**     origin, mount), the missing coordinates can be deduced.  There is
**     only one mount, and hence all the virtual telescopes must share
**     the same encoder demands, namely those generated by the main
**     "mount tracking" virtual telescope.  The remaining virtual
**     telescopes implement such features as autoguiding and tip/tilt
**     secondary optics, either by deducing the image position for a
**     given target, or deducing the sky coordinates that correspond to
**     a given place in the focal plane.
**
**     In the present case, the sky coordinates are predicted (in
**     Cartesian form), starting from the AIM vector, as shown by the
**     arrows.
**
**  2  The arguments sst and cst are the sine and cosine of the local
**     apparent sidereal time.  Neither is used if the target frame is
**     topocentric Az/El.
**
**  3  The way frame, spm1_i, sst, cst and spm2_i are used depends on
**     the type of target coordinates:
**
**       frame        FK4
**       target       Bxxxx RA,Dec, current date
**       spm1_i       mean RA,Dec <- geocentric apparent RA,Dec
**       sst,cst      RA,Dec <- HA,Dec
**       spm2_i       geocentric HA,Dec <- AIM
**
**       frame        FK5
**       target       Jxxxx RA,Dec, current date
**       spm1_i       mean RA,Dec <- geocentric apparent RA,Dec
**       sst,cst      RA,Dec <- HA,Dec
**       spm2_i       geocentric HA,Dec <- AIM
**
**       frame        APPT
**       target       geocentric apparent RA,Dec
**       spm1_i       identity matrix
**       sst,cst      RA,Dec <- HA,Dec
**       spm2_i       geocentric HA,Dec <- AIM
**
**       frame        APPT_TOPO
**       target       topocentric apparent RA,Dec
**       spm1_i       identity matrix
**       sst,cst      RA,Dec <- HA,Dec
**       spm2_i       topocentric HA,Dec <- AIM
**
**       frame        AZEL_TOPO
**       target       topocentric Az,El (N thru E)
**       spm1_i       identity matrix
**       sst,cst      not used
**       spm2_i       topocentric Az,El <- AIM
**
**     ICRS = FK5 J2000 to better than 25 mas.
**
**  Last revision:   4 May 2005
**
**  Copyright P.T.Wallace.  All rights reserved.
*/

{
   double x1, y1, z1, x2, y2, z2, x3, y3, z3, w;



/* AIM vector to apparent -HA,Dec (except for Az/El case). */
    x1 = spm2_i[0][0] * xa + spm2_i[0][1] * ya + spm2_i[0][2] * za;
    y1 = spm2_i[1][0] * xa + spm2_i[1][1] * ya + spm2_i[1][2] * za;
    z1 = spm2_i[2][0] * xa + spm2_i[2][1] * ya + spm2_i[2][2] * za;

/* Earth rotation, giving apparent RA,Dec (except for Az/El case). */
    if (frame != AZEL_TOPO) {
       x2 = cst * x1 - sst * y1;
       y2 = sst * x1 + cst * y1;
    } else {
       x2 = x1;
       y2 = y1;
    }
    z2 = z1;

/* To tracking frame. */
    x3 = spm1_i[0][0] * x2 + spm1_i[0][1] * y2 + spm1_i[0][2] * z2;
    y3 = spm1_i[1][0] * x2 + spm1_i[1][1] * y2 + spm1_i[1][2] * z2;
    z3 = spm1_i[2][0] * x2 + spm1_i[2][1] * y2 + spm1_i[2][2] * z2;

/* Re-normalize (fast). */
    w = ( 3.0 - ( x3 * x3 + y3 * y3 + z3 * z3 ) ) / 2.0;
    *xtar = x3 * w;
    *ytar = y3 * w;
    *ztar = z3 * w;

}

#include "tcs.h"
#include "tcsmac.h"

void tcsAimtrk ( double xa, double ya, double za,
                 ROTLOC rotl, double rotap, double ap, double bp,
                 double xim, double yim,
                 double ia, double ib, double np,
                 double xt, double yt, double zt,
                 double ga, double gb, double rnogo,
                 double *enca1, double *encb1,
                 double *enca2, double *encb2, int *j )

/*
**  - - - - - - - - - -
**   t c s A i m t r k
**  - - - - - - - - - -
**
**  Part of the main telescope tracking routine:  in a "virtual
**  telescope", calculate the encoder demands required to image the
**  target that corresponds to a given AIM vector at a specified place
**  in the focal plane.
**
**  Given:
**     xa       double        AIM x-coordinate (Note 1)
**     ya       double        AIM y-coordinate (Note 1)
**     za       double        AIM z-coordinate (Note 1)
**     rotl     ROTLOC        rotator location
**     rotap    double        predicted rotator mechanical angle (Note 2)
**     ap       double        predicted roll (Note 3)
**     bp       double        predicted pitch (Note 3)
**     xim      double        pointing origin x (in focal lengths)
**     yim      double        pointing origin y (in focal lengths)
**     ia       double        roll zero point (radians)
**     ib       double        pitch zero point (radians)
**     np       double        mount axes nonperpendicularity (radians)
**     xt       double        telescope vector, x-component (Note 4)
**     yt       double        telescope vector, y-component (Note 4)
**     zt       double        telescope vector, z-component (Note 4)
**     ga       double        guiding correction, collimation
**     gb       double        guiding correction, pitch
**     rnogo    double        radius of "no go" region (radians, Note 5)
**
**  Returned:
**     enca1    double        roll coordinate, first solution (Note 6)
**     encb1    double        pitch coordinate, first solution (Note 6)
**     enca2    double        roll coordinate, second solution (Note 6)
**     encb2    double        pitch coordinate, second solution (Note 6)
**     j        int           status: +1 = pole avoidance (Note 7)
**                                     0 = OK
**                                    -1 = no solutions (Note 7)
**
**  Defined in tcsmac.h:
**     PI           double    Pi
**     PI2          double    2Pi
**     TINY         double    a small number
**     ROTLOC       enum      rotator locations
**
**  Called:  tcsAim2enc
**
**  Notes:
**
**  1  A "virtual telescope" is a group of transformations that link
**     three sets of coordinates:
**
**       (i)  the target (where in the sky the source is);
**
**      (ii)  the pointing-origin (where in the focal plane the image
**            appears);
**
**     (iii)  the mount encoder readings (that cause the image of the
**            target to fall in the specified place in the focal plane).
**
**     The transformations are specified by various time-dependent
**     rotation matrices, pointing corrections, functions of rotator
**     angle and so on.  They form a chain:
**
**
**                [ TARGET ]             <- target [a,b]
**                     v
**        astronomical transformations   <- time, site
**                     v
**                 refraction            <- weather
**                     v
**              mount orientation        <- ae2mt
**                     v
**                  [ AIM ]
**                     |                 }
**                   roll                }
**                     |                 } -> encoder [a,b]
**            roll/pitch nonperp         }
**                     |                 } <- np, ia, ib
**                   pitch               }
**                     |                 }
**               [ BORESIGHT ]
**                     ^
**                  guiding              <- ga, gb
**                     ^
**               pointing origin         <- [x,y] and rotator angle
**                     ^
**               [ TELESCOPE ]
**                     ^
**                   flop                <- vertical deflection terms
**                     ^
**             tel/pitch nonperp         <- collimation terms
**                     ^
**                 [ 1,0,0 ]
**
**
**     Given any two of the three sets of coordinates (sky, pointing-
**     origin, mount), the missing coordinates can be deduced.  There is
**     only one mount, and hence all the virtual telescopes must share
**     the same encoder demands, namely those generated by the main
**     "mount tracking" virtual telescope.  The remaining virtual
**     telescopes implement such features as autoguiding and tip/tilt
**     secondary optics, either by deducing the image position for a
**     given target, or deducing the sky coordinates that correspond to
**     a given place in the focal plane.
**
**     In the present case, the encoder demands required to image the
**     target corresponding to the specified AIM vector at the specified
**     pointing-origin are calculated.
**
**  2  The predicted rotator angle rotap is the orientation that the
**     mechanical rotator (whether at a coude or Nasmyth focus, or
**     mounted on the OTA) is expected to reach at the time for which
**     the prediction is being made.  Note that it is the predicted
**     achieved position, not a demand position.
**
**  3  The arguments ap and bp are an estimate of the coordinates
**     a and b which are being computed.  The results are not very
**     sensitive to the values used.
**
**  4  The TELESCOPE vector [xt,yt,zt] is in this frame:
**
**       x-axis:  at right angles to both the roll and pitch axes
**       y-axis:  along the pitch axis
**       z-axis:  at right angles to the other two axes
**
**     In the absence of either collimation error or vertical deflection
**     the TELESCOPE vector is [1,0,0].
**
**  5  Near the pole of the mounting (i.e. the zenith in the case of an
**     altazimuth) a variety of problems arises.  These include
**     confusion about which way round to go, rivalry between the mount
**     and rotator, and cases for which there are no solutions (see also
**     Note 7).  In any event, there are limits to what speeds and
**     accelerations the mechanical drives can achieve.  The present
**     routine provides one strategy for avoiding difficulties in this
**     region.
**
**     The argument rnogo specifies how close to the pole of the
**     mounting the target is allowed to be.  If the target is too
**     close, the routine aims instead for a fictitious target further
**     out, on the edge of the forbidden region.  A warning status is
**     set when this "pole avoidance" action is taken.
**
**     It is permissible to set rnogo to zero, and to handle any pole
**     problems in the TCS application itself.  Two strategies that
**     might be considered as an alternative to the rnogo approach are
**     (i) progressive scaling back of certain of the pointing
**     coefficients so that close to the pole the mount becomes
**     nominally perfect, and (ii) substituting a fictitious target that
**     makes the telescope loiter on the edge of the awkward region
**     until the real target catches up.
**
**  6  If the mount is an altazimuth, the roll coordinate is pi-azimuth
**     and the pitch coordinate is elevation.  If the mount is an
**     equatorial, roll is -HA and pitch is declination.  For any
**     accessible target, there are two solutions; depending on the type
**     of mount, the two solutions correspond to above/below the pole,
**     nearside/farside of the zenith, east/west of the pier, and so on.
**
**  7  Near the pole of the mounting, especially when the collimation
**     error or nonperpendicularity are large, there may be no mount
**     posture that images the target at the desired place.  In these
**     cases, the status j is set to the "no solutions" value, and the
**     returned roll and pitch are set to safe values.
**
**     The "no solution" status overrides the "pole avoidance" status
**     (see Note 5).
**
**  Last revision:   8 December 2006
**
**  Copyright P.T.Wallace.  All rights reserved.
*/

/* dmod(A,B) - A modulo B (double) */
#define dmod(A,B) ((B)!=0.0?((A)*(B)>0.0?(A)-(B)*floor((A)/(B))\
                                        :(A)+(B)*floor(-(A)/(B))):(A))
{
   int nudged, notok;
   double x, y, z, w, a1, b1, a2, b2;



/*
** ------------------------------------------
** SKY target coordinates to ENCODER readings
** ------------------------------------------
*/

/* The AIM vector. */
   x = xa;
   y = ya;
   z = za;

/* Check for pole avoidance. */
   if ( ( w = sqrt ( x*x + y*y ) ) > rnogo ){
      nudged = 0;
   } else {
      if ( x == 0.0 && y == 0.0 ) x = w = TINY;
      w = rnogo / w;
      x *= w;
      y *= w;
      z = sqrt ( 1.0 - x*x - y*y );
      nudged = 1;
   }

/* AIM to ENCODER readings. */
   tcsAim2enc ( x, y, z, rotl, rotap, ap, bp, xim, yim,
                ia, ib, np, xt, yt, zt, ga, gb,
                &a1, &b1, &a2, &b2, &notok );

/*
** -------
** Results
** -------
*/

/* Solution 1 roll coordinate, in range +/- pi. */
   w = dmod ( a1, PI2 );
   if ( fabs ( w ) >= PI ) w += w < 0.0 ? PI2 : - PI2;
   *enca1 = w;

/* Solution 1 pitch. */
   *encb1 = b1;

/* Solution 2 roll coordinate, in range +/- pi. */
   w = dmod ( a2, PI2 );
   if ( fabs ( w ) >= PI ) w += w < 0.0 ? PI2 : - PI2;
   *enca2 = w;

/* Solution 2 pitch. */
   *encb2 = b2;

/* Status. */
   *j = notok ? -1 : nudged;

}
